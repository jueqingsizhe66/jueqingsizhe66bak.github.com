<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | 网络书屋(Web Reading Room)]]></title>
  <link href="http://jueqingsizhe66.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://jueqingsizhe66.github.io/"/>
  <updated>2017-08-13T21:47:14+08:00</updated>
  <id>http://jueqingsizhe66.github.io/</id>
  <author>
    <name><![CDATA[Ye Zhaoliang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What Vim Teaches You?]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2017/08/13/what-vim-teaches-you/"/>
    <updated>2017-08-13T05:14:47+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2017/08/13/what-vim-teaches-you</id>
    <content type="html"><![CDATA[<p>vim真正教会了你什么？</p>

<p>vim带给你激情，也给了你生活的智趣，从一开始你练习<a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/">Learn-vim-progressively</a>,并且现在还在练习macro和vim&rsquo;s text object.
也在不断的学习marks and tags思想，让生活轨迹有迹可循，你使用<a href="#ctrlspace">CtrlSpace</a>来保证你的workspace保存下来，并切换文件和buffer；
随着知识的增长，你使用<a href="#vimwiki">vimwiki</a>来管理你的知识，并结合<a href="https://github.com/mattn/calendar-vim">calendar</a>在vimwiki来管理你的日记。为了让文件查找，文件编辑更加方便，你使用
<a href="https://github.com/Shougo">shoudo</a>的<a href="https://github.com/Shougo/vimfiler.vim">vimfiles</a>来增强你的vim，使得你的vim变得更像一把瑞士军刀。</p>

<ul>
<li><a href="#ctrl-space">1. Ctrl-Space Plugin</a></li>
<li><a href="#vimwiki">2. Knowledge tool: Vimwiki</a></li>
<li><a href="#vimfiler">3. Vimfiles: file operation</a></li>
<li><a href="#star">4. Menu for your vim:Startify</a></li>
<li><a href="#att">5. Attach File </a></li>
</ul>


<!--more-->


<p>为了多一点对称美，你使用高丽棒作者<a href="https://github.com/junegunn">junegunn</a>的<a href="https://github.com/junegunn/vim-easy-align">vim-easy-align</a> (<font color="red">Note: <a href="https://github.com/junegunn/vim-easy-align/blob/master/EXAMPLES.md#formatting-yaml-or-json">many examples</a></font>),为了少犯错误，你加入了<a href="https://github.com/chip/vim-fat-finger">vim-fat-finger</a>,使用iabbrev来缩写你需要写的单词，或者修正错误的单词,为了编辑更加有效,你甚至引入了<a href="https://github.com/terryma/vim-multiple-cursors">vim-multiline-cursor</a>, 并进一步的你引入了<a href="https://github.com/tpope">tpope</a>的<a href="https://github.com/tpope/vim-surround">vim-surround</a>让你在书写racket(当然你也可以使用<a href="https://github.com/ruanyl/bigvim">delimiteMate</a>补全括号插件)或者lisp代码的时候更加方便一些，并为了重复或者递归使用，你也引入他的<a href="https://github.com/tpope/vim-repeat">vim-repeat</a> (vim中的很多插件都是支持增强的，比如f的增强插件<a href="https://rhysd.github.io/clever-f.vim/">clever-f</a>);为了更快捷的编辑文件行，除了使用vim text object, 你也引入了<a href="https://github.com/matze/vim-move">vim-move</a>和<a href="https://github.com/easymotion/vim-easymotion">vim-easymotion</a> (<font color="red">Very Good</font>)来移动行,使得vim文本更加结构化。</p>

<p>想着让你的vim运行得更快一些，你把你一直用的<a href="https://github.com/VundleVim/Vundle.vim">vundle</a>改为了的<a href="https://github.com/junegunn">junegunn</a><a href="https://github.com/junegunn/vim-plug">vim-plug</a>来管理你的插件,确没见得有太大的改进，简洁地使用plugins自然就快了。</p>

<p><img src="/images/AboutVim/fuck.png" alt="vim startup" /></p>

<p>可以看到你的其实也增加了<a href="#star">Startify</a>的配置。</p>

<p>然而，上面这些都是你想让vim做的，下面要写的则是<font color="red">vim plugins带给你关于写作的新的概念和思想</font>，这也才是本文的重点。</p>

<p>刚开始接触vim的时候，你是用了scrooloose的<a href="https://github.com/scrooloose/nerdtree">nerdtree</a> ,<a href="https://github.com/majutsushi/tagbar">tagbar</a>,<a href="https://github.com/vim-airline/vim-airline">vim airline</a>等，你也使用了各种<a href="https://github.com/WolfgangMehner/vim-plugins">language support vim plugins</a>,也知道vim使用<a href="https://github.com/tpope">tpope</a>的<a href="https://github.com/airblade/vim-gitgutter">vim-gitgutter</a>结合git管理code, 现在让我们来看第一个vim插件ctrl-space</p>

<h3 id="ctrlspace"> 1. Ctrl-Space Plugin</h3>


<p>Github Repo: Click <a href="https://github.com/vim-ctrlspace/vim-ctrlspace">here</a></p>

<p>vim help: <code>:h ctrlspace</code></p>

<p><font color="red">核心概念:</font></p>

<p>当你在vim中使用<code>:h ctrlspace</code>时候会搜索到这些资料，</p>

<p>```
【1.vim desktop】: Let&rsquo;s imagine [ Vim ] is a writing desk.
【2.projects draws】 : Your [ projects ] are like drawers.
【3.Bookmark  favorite project】:  The [ Bookmark ] List simply displays your favorite projects.
【4.Buffer  paper】: A [ buffer ] is like a sheet of paper lying on the desk.</p>

<pre><code>    named buffers
    unsaved buffers
</code></pre>

<p>【5.workspace  an status snapshot of current project】:All your [ buffers ], [ tabs ], and [ tab ] layouts can be persisted as a workspace.
It&rsquo;s like taking a picture of your desk with an instant camera. You can
save multiple workspaces per project with Workspace List.
【6.workspace  session】 : The word &ldquo;workspace&rdquo; can be considered a synonym of a &ldquo;session&rdquo;. The
ability of having so many sessions available at hand creates a lot of
interesting use cases! For example, you can have a workspace for each task
or feature you are working on. It&rsquo;s very easy to switch from one workspace
to another.
```</p>

<p>```</p>

<p>然后以后可以使用大写的B，跳转到Bookmark标签栏，类似于CtrlSpace的哲学思想，会跳转到某个bookmark下的目录，通过C也可以，直接Enter《CR》键也是可以的。
删除觉得不需要了，就D一下即可。
```</p>

<p><tag>: The easiest way to think about tab pages in Vim is to consider them to be viewports, layouts, or workspaces</p>

<p>```
tags是一个在编程中经常会使用
而且在git的版本中也经常涉及到很多打tag的工作 (git tag  or  git tag  -a)   git checkout某个tag等</p>

<p>其实tags只不过是对事物的一种抽象，这也是你在现实当中经常看到的class field method 注释等等，其实都可以把他们理解为一种tag，一种convinience tag
```</p>

<p>在vimwiki的wiki文件的简单实用方法(经常用！！！):</p>

<p>```
:标签名字:</p>

<p>[[文件名#标签名字]]即可
```</p>

<p>相同vim tag概念
```</p>

<p>&ldquo;&rdquo; tab encapsulation
&ldquo; tab 操作
&rdquo; <a href="http://vim.wikia.com/wiki/Alternative_tab_navigation">http://vim.wikia.com/wiki/Alternative_tab_navigation</a>
&ldquo; <a href="http://stackoverflow.com/questions/2005214/switching-to-a-particular-tab-in-vim">http://stackoverflow.com/questions/2005214/switching-to-a-particular-tab-in-vim</a></p>

<p>&ldquo; tab切换
map <leader>th :tabfirst<cr>
map <leader>tl :tablast<cr></p>

<p>map <leader>tj :tabnext<cr>
map <leader>tk :tabprev<cr>
map <leader>tn :tabnext<cr>
map <leader>tp :tabprev<cr></p>

<p>map <leader>te :tabedit<cr>
map <leader>td :tabclose<cr>
map <leader>tm :tabm<cr></p>

<p>&ldquo; normal模式下切换到确切的tab
noremap <leader>1 1gt
noremap <leader>2 2gt
noremap <leader>3 3gt
noremap <leader>4 4gt
noremap <leader>5 5gt
noremap <leader>6 6gt
noremap <leader>7 7gt
noremap <leader>8 8gt
noremap <leader>9 9gt
noremap <leader>0 :tablast<cr></p>

<p>&ldquo; Toggles between the active and last active tab &rdquo;
&ldquo; The first tab is always 1 &rdquo;
let g:last_active_tab = 1
&ldquo; nnoremap <leader>gt :execute &lsquo;tabnext &rsquo; . g:last_active_tab<cr>
&rdquo; nnoremap <silent> &lt;c-o> :execute &lsquo;tabnext &rsquo; . g:last_active_tab<cr>
&ldquo; vnoremap <silent> &lt;c-o> :execute &lsquo;tabnext &rsquo; . g:last_active_tab<cr>
nnoremap <silent> <leader>tt :execute &lsquo;tabnext &rsquo; . g:last_active_tab<cr>
autocmd TabLeave * let g:last_active_tab = tabpagenr()</p>

<p>&ldquo; 新建tab  Ctrl+t
nnoremap &lt;C-t>     :tabnew<CR>
inoremap &lt;C-t>     <Esc>:tabnew<CR></p>

<p>```</p>

<h4>默认工作类型目录</h4>

<p><code>``
Markers will be also used as a storage for</code>cs_workspaces<code>(workspaces of
the current project) and</code>cs_files` (cached files of the current project).</p>

<p>Default value: ></p>

<pre><code>let g:CtrlSpaceProjectRootMarkers = [
     \ ".git",
     \ ".hg",
     \ ".svn",
     \ ".bzr",
     \ "_darcs",
     \ "CVS"
     \ ]
</code></pre>

<p>```</p>

<p><font color="RED">Summary:</font></p>

<p>```
   A buffer is the in-memory text of a file.
   A window is a viewport on a buffer.
   A tab page is a collection of windows.</p>

<p>A window is a viewport onto a buffer.  You can use multiple windows on one
buffer, or several windows on different buffers.</p>

<p>A buffer is a file loaded into memory for editing.  The original file remains
unchanged until you write the buffer to the file.</p>

<p>```</p>

<h3 id="vimwiki">2. Knowledge tool: Vimwiki</h3>


<p>Github Repo: Click <a href="https://github.com/vimwiki/vimwiki">here</a></p>

<h4>vimwki setup in vimrc:</h4>

<p><code>
• """"""""""""""""""""""""""""""""""""""""""""""""""  
• " vimwiki  
• let g:vimwiki_use_mouse = 1  
• let g:vimwiki_list_ignore_newline = 0  
• let g:vimwiki_hl_headers = 0  
• " vimwiki打开折叠  
• "let g:vimwiki_folding = 1  
• let g:vimwiki_camel_case = 0  
• let g:vimwiki_list_ignore_newline = 0  
• let g:vimwiki_CJK_length = 1  
•   
• "设定文件浏览器目录为当前目录  
• set bsdir=buffer      
• "set autochdir  
•   
• " 日历插件  
• map ca :Calendar&lt;cr&gt;  
•   
• map &lt;S-Space&gt; :&lt;C-Space&gt;  
•   
• " vimwiki  
• let g:vimwiki_list = [{'path': '~/Wiki/wiki/', 'path_html': '~/Wiki/', 'auto_export': 1}]  
• " 转化为Html文件  
• map &lt;S-F4&gt; :Vimwiki2HTML&lt;cr&gt;  
•   
• " 设置颜色  
• hi VimwikiHeader1 guifg=#FF0000  
• hi VimwikiHeader2 guifg=#00FF00  
• hi VimwikiHeader3 guifg=#0000FF  
• hi VimwikiHeader4 guifg=#FF00FF  
• hi VimwikiHeader5 guifg=#00FFFF  
hi VimwikiHeader6 guifg=#FFFF00  
</code></p>

<h4>vimwiki tagbar 集成</h4>

<h2>```</h2>

<p>Tagbar integration                                            <em>vimwiki-tagbar</em></p>

<p>As an alternative to the Table of Contents, you can use the Tagbar plugin
(<a href="http://majutsushi.github.io/tagbar/">http://majutsushi.github.io/tagbar/</a>) to show the headers of your wiki files
in a side pane.
Download the Python script from
<a href="https://raw.githubusercontent.com/vimwiki/utils/master/vwtags.py">https://raw.githubusercontent.com/vimwiki/utils/master/vwtags.py</a> and follow
the instructions in it.
```</p>

<p>效果如下，</p>

<p><img src="/images/AboutVim/tagbar.png" alt="tagbar" /></p>

<h3 id="vimfiler"> 3. Vimfiles: A tool for file operations </h3>


<p>Github Repo: click <a href="https://github.com/Shougo/vimfiler.vim"> here </a></p>

<p>vimfiler setup in vimrc</p>

<p>```
&ldquo;for vimfiler
let g:vimfiler_enable_auto_cd=1
"call vimfiler#set_execute_file(&lsquo;txt&rsquo;, &lsquo;notepad&rsquo;)
call vimfiler#set_execute_file(&lsquo;txt&rsquo;, &lsquo;gvim&rsquo;)
call vimfiler#set_execute_file(&lsquo;c&rsquo;, [&lsquo;gvim&rsquo;, &lsquo;notepad&rsquo;])</p>

<p>let g:vimfiler_as_default_explorer = 1</p>

<p>&ldquo; Enable file operation commands.
&rdquo; Edit file by tabedit.
&ldquo;call vimfiler#custom#profile(&lsquo;default&rsquo;, &lsquo;context&rsquo;, {
&rdquo;      \ &lsquo;safe&rsquo; : 0,
&ldquo;      \ &lsquo;edit_action&rsquo; : &lsquo;tabopen&rsquo;,
&rdquo;      \ })</p>

<p>&ldquo; Like Textmate icons.
let g:vimfiler_tree_leaf_icon = &lsquo; &rsquo;
"let g:vimfiler_tree_closed_icon = &lsquo;▸&rsquo;
"let g:vimfiler_tree_opened_icon = &lsquo;▾&rsquo;
let g:vimfiler_file_icon = &lsquo;&ndash;&rsquo;
let g:vimfiler_marked_file_icon = &lsquo;*&rsquo;</p>

<p>let g:vimfiler_safe_mode_by_default=0</p>

<pre><code>" Use trashbox.
" Windows only and require latest vimproc.
</code></pre>

<p>let g:unite_kind_file_use_trashbox = 1
&ldquo;&rdquo;  you can create a .vim file, then source it
&ldquo;need everything.exe
"nnoremap <Leader>f :Unite file buffer file_rec file_mru everything<CR>
nnoremap <Leader>f :VimFiler<CR>
nnoremap <leader>l :Unite line<CR>
let g:unite_source_everything_limit = 100
let g:unite_source_everything_full_path_search = 1
let g:unite_source_everything_posix_regexp_search = 1
let g:unite_source_everything_async_minimum_length = 3
let g:unite_source_everything_cmd_path = &lsquo;C:\Users\YeZhao\.vim\es\es.exe&rsquo;</p>

<p>```</p>

<p>由于vimfiler的使用也了解到了 <a href="https://github.com/ggreer/the_silver_searcher">ag</a>插件（一个特别好用的搜索插件,在ubuntu底下直接使用ag &ldquo;expression&rdquo; 找到当前文件夹所有文件内容  包含表达式的行数据 相当快速）</p>

<p>```
H作用打开shell  x打开文件夹的意思</p>

<p>L打开磁盘
Load
&amp;回到project目录  那是相当有用的
~回到.vim目录</p>

<p>e编写文件
N 创建文件
K创建文件夹</p>

<h1>全选</h1>

<p>*全部选？</p>

<p>c复制
d删除
m移动</p>

<p>先用m表示选定 然后d删除(重要操作)
m移动
c复制
```</p>

<p><strong><u>有意思的是:</u></strong></p>

<p>使用m然后r，可以跳出一个新的编辑窗口，进行文件名的修改，这是相当好的实现。</p>

<p>转化为HTML</p>

<p><code>vim
:Vimwiki2HTML – Convert current wiki page to HTML
:VimwikiAll2HTML – Convert all your wiki pages to HTML
</code></p>

<h3 id="star"> 4. Startify Plugin</h3>


<p>Github Repo: click <a href="https://github.com/mhinz/vim-startify"> here </a></p>

<h4>vim 全屏</h4>

<p>``` vim
let w:full_screen=0</p>

<pre><code>map :call FullScreen()
</code></pre>

<p>func! FullScreen()</p>

<pre><code>if w:full_screen==1
let w:full_screen=0
:simalt ~R
else
:simalt ~X
let w:full_screen=1
endif
</code></pre>

<p>endfunc
```</p>

<h4>vim-easy-align常用命令</h4>

<p>vim help: <code>:h easyalign</code></p>

<p>vip=  Enter=   EnterEnter=(居右，居中，居左对其选项 )</p>

<p>```
gaip=</p>

<p> &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
 Delimiter key | Description/Use cases                                              ~
 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
 <Space>       | General alignment around whitespaces</p>

<pre><code>`:`            | Suitable for formatting JSON or YAML
</code></pre>

<p>  <code>=</code>            | Operators containing equals sign ( <code>=</code> ,  <code>==,</code>  <code>!=</code> ,  <code>+=</code> ,  <code>&amp;&amp;=</code> , &hellip;)
  <code>.</code>            | Multi-line method chaining
  <code>,</code>            | Multi-line method arguments
  <code>&amp;</code>            | LaTeX tables (matches  <code>&amp;</code>  and  <code>\\</code> )
  <code>#</code>            | Ruby/Python comments
  <code>"</code>            | Vim comments
 <Bar>         | Table markdown
 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>  &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
 With visual map   | Description                        | Equivalent command ~
 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
 <Enter><Space>    | Around 1st whitespaces             | :&lsquo;&lt;,&rsquo;>EasyAlign\
 <Enter>2<Space>   | Around 2nd whitespaces             | :&lsquo;&lt;,&rsquo;>EasyAlign2\
 <Enter>&ndash;<Space>   | Around the last whitespaces        | :&lsquo;&lt;,&rsquo;>EasyAlign-\
 <Enter>-2<Space>  | Around the 2nd to last whitespaces | :&lsquo;&lt;,&rsquo;>EasyAlign-2\
 <Enter>:          | Around 1st colon ( <code>key:  value</code> )   | :&lsquo;&lt;,&rsquo;>EasyAlign:
 <Enter><Right>:   | Around 1st colon ( <code>key : value</code> )   | :&lsquo;&lt;,&rsquo;>EasyAlign:<l1
 <Enter>=          | Around 1st operators with =        | :&lsquo;&lt;,&rsquo;>EasyAlign=
 <Enter>3=         | Around 3rd operators with =        | :&lsquo;&lt;,&rsquo;>EasyAlign3=
 <Enter><em>=         | Around all operators with =        | :&lsquo;&lt;,&rsquo;>EasyAlign</em>=
 <Enter><strong>=        | Left-right alternating around =    | :&lsquo;&lt;,&rsquo;>EasyAlign</strong>=
 <Enter><Enter>=   | Right alignment around 1st =       | :&lsquo;&lt;,&rsquo;>EasyAlign!=
 <Enter><Enter><strong>= | Right-left alternating around =    | :&lsquo;&lt;,&rsquo;>EasyAlign!</strong>=
 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>

<p>```</p>

<h4>vim-surround 常用命令</h4>

<p><code>
1. cs"'
2. cs'"
3. cs'&lt;q&gt;
5. cs"t
4. cst"
6. ds"
7. ysiw"
8. yssb == yss)  
9. S"  可视化模式选择快 然后大S，这点类似于Multiple-Cursor的Ctrl+N命令
</code></p>

<h4>vim copy file name</h4>

<p>你使用<a href="https://github.com/AdamWhittingham/vim-copy-filename">vim-copy-filename</a>
<code>
"" for vim-copy-filename
nmap &lt;leader&gt;cp :CopyRelativePath&lt;CR&gt;
nmap &lt;leader&gt;cl :CopyRelativePathAndLine&lt;CR&gt;
nmap &lt;leader&gt;cP :CopyAbsolutePath&lt;CR&gt;
nmap &lt;leader&gt;cf :CopyFileName&lt;CR&gt;
nmap &lt;leader&gt;cd :CopyDirectoryPath&lt;CR&gt;
</code></p>

<p>额外一些插件的备注</p>

<ol>
<li><a href="https://github.com/haya14busa"> Haya14busa </a>提供的<a href="https://github.com/haya14busa/incsearch.vim"> incsearch </a> 增加了statusline的查找词当前数 和总个数</li>
<li><a href="https://github.com/itchyny/vim-cursorword"> Vim-cursorword </a>表示添加下划线。</li>
<li><a href="https://github.com/AndrewRadev/splitjoin.vim"> AndrewRadev/splitjoin.vim  </a>是提供类似于perl的当行模式的插件[gS gJ]。在scheme估计比较少用到。</li>
</ol>


<p>一直遗忘的一个快捷查看命令
<code>Ctrl+E</code> 往下滚屏  <code>Ctrl+Y</code> 往上滚屏</p>

<p><code>
运行的话,进入底线命令模式,用:!perl %就可以运行,或者可以绑定一个快捷键组合, %表示当前文件的意思
</code></p>

<p>最后，编辑器界面展示的应全是代码，不应该有<u>工具条、菜单、滚动条</u>浪费空间的元素，另外，编程是种<font color="red">精神高度集中的脑力劳动</font>，不应出现<s>闪烁光标、花哨鼠标</s>这些分散注意力的东东</p>

<p>```
写到这边我去睡觉了，梦中梦到了前半辈子比较重要的三个女人，我妈以及另外两个从小长大的妇女(不说女生了),街道上偶遇她们正在端着一个冰盒沿街发送，也不像是生了孩子似的，但梦中是那么真实又带着虚的东西（所以人是一个最精良的仪器，拥有最直觉的第六感，又拥有最会惹事的直觉），我妈骑着自行车从我们三身边走过，前方又出现一个特别活泼的"妇女",在我的环境中还有篮球这一个概念，我的梦（由我的身体+癫痫的精神状态+疲惫产生的一种组合的事件）把我带到一个篮球场，后来我又去了</p>

<p>我一个哥们那边，终于有男的出现，我发现我走过的路总是不缺乏女生(所以我是趋向于好色之徒,本来也是), 我梦到了我儿时的
阴影我特别怕的一个男生，喜欢拿刀砍人，犯冲，特别好斗，但缺少脑子。我写出来了，因为我想克服它。梦向黄大仙一样，它放屁的效果具有致幻的效果，能让人陷入幻境中不得自拔，人每天晚上也像黄大仙附体一样坐着春秋大梦。</p>

<p>但从我身边路过的那些女生，都已经变得不真实，我身边有一个wife如胶似漆的黏着我，怎么我就不懂珍惜呢。时代的进步，需要梦的催化，世界上无德的传销机构也在利用着洗脑在铸造着同一类人，这些人把思维当作无趣，而非智趣。</p>

<p>匆匆而过三十载，岁月不饶人，也不等人(也就是你学会了用时间的非定常特性来观察人生）。乐观、不自信一直伴随着我成长，然而我却不知道痛苦才是生活的本源，享受
痛苦，才能拥有些许的快乐。Enjoy Painess!但我不想把pain带给亲人，身边的人。我是一个自私的人，没有团队精神，不太会
替别人考虑的人（当然自从有了她，我得替她考虑，但是考虑得还很少，我很对不起她）</p>

<p>也就是生活的智趣源于痛苦，痛苦的根源诞生了时代的进步，和智趣的发展。</p>

<p>写到这边，就先停笔把，继续回到vim当中，他也像人，能够感知到字符的变化，感知文本结构（你赋予了它思考的能力），能够
让你编辑得更顺畅些;vim像刀、人也可以像刀，磨砺你自己这把最重要的一把刀把！</p>

<p>```</p>

<p>必然对偶然，自由对随机，自由在必然中，随机在偶然中，原来这才是自由(<a href="http://www.huzheng.org/geniusreligion/TheSourceCodeOfMyWorld.pdf">胡正自由</a>是有代价的)。</p>

<h3 id="att"> 5. Attach File </h3>


<ul>
<li>Windows Version dotVim Repo: <a href="http://pan.baidu.com/s/1ge3EbZX"> here </a></li>
<li>Ubuntu Version dotVim Repo: <a href="http://pan.baidu.com/s/1slQA3JB"> here </a></li>
</ul>


<p>在终端使用vim编辑命令的方式:</p>

<p>在~目录下创建一个.inputrc文件，内容如下</p>

<p>```
set editing-mode vi
Control-a: beginning-of-line
Control-b: backward-char
Control-d: delete-char
Control-e: end-of-line
Control-f: forward-char
Control-k: kill-line
Control-n: next-history
Control-p: previous-history
set keymap emacs-ctlx
v: vi-editing-mode
Control-v: &ldquo;\C-xv\e&rdquo;
Escape: &ldquo;\C-xv\e&rdquo;
set keymap emacs
$if Bash
  Control-w: unix-filename-rubout
$endif</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[批量修改pdf文件名以及创建wiki Links]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2017/07/05/pi-liang-xiu-gai-pdfwen-jian-ming-yi-ji-chuang-jian-wiki-links/"/>
    <updated>2017-07-05T17:03:07+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2017/07/05/pi-liang-xiu-gai-pdfwen-jian-ming-yi-ji-chuang-jian-wiki-links</id>
    <content type="html"><![CDATA[<p>bash、awk、sed等的好处，就是可以专一的完成你的需求，但是也存在很多不足，借着批量重命令和批量导出链接到vimwiki的wiki中，形成[[local:文件名路径]]的过程，巩固学习linux命令, it is homework(learning process)。</p>

<!--more-->


<h2>提取路径，用于vimwiki中，当作快速链接</h2>

<ul>
<li><p>如果IFS是"&ldquo;，那么相当于一个文件名特别长会分成很多行显示，所以这边设置为
IFS=$&lsquo;\n&rsquo;</p></li>
<li><p>[a-z]star替换原先的star，目的是去除点号。</p></li>
<li>使用echo和管道命令传递信息给sed或者awk等</li>
<li>在sed中似乎用^$等位置字符进行替换,如果是文件夹则进行名字替换，并且遍历当前文件夹</li>
<li>使用双重for循环进行控制</li>
</ul>


<p>```
IFS=$&lsquo;\n&rsquo;;
count=1;
countDir=1;
specialCharacter=&lsquo;pages&rsquo;;
generateChapter() # @Description : 对不同文件进行不同处理</p>

<pre><code>              # @usage       : generatechapter
</code></pre>

<p>{</p>

<pre><code># 妙用find 得到当前目录的相对路径 不需要不断的进入目录
for var2 in `find . -name "[a-z]*"`
do
    if [[ -d  $var2 ]] # &lt; cannot . Error
    then
        #echo "fuck"
        var=`echo $var2|sed 's/^./F:\/ScienceBase.Attachments\/WindEnergy/g'|sed 's/^/[[local:/g'|sed 's/$/]]/g'`
        printf "= $countDir. [ ] $var =\n" # 使用#号来删除之前的点号
        countDir=$(($countDir+1));

        for tempVar in `find $var2 -name "*.pdf"`
        do
            temp1=`echo $tempVar|sed 's/^./F:\/ScienceBase.Attachments\/WindEnergy/g'` 
#            # echo ${var2} ${var2:0:$((${var2}-18))}.pdf  
             varr=`echo $temp1|sed 's/^/[[local:/g'|sed 's/$/]]/g'`;
            #var=`echo $var2|sed 's/^./F:\/ScienceBase.Attachments\/WindEnergy/g'|sed 's/^/[[local:/g'|sed 's/$/]]/g'` 
            printf "\t$count. [ ] ${varr}\n" # 这边需要去除到第一个点号,这是才得到的处理方法
            count=$(($count+1));

        done
        count=1;
    fi


done
</code></pre>

<p>}</p>

<p>generateChapter</p>

<p>```</p>

<h2>删除不必要的名字特殊字符，重命名</h2>

<ul>
<li>删除文件pdf名字不必要的（pages 110&mdash;30）等信息。</li>
<li>使用awk printf产生逗号分隔字符串，使用xargs -d, mv提取以逗号分隔的字段，
并且对文件名进行重命名（在我找的多种方法中，就他有效）</li>
<li>xargs -n 2 表示按照空格划分的方式 提取两个参数，逐个进行。</li>
</ul>


<p>```</p>

<h1>!/bin/bash &ndash;</h1>

<h1>===============================================================================</h1>

<p>#</p>

<h1>FILE: b.sh</h1>

<p>#</p>

<h1>USAGE: ./b.sh</h1>

<p>#</p>

<h1>DESCRIPTION:</h1>

<p>#</p>

<h1>OPTIONS: &mdash;&ndash;</h1>

<h1>REQUIREMENTS: &mdash;&ndash;</h1>

<h1>BUGS: &mdash;&ndash;</h1>

<h1>NOTES: &mdash;&ndash;</h1>

<h1>AUTHOR: Ye Zhao Liang (Vimer), <a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#x3a;&#122;&#104;&#97;&#x6f;&#x74;&#x75;&#x72;&#x6b;&#107;&#x65;&#x79;&#x40;&#49;&#x36;&#x33;&#x2e;&#x63;&#111;&#x6d;">&#x7a;&#x68;&#x61;&#111;&#116;&#x75;&#114;&#107;&#x6b;&#x65;&#x79;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#x6d;</a></h1>

<h1>ORGANIZATION: BrokenSun</h1>

<h1>CREATED: 2017/7/4 23:01:31</h1>

<h1>REVISION:  &mdash;&ndash;</h1>

<h1>===============================================================================</h1>

<p>IFS=$&lsquo;\n&rsquo;;
count=1;
countDir=1;
specialCharacter=&lsquo;pages&rsquo;;
generateChapter() # @Description : 对不同文件进行不同处理</p>

<pre><code>              # @usage       : generatechapter
</code></pre>

<p>{</p>

<pre><code># 妙用find 得到当前目录的相对路径 不需要不断的进入目录
#for var2 in `find . -name "*"`
for var2 in `find . -name "windEnergy201*"`
do
    if [[ -d  $var2 ]] # &lt; cannot . Error
    then
            cd $var2;
            for var in `find . -name "*"`;do echo $var|awk '/pages/{printf("%s,%s",$0,substr($0,0,length($0)-22)".pdf")|"xargs -d, mv ";}';done 
            cd ..;
    fi

done
</code></pre>

<p>}</p>

<p>generateChapter</p>

<p>```</p>

<p><font color="red">注意可以使用 ，学到技巧1中的检测工具，查看你的修改是否完全正确，如果出现文件名中有逗号的情况，通常pages没有删掉，原因是xargs也是按照，号进行分割，所以改进方法是使用分号输出</font></p>

<p>改进代码
<code>``
for var in</code>find . -name &ldquo;*&rdquo;`;do echo $var|awk &lsquo;/pages/{printf(&ldquo;%s;%s&rdquo;,$0,substr($0,0,length($0)-22)&ldquo;.pdf&rdquo;)|&ldquo;xargs -d; mv &rdquo;;}&rsquo;;done</p>

<p>```</p>

<h2>最终结果</h2>

<p>```
= 1. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system]] =</p>

<pre><code>1. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch1.pdf]]
2. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch10.pdf]]
3. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch11.pdf]]
4. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch12.pdf]]
5. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch13.pdf]]
6. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch14.pdf]]
7. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch15.pdf]]
8. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch16.pdf]]
9. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch2.pdf]]
10. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch3.pdf]]
11. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch4.pdf]]
12. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch5.pdf]]
13. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch6.pdf]]
14. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch7.pdf]]
15. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch8.pdf]]
16. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch9.pdf]]
17. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/fmatter.pdf]]
18. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/index.pdf]]
19. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/scard.pdf]]
</code></pre>

<p>= 2. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/Offshore Wind Energy Generation Control, Protection, and Integration to Electrical Systems/offshoreWindEnergy]] =</p>

<pre><code>1. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/Offshore Wind Energy Generation Control, Protection, and Integration to Electrical Systems/offshoreWindEnergy/app1.pdf]]
2. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/Offshore Wind Energy Generation Control, Protection, and Integration to Electrical Systems/offshoreWindEnergy/app2.pdf]]
</code></pre>

<p>```</p>

<h2>学到的技巧</h2>

<ol>
<li>awk两种表示判断,if判断得用分号
<a href="http://blog.csdn.net/qq_31382921/article/details/55094907">如果不用分号隔开会报错</a></li>
</ol>


<p><strong>注意分号！！！</strong></p>

<p><code>
awk '{if ($1==1) print "A"; else if ($1==2) print "B"; else print "C"}'
</code></p>

<p>对应的bash使用的是if,then,else,fi的形式，且不用分号间隔语句
```</p>

<p> for var in <code>find . -name "*"</code></p>

<pre><code>do
    if [[ -d  $var ]] # &lt; cannot . Error
    then
        printf "$var\n" # 使用#号来删除之前的点号
    else
        printf "\t${var}\n" # 这边需要去除到第一个点号,这是才得到的处理方法
    fi

done
</code></pre>

<p>```</p>

<p>awk的'/page/{}&lsquo;等效于'if($0~/dfd/){}&rsquo;</p>

<p>下面的命令，也是一种检查上述程序正确与否的一种工具,可以看出哪些pdf文件依然有pages的字段</p>

<p>```
YeZhao@DESKTOP-YeZhao /cygdrive/f/ScienceBase.Attachments/WindEnergy
$ find . -name &ldquo;*&rdquo;|awk &lsquo;{if($0~/pages/){print $0}}&rsquo;
./windEnergy2009-i6/Characterizing future large, rapid changes in aggregated wind power using Numerical Weather Prediction spatial fields (pages 542–555).pdf
./windEnergy2012-i1/Modeling wake effects in large wind farms in complex terrain the problem, the methods and the issues (pages 161–182).pdf
./windEnergy2012-i2/The Betz–Joukowsky limit on the contribution to rotor aerodynamics by the British, German and Russian scientific schools (pages 335–344).pdf
./windEnergy2012-i3/Computational fluid dynamics simulation of the aerodynamics of a high solidity, small-scale vertical axis wind turbine (pages 349–361).pdf
./windEnergy2012-i3/Correction factors for NRG #40 anemometers potentially affected by dry friction whip characterization, analysis, and validation (pages 489–502).pdf
./windEnergy2012-i4/Analysis of wake measurements from the ECN Wind Turbine Test Site Wieringermeer, EWTW (pages 575–591).pdf
./windEnergy2012-i5/Atmospheric stability and turbulence fluxes at Horns Rev—an intercomparison of sonic, bulk and WRF model data (pages 717–731).pdf
./windEnergy2013-11/Modeling, simulation and control of a wind turbine with a hydraulic transmission system (pages 1259–1276).pdf
./windEnergy2013-8/Indicial lift response function an empirical relation for finite-thickness airfoils, and effects on aeroelastic simulations (pages 681–693).pdf
./windEnergy2013-8/Simulating the dynamics of wind turbine blades part I, model development and verification (pages 694–710).pdf
./windEnergy2013-8/Simulating the dynamics of wind turbine blades part鈥塈I, model validation and uncertainty quantification (pages 741–758).pdf
./windEnergy2014-2/An assessment of the impact of reduced averaging time on small wind turbine power curves, energy capture predictions and turbulence intensity measurements (pages 337–342).pdf
./windEnergy2014-9/Dynamic response analysis of wind turbines under blade pitch system fault, grid loss, and shutdown events (pages 1385–1409).pdf
./windEnergy2015-10/Rapid optimization of stall-regulated wind turbine blades using a frequency-domain method Part 1, loads analysis (pages 1703–1723).pdf
./windEnergy2015-11/Application and validation of incrementally complex models for wind turbine aerodynamics, isolated wind turbine in uniform inflow conditions (pages 1893–1916).pdf
./windEnergy2015-2/Wind turbine boundary layer arrays for Cartesian and staggered configurations Part II, low-dimensional representations via the proper orthogonal decomposition (pages 297–315).pdf
./windEnergy2015-2/Wind turbine boundary layer arrays for Cartesian and staggered configurations-Part I, flow field and power measurements (pages 277–295).pdf
./windEnergy2015-4/Utilization of machine-learning algorithms for wind turbine site suitability modeling in Iowa, USA (pages 713–727).pdf
./windEnergy2015-6/Rapid optimization of stall-regulated wind turbine blades using a frequency-domain method Part 2, cost function selection and results (pages 955–977).pdf
./windEnergy2015-7/Variable geometry wind turbine for performance enhancement, improved survivability and reduced cost of energy (pages 1303–1311).pdf
./windEnergy2016-11/Reliability of wind turbines modeled by a Poisson process with covariates, unobserved heterogeneity and seasonality (pages 1991–2002).pdf
./windEnergy2016-2/Cylindrical vortex wake model skewed cylinder, application to yawed or tilted rotors (pages 345–358).pdf
./windEnergy2016-6/Effects of low temperature on the mechanical properties of glass fibre–epoxy composites static tension, compression, R = 0.1 and R =鈭▒ 1 fatigue of ±45laminates (pages 1023–1041).pdf
./windEnergy2016-6/Failure rate, repair time and unscheduled O&amp;M cost analysis of offshore wind turbines (pages 1107–1119).pdf
./windEnergy2017-02/Verifying the Blade Element Momentum Method in unsteady, radially varied, axisymmetric loading using a vortex ring model (pages 269–288).pdf</p>

<p>```</p>

<p>2.awk的<a href="http://blog.csdn.net/panpan639944806/article/details/19932543">BEGIN</a></p>

<p>```
function name()
{}</p>

<p>BEGIN{
}
{</p>

<p>}
END{</p>

<p>}
```</p>

<p>3.awk <a href="http://blog.sina.com.cn/s/blog_67e34ceb0100ybvg.html">gsub</a></p>

<p><code>
echo "a b c 2011-11-22 a:d" | awk 'gsub(/-/,"",$4)'
</code></p>

<p>4.awk变量定义</p>

<p>BEGIN中<a href="http://blog.csdn.net/shangboerds/article/details/49449291">定义1</a>
<a href="http://jingyan.baidu.com/article/d45ad148fb46f269552b80cf.html">awk -v单行</a>定义变量</p>

<p><a href="http://www.linuxidc.com/Linux/2015-04/115781.htm">awk内置变量</a>, 包括FS,OFS,NR,NFR,NF,$0,$1,$2,ARGC,ARGV<a href="http://blog.csdn.net/panpan639944806/article/details/19932543">1</a>等。</p>

<p>5.awk定义函数</p>

<p>awk的<a href="http://bbs.chinaunix.net/thread-1424218-1-1.html">函数定义</a>是在BEGIN{},{},END{}之外的，和他们平级的关系
```</p>

<h1>!/usr/bin/awk -f</h1>

<h1>===============================================================================</h1>

<p>#</p>

<h1>File:  func.awk</h1>

<h1></h1>

<h1>Description:  awk -f func.awk file</h1>

<h1>file内容为400</h1>

<h1></h1>

<h1>VIM Version:  7.0+</h1>

<h1>Author:  Ye Zhao Liang (Vimer), <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x7a;&#104;&#97;&#111;&#x74;&#117;&#x72;&#107;&#107;&#x65;&#121;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#109;">&#122;&#x68;&#97;&#111;&#x74;&#117;&#x72;&#107;&#107;&#x65;&#x79;&#x40;&#x31;&#x36;&#x33;&#x2e;&#99;&#x6f;&#109;</a></h1>

<h1>Organization:  BrokenSun</h1>

<h1>Version:  1.0</h1>

<h1>Created:  2017/7/5 16:06:33</h1>

<h1>Revision:  &mdash;&ndash;</h1>

<h1>License:  Copyright &copy; 2017, Ye Zhao Liang</h1>

<h1>===============================================================================</h1>

<h1></h1>

<p>function b()
{
print &ldquo;b.in.$1=&rdquo;$1;
}
{
v=100; y=200
print &ldquo;a.in.v="v;
print "a.in.y="y;</p>

<p>a(y);
b();
print &ldquo;a.out.v="v;
print "a.out.y="y;
}</p>

<p>function a(y)
{
print &ldquo;(a)v="v;
v=v+$1+y;
y=300;
}</p>

<p>```</p>

<p>6.bash四种变量截取</p>

<ol type="a">
<li>${var#.*}  从左到右，满足#之后条件的最小长度</li>
<li>${var##.*}  从左到右，满足##之后条件的最大长度</li>
<li>${var%.*}  从右到左，满足%之后条件的最小长度</li>
<li>${var%%.*}  从右到左，满足%%之后条件的最小长度</li>
</ol>


<p>在awk中可以使用substr($1,0,length($1)&ndash;..)实现类似的功能。</p>

<p>7.bash中的包含关系</p>

<p>包含： 即一个大的部分包含小的部分（member)
等价： 即两个东西等价(equal)
比较：一般是两个数，另外也可以是字符串。</p>

<p>bash几种<a href="http://www.cnblogs.com/ginsonwang/p/5525340.html">包含关系用法</a></p>

<p>```
strA=&ldquo;helloworld&rdquo;
strB=&ldquo;low&rdquo;
if [[ $strA =~ $strB ]]
then</p>

<pre><code>echo "包含"
</code></pre>

<p>else</p>

<pre><code>echo "不包含"
</code></pre>

<p>fi
```</p>

<p>8.awk去除左右空格</p>

<p>第5个知识点阐述了函数的定义方式,现在来运用一下，
awk<a href="http://blog.csdn.net/bitcarmanlee/article/details/51090048">去除左右空格</a>，再一次使用中发现所有的文件名后缀中多了一个空格，于是尝试消掉空格，想着用awk实现。</p>

<p>```
function ltrim(s) { sub(/^[ \t\r\n]+/, &ldquo;&rdquo;, s); return s }
function rtrim(s) { sub(/[ \t\r\n]+$/, &ldquo;&rdquo;, s); return s }
function trim(s) { return rtrim(ltrim(s)); }
BEGIN{</p>

<pre><code>    FS=","
</code></pre>

<p>}</p>

<p>{</p>

<pre><code>    $0 = rtrim($0);
    if($2!="-" &amp;&amp; $3=="-")
            a[$4]++;
    {
    if($4!="-")
            b[$4]++;
    else
            b[$5]++;
    }
</code></pre>

<p>}</p>

<p>END{</p>

<pre><code>    print "   client    incr_num_day";
    for(i in a) printf("%10s   %d\n",i,a[i])
    print "\n\n   client    all_num";                                                                                                                                                     
    for(j in b) printf("%10s   %d\n",j,b[j]);
</code></pre>

<p>}
```</p>

<p>9.awk调用系统命令</p>

<p><a href="http://blog.csdn.net/cy_cai/article/details/41908921">方法</a></p>

<ol type="a">
<li>ready:</li>
</ol>


<p><code>
touch c.txt
touch d.txt
</code></p>

<p>II. a.txt:
<code>
c.txt
d.txt
</code></p>

<p>III. code:
```</p>

<p>awk &lsquo;{cmd=&ldquo;rm &rdquo;$0;system(cmd)}&rsquo; a.txt <br/>
```</p>

<p>10.awk重定向和管道</p>

<p>有时候直接可以在awk使用管道，提供给shell,比如<a href="http://blog.chinaunix.net/uid-25324849-id-3079511.html">print|Sort</a>,</p>

<p><code>
awk '{print $1, $2 | "sort" }'
</code></p>

<p>11.windows下的cygwin使用脚本</p>

<p>必须得使用
<code>
dos2unix.exe *脚本名字
dos2unix.exe a.sh
dos2unix.exe func.awk
</code>
这样执行shell才有效。</p>

<p>12.awk性能比shell更高</p>

<p>参考<a href="http://www.cnblogs.com/chengmo/archive/2010/10/04/1842073.html">链接</a>
```
性能比较</p>

<p>[chengmo@localhost nginx]# time (awk &lsquo;BEGIN{ total=0;for(i=0;i&lt;=10000;i++){total+=i;}print total;}&rsquo;)
50005000</p>

<p>real    0m0.003s
user    0m0.003s
sys     0m0.000s
[chengmo@localhost nginx]# time(total=0;for i in $(seq 10000);do total=$(($total+i));done;echo $total;)
50005000</p>

<p>real    0m0.141s
user    0m0.125s
sys     0m0.008s
```</p>

<p>结论：在awk中执行算术运算，比在bash中执行更好一些。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[See From NoteExpress]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2017/05/18/see-from-noteexpress/"/>
    <updated>2017-05-18T22:03:06+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2017/05/18/see-from-noteexpress</id>
    <content type="html"><![CDATA[<p><a href="http://www.inoteexpress.com/aegean/"> NoteExpress </a>是一个文档管理软件，用于管理参考文件，可以方便的word等进行关联插入相关参考文献。
然而他有一个样式编辑器,很普通，却是让我有点触动。</p>

<!--more-->


<h3>三个定义</h3>

<ol>
<li>过滤系统：让你的程序获得合适的数据，在运算系统之前.[struts的拦截器];你需要进行过滤，才能得到满足运算需要的<strong>数据</strong></li>
<li>运算系统：合适的数据进行算法运算，矩阵运算等</li>
<li>样式系统: 运算完的数据进行输出,很多美化的工作。</li>
</ol>


<p>linux的ls可以有很多选项，可以让你的结果不一样，这个选项的效果其实跟样式系统的效果是一致的，都是你对
现实的输出不满意，于是修改，使得你的输出更加perfect</p>

<p><code>
ls
ls -ls
ls -lsh  # 显示文件大小按照人类比较好识别的方式
ls -lsha # 显示隐藏文件
</code></p>

<p><a href="http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html"> awk </a>是linux重要的过滤工具，他就好象是一个鱼网过滤器一样，按照孔的形状过滤字段, 也叫做字段级别过滤器。
<a href="http://www.iteye.com/topic/587673"> sed </a>是一个行修改工具，行级别过滤器, <a href="http://blog.csdn.net/itsenlin/article/details/21129405"> 有几种典型的模式 </a>s,p,d,x,g,h etc</p>

<p>但就是这么简单的几个系统，却是组成了很多业务系统的实现过程的定义，你可以很容易把它替换成为你当前正在处理的阶段，see here to there.</p>

<h3>One Sentence</h3>

<p>每个人都应该有自己的样式系统，this is your style, nobody can change you!
Different Style System makes you different.
人应该有点脾气.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Can You See Them From Here?]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2017/05/18/can-you-see-them-from-here/"/>
    <updated>2017-05-18T20:44:59+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2017/05/18/can-you-see-them-from-here</id>
    <content type="html"><![CDATA[<h2>[[<strong>Here Song</strong>]]</h2>

<pre><code>I am here to look forward,
Nothing or many things?
I am embarrassed.

what should I do here?
What is your plan? what is your target?
Come on,Come on!
Be confident, do and do it at the best,
so you can see more from here

Life is a road with many ups and downs.
Looking at the stars in the sky, Doing at the desk in the grounds.
</code></pre>

<!--more-->


<h2>理解你的Here，才能到达There</h2>

<p>Go there Base on Here !</p>

<pre><code>千里之行，始于足下;
百层高楼，起于垒土;
</code></pre>

<p>You are Here!</p>

<ol>
<li><a href="http://think-like-a-git.net/sections/rebase-from-the-ground-up/a-helpful-mnemonic-for-git-rebase-arguments.html">git rebase Here There</a></li>
</ol>


<p><img src="/images/linux/gitflow.png" alt="gitFlow" /></p>

<p>The home faraway
<img src="/images/linux/railway.jpg" alt="railway" /></p>

<p>See the sumrise, here to go! Let&rsquo;s go!
<img src="/images/linux/time.jpg" alt="sumrise" /></p>

<ol>
<li>somethings added later</li>
</ol>


<p><a href="http://people.csail.mit.edu/sperezde/pre-print-oopsla16.pdf"> To this point </a> , you should understand that use <code>to this point</code> to let your draft become a beautiful road way in your paper.</p>

<p>To this point , you should understand why you do this action at the current time!
To this point , we can realized that there are a rule about the yaw aerodynamic characteristic.</p>

<p>With time goes on or from now on, maybe the result before us show me some infos. See from history.</p>

<p>Your need to find the failure time in the history, understand it, understand why.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash Special Annotation]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2016/09/25/bash-special-annotation/"/>
    <updated>2016-09-25T23:15:01+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2016/09/25/bash-special-annotation</id>
    <content type="html"><![CDATA[<p>关于shell的summary参看<a href="http://jueqingsizhe66.github.io/blog/2016/08/06/linux-shell-summary/#kernel">Linux Shell Summary</a></p>

<p>以下是关于bash的一些比较特殊的地方。</p>

<!--more-->


<h2>1. bash数组再理解</h2>

<p><code>declare -a</code>表示声明一个数组，类似于 <code>declare -i</code> 声明一个整数和<code>declare -x</code>声明一个环境变量。</p>

<p><font color="red">bash数组定义时候使用小括号来赋值，而在引用数组的时候反而使用中括号（不同于其他编程语言)</font></p>

<h3>定义数组</h3>

<p><code>sh
bash2=("34","5","5","4")
</code></p>

<h3>引用数组</h3>

<p><code>`` sh
echo ${array[n]}
遍历数组：
filename=(</code>ls`)
for var in ${filename[@]};do
echo $var
done</p>

<p>```</p>

<h3>添加数组</h3>

<p><code>sh
bash1+="45"; #赋值两边不能有空格
</code></p>

<h2>2. bash变量截取和变量替换</h2>

<p><font color="red">bash使用井号代表开头(这和正则表达式有点不同，使用caret)
而结尾则使用百分号(不同于正则表达式的dollar符号$)。并且在当使用两个重叠的井号，表示最大长度（从头开始的最大删除都删掉）
而使用两个百分号则表达反方向的最大长度删除（从尾到头删除匹配字符串）</p>

<ol>
<li>#表示正向最短匹配，##表示正向最大匹配</li>
<li>%表示反向最短匹配，%%表示反向最大匹配</li>
</ol>


<p>而这一点也体现在变量替换当中，</p>

<p>```
子串替换：
${string/substring/replacement}
使用$replacement来替换第一个匹配的$substring.</p>

<p>${string//substring/replacement}
使用$replacement来替换所有匹配的$substring.</p>

<p>${string/#substring/replacement}
如果$substring匹配$string的开头部分, 那么就用$replacement来替换$substring.</p>

<p>${string/%substring/replacement}
如果$substring匹配$string的结尾部分, 那么就用$replacement来替换$substring.</p>

<p>子串提取的方法主要有：直接到指定位置求子串，字符匹配求子串。
${string:position}
在$string中从位置$position开始提取子串.</p>

<p>如果$string是"*&ldquo;或者&rdquo;@&ldquo;, 那么将会提取从位置$position开始的位置参数.<a href="http://jueqingsizhe66.github.io/blog/2016/08/06/linux-shell-summary/#kernel">1</a></p>

<p>${string:position:length}
在$string中从位置$position开始提取$length长度的子串.</p>

<p>```</p>

<ol>
<li>除号表示最短替换，双除号表示最长替换</li>
<li>匹配项第一个位置出现#井号表示开头部分</li>
<li>匹配项最后一个位置出现%百分号表示结尾部分</li>
</ol>


<h2>3. bash接受键盘操作</h2>

<p>用一个read命令即可(类似于matlab的input命令)
通常的风格是 <code>read -p "prompt for reminding" variable-name</code></p>

<p>``` sh
接收键盘输入：
    read [选项] [变量名]
    选项：
        -p &ldquo;提示信息"：在等待read输入时，输出提示信息
        -t 秒数：read命令会一直等待用户输入，使用此选项可以指定等待时间
        -n 字符数：read命令只接受指定的字符数，就会执行
        -s：隐藏输入的数据，适用于机密信息的输入</p>

<p>read.sh：</p>

<h1>!/bin/bash</h1>

<p>read -p &ldquo;please input your name:&rdquo; -t 30 name
echo $name</p>

<p>read -p &ldquo;please input your passwd:&rdquo; -s passwd
echo -e &ldquo;\n&rdquo;
echo $passwd</p>

<p>read -p &ldquo;please input your sex [M/F]:&rdquo; sex
echo -e &ldquo;\n&rdquo;
echo $sex</p>

<p>```</p>

<h2>4. tac反向</h2>

<p>cat在bash中是打印文本信息的作用，而<a href="http://bbs.chinaunix.net/thread-250407-1-1.html">tac</a>则是反向输出文件流</p>

<p>``` sh
cat old_file|awk &lsquo;{print NR,$0}&rsquo;|sort -r -n|awk &lsquo;{print $2}&rsquo;</p>

<p>```</p>

<ol>
<li>添加每行的行号</li>
<li>逆向排列</li>
<li>输出每行</li>
</ol>


<h2>5. if当中也可以使用双括号进行算术判断</h2>

<p>if并不是支持正则表达式？还是只有变量支持？
``` sh
root at javazhao-N53SM [13:26:46ä��午] in /MyBashWork/clean on git:develop?
$ if [ -f &ldquo;All.sh&rdquo; ] ;then echo &ldquo;hei&rdquo;; else echo &ldquo;no&rdquo; ;fi;</p>

<p>hei</p>

<p>root at javazhao-N53SM [13:26:52ä��午] in /MyBashWork/clean on git:develop?
$ if [ -f &ldquo;*.sh&rdquo; ] ;then echo &ldquo;hei&rdquo;; else echo &ldquo;no&rdquo; ;fi;</p>

<p>no</p>

<p>但是对于变量是可以的
[root@bj_manager ~]# a=123a;if [[ $a =~ ^[0-9]+$ ]]; then echo ok; fi
[root@bj_manager ~]# a=123;if [[ $a =~ ^[0-9]+$ ]]; then echo ok; fi<br/>
```</p>

<p><font color="red">实际情况是只有在双中括号的时候才支持正则表达式</font>。<font color="green">一般是使用双中括号进行文件判断，目录判断，
文件大小判断等</font></p>

<p>if另外一个特殊地方就是使用双括号执行算术比较</p>

<p>```
708@708-PC MINGW64 /e/plGraphViz (master)
  if (( 1&lt;2 )) ;then echo &ldquo;zero&rdquo;;   echo &ldquo;a=2&rdquo;; echo &ldquo;a=3&rdquo; ;else echo &ldquo;no&rdquo;; fi;
zero
a=2
a=3</p>

<p>708@708-PC MINGW64 /e/dot(1)/testByYe
$   if [[ 1&lt;2 ]] ;then echo &ldquo;zero&rdquo;;   echo &ldquo;a=2&rdquo;; echo &ldquo;a=3&rdquo; ;else echo &ldquo;no&rdquo;; fi;
bash: unexpected token 284 in conditional command
bash: syntax error near `1&lt;'</p>

<p>```</p>

<p>而bash也一般是使用<code>$((...))</code> 进行算术的运算.</p>
]]></content>
  </entry>
  
</feed>
