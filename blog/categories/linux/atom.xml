<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | 网络书屋(Web Reading Room)]]></title>
  <link href="http://jueqingsizhe66.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://jueqingsizhe66.github.io/"/>
  <updated>2017-07-05T17:04:27+08:00</updated>
  <id>http://jueqingsizhe66.github.io/</id>
  <author>
    <name><![CDATA[Ye Zhaoliang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[批量修改pdf文件名以及创建wiki Links]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2017/07/05/pi-liang-xiu-gai-pdfwen-jian-ming-yi-ji-chuang-jian-wiki-links/"/>
    <updated>2017-07-05T17:03:07+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2017/07/05/pi-liang-xiu-gai-pdfwen-jian-ming-yi-ji-chuang-jian-wiki-links</id>
    <content type="html"><![CDATA[<p>bash、awk、sed等的好处，就是可以专一的完成你的需求，但是也存在很多不足，借着批量重命令和批量导出链接到vimwiki的wiki中，形成[[local:文件名路径]]的过程，巩固学习linux命令, it is homework(learning process)。</p>

<!--more-->


<h2>提取路径，用于vimwiki中，当作快速链接</h2>

<ul>
<li><p>如果IFS是"&ldquo;，那么相当于一个文件名特别长会分成很多行显示，所以这边设置为
IFS=$&lsquo;\n&rsquo;</p></li>
<li><p>[a-z]star替换原先的star，目的是去除点号。</p></li>
<li>使用echo和管道命令传递信息给sed或者awk等</li>
<li>在sed中似乎用^$等位置字符进行替换,如果是文件夹则进行名字替换，并且遍历当前文件夹</li>
<li>使用双重for循环进行控制</li>
</ul>


<p>```
IFS=$&lsquo;\n&rsquo;;
count=1;
countDir=1;
specialCharacter=&lsquo;pages&rsquo;;
generateChapter() # @Description : 对不同文件进行不同处理</p>

<pre><code>              # @usage       : generatechapter
</code></pre>

<p>{</p>

<pre><code># 妙用find 得到当前目录的相对路径 不需要不断的进入目录
for var2 in `find . -name "[a-z]*"`
do
    if [[ -d  $var2 ]] # &lt; cannot . Error
    then
        #echo "fuck"
        var=`echo $var2|sed 's/^./F:\/ScienceBase.Attachments\/WindEnergy/g'|sed 's/^/[[local:/g'|sed 's/$/]]/g'`
        printf "= $countDir. [ ] $var =\n" # 使用#号来删除之前的点号
        countDir=$(($countDir+1));

        for tempVar in `find $var2 -name "*.pdf"`
        do
            temp1=`echo $tempVar|sed 's/^./F:\/ScienceBase.Attachments\/WindEnergy/g'` 
#            # echo ${var2} ${var2:0:$((${var2}-18))}.pdf  
             varr=`echo $temp1|sed 's/^/[[local:/g'|sed 's/$/]]/g'`;
            #var=`echo $var2|sed 's/^./F:\/ScienceBase.Attachments\/WindEnergy/g'|sed 's/^/[[local:/g'|sed 's/$/]]/g'` 
            printf "\t$count. [ ] ${varr}\n" # 这边需要去除到第一个点号,这是才得到的处理方法
            count=$(($count+1));

        done
        count=1;
    fi


done
</code></pre>

<p>}</p>

<p>generateChapter</p>

<p>```</p>

<h2>删除不必要的名字特殊字符，重命名</h2>

<ul>
<li>删除文件pdf名字不必要的（pages 110&mdash;30）等信息。</li>
<li>使用awk printf产生逗号分隔字符串，使用xargs -d, mv提取以逗号分隔的字段，
并且对文件名进行重命名（在我找的多种方法中，就他有效）</li>
<li>xargs -n 2 表示按照空格划分的方式 提取两个参数，逐个进行。</li>
</ul>


<p>```</p>

<h1>!/bin/bash &ndash;</h1>

<h1>===============================================================================</h1>

<p>#</p>

<h1>FILE: b.sh</h1>

<p>#</p>

<h1>USAGE: ./b.sh</h1>

<p>#</p>

<h1>DESCRIPTION:</h1>

<p>#</p>

<h1>OPTIONS: &mdash;&ndash;</h1>

<h1>REQUIREMENTS: &mdash;&ndash;</h1>

<h1>BUGS: &mdash;&ndash;</h1>

<h1>NOTES: &mdash;&ndash;</h1>

<h1>AUTHOR: Ye Zhao Liang (Vimer), <a href="&#109;&#97;&#105;&#108;&#x74;&#111;&#58;&#x7a;&#x68;&#97;&#x6f;&#116;&#x75;&#x72;&#x6b;&#107;&#101;&#121;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#109;">&#x7a;&#x68;&#97;&#x6f;&#116;&#x75;&#x72;&#107;&#x6b;&#101;&#121;&#64;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#109;</a></h1>

<h1>ORGANIZATION: BrokenSun</h1>

<h1>CREATED: 2017/7/4 23:01:31</h1>

<h1>REVISION:  &mdash;&ndash;</h1>

<h1>===============================================================================</h1>

<p>IFS=$&lsquo;\n&rsquo;;
count=1;
countDir=1;
specialCharacter=&lsquo;pages&rsquo;;
generateChapter() # @Description : 对不同文件进行不同处理</p>

<pre><code>              # @usage       : generatechapter
</code></pre>

<p>{</p>

<pre><code># 妙用find 得到当前目录的相对路径 不需要不断的进入目录
#for var2 in `find . -name "*"`
for var2 in `find . -name "windEnergy201*"`
do
    if [[ -d  $var2 ]] # &lt; cannot . Error
    then
            cd $var2;
            for var in `find . -name "*"`;do echo $var|awk '/pages/{printf("%s,%s",$0,substr($0,0,length($0)-22)".pdf")|"xargs -d, mv ";}';done 
            cd ..;
    fi

done
</code></pre>

<p>}</p>

<p>generateChapter</p>

<p>```</p>

<p><font color="red">注意可以使用 ，学到技巧1中的检测工具，查看你的修改是否完全正确，如果出现文件名中有逗号的情况，通常pages没有删掉，原因是xargs也是按照，号进行分割，所以改进方法是使用分号输出</font></p>

<p>改进代码
<code>``
for var in</code>find . -name &ldquo;*&rdquo;`;do echo $var|awk &lsquo;/pages/{printf(&ldquo;%s;%s&rdquo;,$0,substr($0,0,length($0)-22)&ldquo;.pdf&rdquo;)|&ldquo;xargs -d; mv &rdquo;;}&rsquo;;done</p>

<p>```</p>

<h2>最终结果</h2>

<p>```
= 1. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system]] =</p>

<pre><code>1. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch1.pdf]]
2. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch10.pdf]]
3. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch11.pdf]]
4. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch12.pdf]]
5. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch13.pdf]]
6. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch14.pdf]]
7. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch15.pdf]]
8. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch16.pdf]]
9. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch2.pdf]]
10. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch3.pdf]]
11. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch4.pdf]]
12. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch5.pdf]]
13. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch6.pdf]]
14. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch7.pdf]]
15. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch8.pdf]]
16. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/ch9.pdf]]
17. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/fmatter.pdf]]
18. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/index.pdf]]
19. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/harmonic power system/scard.pdf]]
</code></pre>

<p>= 2. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/Offshore Wind Energy Generation Control, Protection, and Integration to Electrical Systems/offshoreWindEnergy]] =</p>

<pre><code>1. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/Offshore Wind Energy Generation Control, Protection, and Integration to Electrical Systems/offshoreWindEnergy/app1.pdf]]
2. [ ] [[local:F:/ScienceBase.Attachments/WindEnergy/Offshore Wind Energy Generation Control, Protection, and Integration to Electrical Systems/offshoreWindEnergy/app2.pdf]]
</code></pre>

<p>```</p>

<h2>学到的技巧</h2>

<ol>
<li>awk两种表示判断,if判断得用分号
<a href="http://blog.csdn.net/qq_31382921/article/details/55094907">如果不用分号隔开会报错</a></li>
</ol>


<p><strong>注意分号！！！</strong></p>

<p><code>
awk '{if ($1==1) print "A"; else if ($1==2) print "B"; else print "C"}'
</code></p>

<p>对应的bash使用的是if,then,else,fi的形式，且不用分号间隔语句
```</p>

<p> for var in <code>find . -name "*"</code></p>

<pre><code>do
    if [[ -d  $var ]] # &lt; cannot . Error
    then
        printf "$var\n" # 使用#号来删除之前的点号
    else
        printf "\t${var}\n" # 这边需要去除到第一个点号,这是才得到的处理方法
    fi

done
</code></pre>

<p>```</p>

<p>awk的'/page/{}&lsquo;等效于'if($0~/dfd/){}&rsquo;</p>

<p>下面的命令，也是一种检查上述程序正确与否的一种工具,可以看出哪些pdf文件依然有pages的字段</p>

<p>```
YeZhao@DESKTOP-YeZhao /cygdrive/f/ScienceBase.Attachments/WindEnergy
$ find . -name &ldquo;*&rdquo;|awk &lsquo;{if($0~/pages/){print $0}}&rsquo;
./windEnergy2009-i6/Characterizing future large, rapid changes in aggregated wind power using Numerical Weather Prediction spatial fields (pages 542–555).pdf
./windEnergy2012-i1/Modeling wake effects in large wind farms in complex terrain the problem, the methods and the issues (pages 161–182).pdf
./windEnergy2012-i2/The Betz–Joukowsky limit on the contribution to rotor aerodynamics by the British, German and Russian scientific schools (pages 335–344).pdf
./windEnergy2012-i3/Computational fluid dynamics simulation of the aerodynamics of a high solidity, small-scale vertical axis wind turbine (pages 349–361).pdf
./windEnergy2012-i3/Correction factors for NRG #40 anemometers potentially affected by dry friction whip characterization, analysis, and validation (pages 489–502).pdf
./windEnergy2012-i4/Analysis of wake measurements from the ECN Wind Turbine Test Site Wieringermeer, EWTW (pages 575–591).pdf
./windEnergy2012-i5/Atmospheric stability and turbulence fluxes at Horns Rev—an intercomparison of sonic, bulk and WRF model data (pages 717–731).pdf
./windEnergy2013-11/Modeling, simulation and control of a wind turbine with a hydraulic transmission system (pages 1259–1276).pdf
./windEnergy2013-8/Indicial lift response function an empirical relation for finite-thickness airfoils, and effects on aeroelastic simulations (pages 681–693).pdf
./windEnergy2013-8/Simulating the dynamics of wind turbine blades part I, model development and verification (pages 694–710).pdf
./windEnergy2013-8/Simulating the dynamics of wind turbine blades part鈥塈I, model validation and uncertainty quantification (pages 741–758).pdf
./windEnergy2014-2/An assessment of the impact of reduced averaging time on small wind turbine power curves, energy capture predictions and turbulence intensity measurements (pages 337–342).pdf
./windEnergy2014-9/Dynamic response analysis of wind turbines under blade pitch system fault, grid loss, and shutdown events (pages 1385–1409).pdf
./windEnergy2015-10/Rapid optimization of stall-regulated wind turbine blades using a frequency-domain method Part 1, loads analysis (pages 1703–1723).pdf
./windEnergy2015-11/Application and validation of incrementally complex models for wind turbine aerodynamics, isolated wind turbine in uniform inflow conditions (pages 1893–1916).pdf
./windEnergy2015-2/Wind turbine boundary layer arrays for Cartesian and staggered configurations Part II, low-dimensional representations via the proper orthogonal decomposition (pages 297–315).pdf
./windEnergy2015-2/Wind turbine boundary layer arrays for Cartesian and staggered configurations-Part I, flow field and power measurements (pages 277–295).pdf
./windEnergy2015-4/Utilization of machine-learning algorithms for wind turbine site suitability modeling in Iowa, USA (pages 713–727).pdf
./windEnergy2015-6/Rapid optimization of stall-regulated wind turbine blades using a frequency-domain method Part 2, cost function selection and results (pages 955–977).pdf
./windEnergy2015-7/Variable geometry wind turbine for performance enhancement, improved survivability and reduced cost of energy (pages 1303–1311).pdf
./windEnergy2016-11/Reliability of wind turbines modeled by a Poisson process with covariates, unobserved heterogeneity and seasonality (pages 1991–2002).pdf
./windEnergy2016-2/Cylindrical vortex wake model skewed cylinder, application to yawed or tilted rotors (pages 345–358).pdf
./windEnergy2016-6/Effects of low temperature on the mechanical properties of glass fibre–epoxy composites static tension, compression, R = 0.1 and R =鈭▒ 1 fatigue of ±45laminates (pages 1023–1041).pdf
./windEnergy2016-6/Failure rate, repair time and unscheduled O&amp;M cost analysis of offshore wind turbines (pages 1107–1119).pdf
./windEnergy2017-02/Verifying the Blade Element Momentum Method in unsteady, radially varied, axisymmetric loading using a vortex ring model (pages 269–288).pdf</p>

<p>```</p>

<ol>
<li>awk的<a href="http://blog.csdn.net/panpan639944806/article/details/19932543">BEGIN</a></li>
</ol>


<p>```
function name()
{}</p>

<p>BEGIN{
}
{</p>

<p>}
END{</p>

<p>}
```</p>

<ol>
<li>awk <a href="http://blog.sina.com.cn/s/blog_67e34ceb0100ybvg.html">gsub</a></li>
</ol>


<p><code>
echo "a b c 2011-11-22 a:d" | awk 'gsub(/-/,"",$4)'
</code></p>

<ol>
<li>awk变量定义</li>
</ol>


<p>BEGIN中<a href="http://blog.csdn.net/shangboerds/article/details/49449291">定义1</a>
<a href="http://jingyan.baidu.com/article/d45ad148fb46f269552b80cf.html">awk -v单行</a>定义变量</p>

<p><a href="http://www.linuxidc.com/Linux/2015-04/115781.htm">awk内置变量</a>, 包括FS,OFS,NR,NFR,NF,$0,$1,$2,ARGC,ARGV<a href="http://blog.csdn.net/panpan639944806/article/details/19932543">1</a>等。</p>

<ol>
<li>awk定义函数</li>
</ol>


<p>awk的<a href="http://bbs.chinaunix.net/thread-1424218-1-1.html">函数定义</a>是在BEGIN{},{},END{}之外的，和他们平级的关系
```</p>

<h1>!/usr/bin/awk -f</h1>

<h1>===============================================================================</h1>

<p>#</p>

<h1>File:  func.awk</h1>

<h1></h1>

<h1>Description:  awk -f func.awk file</h1>

<h1>file内容为400</h1>

<h1></h1>

<h1>VIM Version:  7.0+</h1>

<h1>Author:  Ye Zhao Liang (Vimer), <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#122;&#x68;&#x61;&#x6f;&#x74;&#117;&#114;&#107;&#x6b;&#101;&#x79;&#x40;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;">&#x7a;&#104;&#x61;&#111;&#116;&#117;&#114;&#x6b;&#107;&#101;&#x79;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#111;&#x6d;</a></h1>

<h1>Organization:  BrokenSun</h1>

<h1>Version:  1.0</h1>

<h1>Created:  2017/7/5 16:06:33</h1>

<h1>Revision:  &mdash;&ndash;</h1>

<h1>License:  Copyright &copy; 2017, Ye Zhao Liang</h1>

<h1>===============================================================================</h1>

<h1></h1>

<p>function b()
{
print &ldquo;b.in.$1=&rdquo;$1;
}
{
v=100; y=200
print &ldquo;a.in.v="v;
print "a.in.y="y;</p>

<p>a(y);
b();
print &ldquo;a.out.v="v;
print "a.out.y="y;
}</p>

<p>function a(y)
{
print &ldquo;(a)v="v;
v=v+$1+y;
y=300;
}</p>

<p>```</p>

<ol>
<li><p>bash四种变量截取</p></li>
<li><p>${var#.*}  从左到右，满足#之后条件的最小长度</p></li>
<li>${var##.*}  从左到右，满足##之后条件的最大长度</li>
<li>${var%.*}  从右到左，满足%之后条件的最小长度</li>
<li>${var%%.*}  从右到左，满足%%之后条件的最小长度</li>
</ol>


<p>在awk中可以使用substr($1,0,length($1)&ndash;..)实现类似的功能。</p>

<ol>
<li>bash中的包含关系</li>
</ol>


<p>包含： 即一个大的部分包含小的部分（member)
等价： 即两个东西等价(equal)
比较：一般是两个数，另外也可以是字符串。</p>

<p>bash几种<a href="http://www.cnblogs.com/ginsonwang/p/5525340.html">包含关系用法</a></p>

<p>```
strA=&ldquo;helloworld&rdquo;
strB=&ldquo;low&rdquo;
if [[ $strA =~ $strB ]]
then</p>

<pre><code>echo "包含"
</code></pre>

<p>else</p>

<pre><code>echo "不包含"
</code></pre>

<p>fi
```</p>

<ol>
<li>awk去除左右空格</li>
</ol>


<p>第5个知识点阐述了函数的定义方式,现在来运用一下，
awk<a href="http://blog.csdn.net/bitcarmanlee/article/details/51090048">去除左右空格</a>，再一次使用中发现所有的文件名后缀中多了一个空格，于是尝试消掉空格，想着用awk实现。</p>

<p>```
function ltrim(s) { sub(/^[ \t\r\n]+/, &ldquo;&rdquo;, s); return s }
function rtrim(s) { sub(/[ \t\r\n]+$/, &ldquo;&rdquo;, s); return s }
function trim(s) { return rtrim(ltrim(s)); }
BEGIN{</p>

<pre><code>    FS=","
</code></pre>

<p>}</p>

<p>{</p>

<pre><code>    $0 = rtrim($0);
    if($2!="-" &amp;&amp; $3=="-")
            a[$4]++;
    {
    if($4!="-")
            b[$4]++;
    else
            b[$5]++;
    }
</code></pre>

<p>}</p>

<p>END{</p>

<pre><code>    print "   client    incr_num_day";
    for(i in a) printf("%10s   %d\n",i,a[i])
    print "\n\n   client    all_num";                                                                                                                                                     
    for(j in b) printf("%10s   %d\n",j,b[j]);
</code></pre>

<p>}
```</p>

<ol>
<li>awk调用系统命令</li>
</ol>


<p><a href="http://blog.csdn.net/cy_cai/article/details/41908921">方法</a></p>

<ol type="a">
<li>ready:</li>
</ol>


<p><code>
touch c.txt
touch d.txt
</code></p>

<p>II. a.txt:
<code>
c.txt
d.txt
</code></p>

<p>III. code:
```</p>

<p>awk &lsquo;{cmd=&ldquo;rm &rdquo;$0;system(cmd)}&rsquo; a.txt <br/>
```</p>

<ol>
<li>awk重定向和管道</li>
</ol>


<p>有时候直接可以在awk使用管道，提供给shell,比如<a href="http://blog.chinaunix.net/uid-25324849-id-3079511.html">print|Sort</a>,</p>

<p><code>
awk '{print $1, $2 | "sort" }'
</code></p>

<ol>
<li>windows下的cygwin使用脚本</li>
</ol>


<p>必须得使用
<code>
dos2unix.exe *脚本名字
dos2unix.exe a.sh
dos2unix.exe func.awk
</code>
这样执行shell才有效。</p>

<ol>
<li>awk性能比shell更高</li>
</ol>


<p>参考<a href="http://www.cnblogs.com/chengmo/archive/2010/10/04/1842073.html">链接</a>
```
三、性能比较</p>

<p>[chengmo@localhost nginx]# time (awk &lsquo;BEGIN{ total=0;for(i=0;i&lt;=10000;i++){total+=i;}print total;}&rsquo;)
50005000</p>

<p>real    0m0.003s
user    0m0.003s
sys     0m0.000s
[chengmo@localhost nginx]# time(total=0;for i in $(seq 10000);do total=$(($total+i));done;echo $total;)
50005000</p>

<p>real    0m0.141s
user    0m0.125s
sys     0m0.008s
```</p>

<p>结论：在awk中执行算术运算，比在bash中执行更好一些。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[See From NoteExpress]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2017/05/18/see-from-noteexpress/"/>
    <updated>2017-05-18T22:03:06+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2017/05/18/see-from-noteexpress</id>
    <content type="html"><![CDATA[<p><a href="http://www.inoteexpress.com/aegean/"> NoteExpress </a>是一个文档管理软件，用于管理参考文件，可以方便的word等进行关联插入相关参考文献。
然而他有一个样式编辑器,很普通，却是让我有点触动。</p>

<!--more-->


<h3>三个定义</h3>

<ol>
<li>过滤系统：让你的程序获得合适的数据，在运算系统之前.[struts的拦截器];你需要进行过滤，才能得到满足运算需要的<strong>数据</strong></li>
<li>运算系统：合适的数据进行算法运算，矩阵运算等</li>
<li>样式系统: 运算完的数据进行输出,很多美化的工作。</li>
</ol>


<p>linux的ls可以有很多选项，可以让你的结果不一样，这个选项的效果其实跟样式系统的效果是一致的，都是你对
现实的输出不满意，于是修改，使得你的输出更加perfect</p>

<p><code>
ls
ls -ls
ls -lsh  # 显示文件大小按照人类比较好识别的方式
ls -lsha # 显示隐藏文件
</code></p>

<p><a href="http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html"> awk </a>是linux重要的过滤工具，他就好象是一个鱼网过滤器一样，按照孔的形状过滤字段, 也叫做字段级别过滤器。
<a href="http://www.iteye.com/topic/587673"> sed </a>是一个行修改工具，行级别过滤器, <a href="http://blog.csdn.net/itsenlin/article/details/21129405"> 有几种典型的模式 </a>s,p,d,x,g,h etc</p>

<p>但就是这么简单的几个系统，却是组成了很多业务系统的实现过程的定义，你可以很容易把它替换成为你当前正在处理的阶段，see here to there.</p>

<h3>One Sentence</h3>

<p>每个人都应该有自己的样式系统，this is your style, nobody can change you!
Different Style System makes you different.
人应该有点脾气.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Can You See Them From Here?]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2017/05/18/can-you-see-them-from-here/"/>
    <updated>2017-05-18T20:44:59+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2017/05/18/can-you-see-them-from-here</id>
    <content type="html"><![CDATA[<h2>[[<strong>Here Song</strong>]]</h2>

<pre><code>I am here to look forward,
Nothing or many things?
I am embarrassed.

what should I do here?
What is your plan? what is your target?
Come on,Come on!
Be confident, do and do it at the best,
so you can see more from here

Life is a road with many ups and downs.
Looking at the stars in the sky, Doing at the desk in the grounds.
</code></pre>

<!--more-->


<h2>理解你的Here，才能到达There</h2>

<p>Go there Base on Here !</p>

<pre><code>千里之行，始于足下;
百层高楼，起于垒土;
</code></pre>

<p>You are Here!</p>

<ol>
<li><a href="http://think-like-a-git.net/sections/rebase-from-the-ground-up/a-helpful-mnemonic-for-git-rebase-arguments.html">git rebase Here There</a></li>
</ol>


<p><img src="/images/linux/gitflow.png" alt="gitFlow" /></p>

<p>The home faraway
<img src="/images/linux/railway.jpg" alt="railway" /></p>

<p>See the sumrise, here to go! Let&rsquo;s go!
<img src="/images/linux/time.jpg" alt="sumrise" /></p>

<ol>
<li>somethings added later</li>
</ol>


<p><a href="http://people.csail.mit.edu/sperezde/pre-print-oopsla16.pdf"> To this point </a> , you should understand that use <code>to this point</code> to let your draft become a beautiful road way in your paper.</p>

<p>To this point , you should understand why you do this action at the current time!
To this point , we can realized that there are a rule about the yaw aerodynamic characteristic.</p>

<p>With time goes on or from now on, maybe the result before us show me some infos. See from history.</p>

<p>Your need to find the failure time in the history, understand it, understand why.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash Special Annotation]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2016/09/25/bash-special-annotation/"/>
    <updated>2016-09-25T23:15:01+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2016/09/25/bash-special-annotation</id>
    <content type="html"><![CDATA[<p>关于shell的summary参看<a href="http://jueqingsizhe66.github.io/blog/2016/08/06/linux-shell-summary/#kernel">Linux Shell Summary</a></p>

<p>以下是关于bash的一些比较特殊的地方。</p>

<!--more-->


<h2>1. bash数组再理解</h2>

<p><code>declare -a</code>表示声明一个数组，类似于 <code>declare -i</code> 声明一个整数和<code>declare -x</code>声明一个环境变量。</p>

<p><font color="red">bash数组定义时候使用小括号来赋值，而在引用数组的时候反而使用中括号（不同于其他编程语言)</font></p>

<h3>定义数组</h3>

<p><code>sh
bash2=("34","5","5","4")
</code></p>

<h3>引用数组</h3>

<p><code>`` sh
echo ${array[n]}
遍历数组：
filename=(</code>ls`)
for var in ${filename[@]};do
echo $var
done</p>

<p>```</p>

<h3>添加数组</h3>

<p><code>sh
bash1+="45"; #赋值两边不能有空格
</code></p>

<h2>2. bash变量截取和变量替换</h2>

<p><font color="red">bash使用井号代表开头(这和正则表达式有点不同，使用caret)
而结尾则使用百分号(不同于正则表达式的dollar符号$)。并且在当使用两个重叠的井号，表示最大长度（从头开始的最大删除都删掉）
而使用两个百分号则表达反方向的最大长度删除（从尾到头删除匹配字符串）</p>

<ol>
<li>#表示正向最短匹配，##表示正向最大匹配</li>
<li>%表示反向最短匹配，%%表示反向最大匹配</li>
</ol>


<p>而这一点也体现在变量替换当中，</p>

<p>```
子串替换：
${string/substring/replacement}
使用$replacement来替换第一个匹配的$substring.</p>

<p>${string//substring/replacement}
使用$replacement来替换所有匹配的$substring.</p>

<p>${string/#substring/replacement}
如果$substring匹配$string的开头部分, 那么就用$replacement来替换$substring.</p>

<p>${string/%substring/replacement}
如果$substring匹配$string的结尾部分, 那么就用$replacement来替换$substring.</p>

<p>子串提取的方法主要有：直接到指定位置求子串，字符匹配求子串。
${string:position}
在$string中从位置$position开始提取子串.</p>

<p>如果$string是"*&ldquo;或者&rdquo;@&ldquo;, 那么将会提取从位置$position开始的位置参数.<a href="http://jueqingsizhe66.github.io/blog/2016/08/06/linux-shell-summary/#kernel">1</a></p>

<p>${string:position:length}
在$string中从位置$position开始提取$length长度的子串.</p>

<p>```</p>

<ol>
<li>除号表示最短替换，双除号表示最长替换</li>
<li>匹配项第一个位置出现#井号表示开头部分</li>
<li>匹配项最后一个位置出现%百分号表示结尾部分</li>
</ol>


<h2>3. bash接受键盘操作</h2>

<p>用一个read命令即可(类似于matlab的input命令)
通常的风格是 <code>read -p "prompt for reminding" variable-name</code></p>

<p>``` sh
接收键盘输入：
    read [选项] [变量名]
    选项：
        -p &ldquo;提示信息"：在等待read输入时，输出提示信息
        -t 秒数：read命令会一直等待用户输入，使用此选项可以指定等待时间
        -n 字符数：read命令只接受指定的字符数，就会执行
        -s：隐藏输入的数据，适用于机密信息的输入</p>

<p>read.sh：</p>

<h1>!/bin/bash</h1>

<p>read -p &ldquo;please input your name:&rdquo; -t 30 name
echo $name</p>

<p>read -p &ldquo;please input your passwd:&rdquo; -s passwd
echo -e &ldquo;\n&rdquo;
echo $passwd</p>

<p>read -p &ldquo;please input your sex [M/F]:&rdquo; sex
echo -e &ldquo;\n&rdquo;
echo $sex</p>

<p>```</p>

<h2>4. tac反向</h2>

<p>cat在bash中是打印文本信息的作用，而<a href="http://bbs.chinaunix.net/thread-250407-1-1.html">tac</a>则是反向输出文件流</p>

<p>``` sh
cat old_file|awk &lsquo;{print NR,$0}&rsquo;|sort -r -n|awk &lsquo;{print $2}&rsquo;</p>

<p>```</p>

<ol>
<li>添加每行的行号</li>
<li>逆向排列</li>
<li>输出每行</li>
</ol>


<h2>5. if当中也可以使用双括号进行算术判断</h2>

<p>if并不是支持正则表达式？还是只有变量支持？
``` sh
root at javazhao-N53SM [13:26:46ä��午] in /MyBashWork/clean on git:develop?
$ if [ -f &ldquo;All.sh&rdquo; ] ;then echo &ldquo;hei&rdquo;; else echo &ldquo;no&rdquo; ;fi;</p>

<p>hei</p>

<p>root at javazhao-N53SM [13:26:52ä��午] in /MyBashWork/clean on git:develop?
$ if [ -f &ldquo;*.sh&rdquo; ] ;then echo &ldquo;hei&rdquo;; else echo &ldquo;no&rdquo; ;fi;</p>

<p>no</p>

<p>但是对于变量是可以的
[root@bj_manager ~]# a=123a;if [[ $a =~ ^[0-9]+$ ]]; then echo ok; fi
[root@bj_manager ~]# a=123;if [[ $a =~ ^[0-9]+$ ]]; then echo ok; fi<br/>
```</p>

<p><font color="red">实际情况是只有在双中括号的时候才支持正则表达式</font>。<font color="green">一般是使用双中括号进行文件判断，目录判断，
文件大小判断等</font></p>

<p>if另外一个特殊地方就是使用双括号执行算术比较</p>

<p>```
708@708-PC MINGW64 /e/plGraphViz (master)
  if (( 1&lt;2 )) ;then echo &ldquo;zero&rdquo;;   echo &ldquo;a=2&rdquo;; echo &ldquo;a=3&rdquo; ;else echo &ldquo;no&rdquo;; fi;
zero
a=2
a=3</p>

<p>708@708-PC MINGW64 /e/dot(1)/testByYe
$   if [[ 1&lt;2 ]] ;then echo &ldquo;zero&rdquo;;   echo &ldquo;a=2&rdquo;; echo &ldquo;a=3&rdquo; ;else echo &ldquo;no&rdquo;; fi;
bash: unexpected token 284 in conditional command
bash: syntax error near `1&lt;'</p>

<p>```</p>

<p>而bash也一般是使用<code>$((...))</code> 进行算术的运算.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ydiff单文件夹的所有scm文件比较]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2016/02/26/ydiffdan-wen-jian-jia-de-suo-you-scmwen-jian-bi-jiao/"/>
    <updated>2016-02-26T18:29:08+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2016/02/26/ydiffdan-wen-jian-jia-de-suo-you-scmwen-jian-bi-jiao</id>
    <content type="html"><![CDATA[<p>关于YDIff处理已经在<a href="http://jueqingsizhe66.github.io/blog/2016/02/22/shi-yong-ydiffgong-ju-sheng-cheng-wen-jian-chai-yi-bi-jiao-wen-jian/">使用Ydiff工具生成文件差异比较文件</a>中提及，但是只是比较了两个文件夹之间的文件，
而如果是较为简单的单个文件的所有文件的比较？类似思路如下所示，</p>

<!--more-->


<p>一定要注意数组使用的是小括号包括起来，否则程序有问题。</p>

<p>``` sh</p>

<h1>遍历当前目录下的所有文件 并进行比较 最终结果存入final-result</h1>

<h1>array1=<code>ls *.scm</code></h1>

<p>array1=(<code>ls *.scm</code>)  # 必须加上括号
mkdir final-result
for i in <code>seq 0 $((${#array1[@]}-1))</code>; do</p>

<pre><code>#遍历从i之后的文件
for j in ${array1[@]:$i+1:${#array1[@]}}; do 
    #echo ${array1[$i]},$j;
    dir1=${array1[$i]};
    dir2=$j;
    # 选取对应文件夹下的scm文件
        #export TestVari=$i
        /home/happycamp-of-lisp/wangying/ydiff/diff-lisp $dir1 ${dir2}

done;
</code></pre>

<p>done;</p>

<pre><code>    mv *.html final-result
    cp ./nav.js ./diff.css final-result
</code></pre>

<p>```</p>

<p>ls会找出当前文件夹下的所有scm文件，然后利用bash中的数组操作，使用双重
循环进行遍历即可。</p>
]]></content>
  </entry>
  
</feed>
