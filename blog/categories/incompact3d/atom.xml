<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Incompact3d | 网络书屋(Web Reading Room)]]></title>
  <link href="http://jueqingsizhe66.github.io/blog/categories/incompact3d/atom.xml" rel="self"/>
  <link href="http://jueqingsizhe66.github.io/"/>
  <updated>2017-08-13T11:41:34+08:00</updated>
  <id>http://jueqingsizhe66.github.io/</id>
  <author>
    <name><![CDATA[Ye Zhaoliang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Incompact3d的Makefile及DNS算法]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dde-makefileji-dnssuan-fa/"/>
    <updated>2015-06-22T16:52:20+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dde-makefileji-dnssuan-fa</id>
    <content type="html"><![CDATA[<p><a href="https://code.google.com/p/incompact3d">Incompact3d</a>是一个开源的基于fortran语言编写的DNS求解器，也是我研究生期间使用的开源源代码。
Incompact3d整体框架的介绍可以参考软件的<a href="https://code.google.com/p/incompact3d/downloads/detail?name=user_guide_incompact3d_V1-1.pdf&amp;can=2&amp;q=">user-guide</a>和文献<a href="http://www.imperial.ac.uk/media/imperial-college/research-centres-and-groups/turbulence-mixing-and-flow-control-group/2009_LAIZET_JCP.pdf">High-order-compact schemes for incompressible flows: a simple and effcient method with the quasi-spectral accuary</a>,还可以搜索<a href="http://www.imperial.ac.uk/tmfc">sylvain Laziet</a> 相关的文章 ，只不过他并不是成熟的软件，很多的编译和后处理都可能出现问题，下面是我使用过程遇到的一些问题。
当然主要过程是，通过makefile编译，然后运行incompact3d，最后处理计算结果。</p>

<!--more-->


<h1>1 如何模拟？</h1>

<p>以周期性槽道流动(当然我也就会这么一种，其他都只是走了一小半）为例。</p>

<ol>
<li>首先是得到(不得不说，我也有点忘记)一个完全发展的旋转槽道流动(注意旋转源项的添加) (一般设置20000步可以了，只要收敛即可 大概一天)</li>
<li>然后是获得完全发展槽道流动(也就是不加上旋转源项)(估计得三万步以上 大概一天)</li>
<li>最后是获得统计的完全发展槽道流动.因为DNS获得的结果是非定常的，所以你得进行时均处理(当然时均程序得打开时均统计项 umean等)(我统计了20万步，大概花了4天时间。)</li>
</ol>


<p>步骤就是这样,大概一个较小的流程需要一周左右。</p>

<p>Incompact3d比较特殊的是收敛性判定问题，上面的几个过程都需要使用实时<a href="http://jueqingsizhe66.github.io/blog/2015/05/31/u-plus-y-plus/">监控小程序</a>
来观看速度散度和质量流量(质量流量是周期性槽道流动所特有的，所以最好进行实时显示)的收敛情况.另外你可以通过python的一个小脚本
来获得实时显示的图片，这样就能看到程序模拟得怎么样了，具体查看<a href="http://jueqingsizhe66.github.io/blog/2015/06/11/ji-yu-pythonde-ju-yu-wang-wen-jian-gong-xiang-ruan-jian-simplehttpserverwithupload/">python局域网上传和下载</a>.</p>

<h1>2 后处理方法</h1>

<p>参考我的<a href="http://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dru-he-tong-guo-jie-guo-chu-li-chu-ji-xian">pathline处理方法</a>
一定要注意(real 8) 否则得到的结果肯定是错误的，这也是困扰我几星期的问题。</p>

<h1>3 关于Makefile编译</h1>

<p>``` makefile</p>

<h1>=======================================================================</h1>

<h1>Makefile for Imcompact3D</h1>

<h1>=======================================================================</h1>

<h1>Choose pre-processing options</h1>

<h1>-DSHM      &ndash; enable shared-memory implementation</h1>

<h1>-DDOUBLE_PREC  &ndash; use double-precision</h1>

<p>OPTIONS = -DDOUBLE_PREC</p>

<h1>Choose an FFT engine, available options are:</h1>

<h1>essl       &ndash; IBM Blue Gene ESSL Library</h1>

<h1>fftw3      &ndash; FFTW version 3.x</h1>

<h1>generic    &ndash; A general FFT algorithm (no 3rd-party library needed)</h1>

<h1>FFT= essl # I ignore</h1>

<p>FFT = generic</p>

<h1>Paths to FFTW 3</h1>

<p>FFTW3_PATH=   # full path of FFTW installation if using fftw3 engine above
FFTW3_INCLUDE = -I$(FFTW3_PATH)/include
FFTW3_LIB = -L$(FFTW3_PATH)/lib -lfftw3 -lfftw3f</p>

<h1>Paths to ESSL</h1>

<p>ESSL_PATH=/bgsys/drivers/ppcfloor/comm/xl
ESSL_INCLUDE =
ESSL_LIB = -L$(ESSL_PATH)/lib -L/opt/ibmmath/lib64 -lesslbg</p>

<h1>Specify Fortran and C compiler names and flags here</h1>

<h1>Normally, use MPI wrappers rather than compilers themselves</h1>

<h1>Supply a Fortran pre-processing flag together with optimisation level flags</h1>

<h1>Some examples are given below:</h1>

<h1>FC =</h1>

<h1>OPTFC =</h1>

<h1>CC =</h1>

<h1>CFLAGS =</h1>

<h1>PGI</h1>

<h1>FC = ftn</h1>

<h1>OPTFC = -fast -O3 -Mpreprocess</h1>

<h1>CC = cc</h1>

<h1>CFLAGS = -O3</h1>

<h1>PathScale</h1>

<h1>FC = ftn</h1>

<h1>OPTFC = -Ofast -cpp</h1>

<h1>CC = cc</h1>

<h1>CFLAGS = -O3</h1>

<h1>GNU 选用mpif90进行编译</h1>

<p>FC = mpif90
OPTFC = -O0 -g  -fdefault-real-8 -fdefault-double-8 -funroll-loops -ftree-vectorize -fcray-pointer -cpp
CC = mpicc
CFLAGS = -O0
PLATFORM=gnu</p>

<h1>Blue Gene/Q : EDF R&amp;D</h1>

<h1>PREP=/bgsys/drivers/ppcfloor/comm/xl/bin/</h1>

<h1>FC = $(PREP)mpixlf95_r</h1>

<h1>OPTFC= -O3 -qsuffix=cpp=f90 -qinitauto -qautodbl=dbl4</h1>

<h2>OPT_LK= -O3 -qinitauto -qautodbl=dbl4</h2>

<h1>CFLAGS= -O3 -qinitauto -qautodbl=dbl4</h1>

<h1>CC=$(PREP)mpixlc_r</h1>

<h1>PLATFORM=bgq_xlf</h1>

<h1>Cray</h1>

<h1>FC = ftn</h1>

<h1>OPTFC = -e Fm</h1>

<h1>CC = cc</h1>

<h1>CFLAGS =</h1>

<h1>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</h1>

<h1>Normally no need to change anything below</h1>

<h1>include PATH</h1>

<p>ifeq ($(FFT),generic)
  INC=
else ifeq ($(FFT),fftw3)
  INC=$(FFTW3_INCLUDE)
else ifeq ($(FFT),essl)
  INC=$(ESSL_INCLUDE)
endif</p>

<h1>library path</h1>

<p>ifeq ($(FFT),generic)
   LIBFFT=
else ifeq ($(FFT),fftw3)
   LIBFFT=$(FFTW3_LIB)
else ifeq ($(FFT),essl)
   LIBFFT=$(ESSL_LIB)
endif</p>

<h1>List of source files</h1>

<h1>注意这边编译的模块，一般是需要的mod生成放在前面首先编译，如果不放前面会报错，解决办法 就是文件名放在前面即可,具体可以查看关于Makefile Fortran</h1>

<p>SRC = decomp_2d.f90 glassman.f90 fft_$(FFT).f90 module_param.f90 io.f90 variables.f90 poisson.f90 schemes.f90 implicit.f90 convdiff.f90 user_module.f90 incompact3d.f90 navier.f90 derive.f90 parameters.f90 tools.f90 visu.f90</p>

<h1>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;</h1>

<h1>Normally no need to change anything below</h1>

<p>ifneq (,$(findstring DSHM,$(OPTIONS)))
SRC := FreeIPC.f90 $(SRC)<br/>
OBJ =   $(SRC:.f90=.o) alloc_shm.o FreeIPC_c.o
else
OBJ =   $(SRC:.f90=.o)
endif</p>

<p>OPTION=$(OPTIONS)
from:=-D
to:=-WF,-D
TMP=$(subst $(from),$(to),$(OPTIONS))
ifeq ($(PLATFORM),bgp_xlf)
   OPTION=$(TMP)
endif
ifeq ($(PLATFORM),bgq_xlf)
   OPTION=$(TMP)
endif</p>

<p>all: incompact3d</p>

<p>alloc_shm.o: alloc_shm.c</p>

<pre><code>$(CC) $(CFLAGS) -c $&lt;
</code></pre>

<p>FreeIPC_c.o: FreeIPC_c.c</p>

<pre><code>$(CC) $(CFLAGS) -c $&lt;
</code></pre>

<p>incompact3d : $(OBJ)</p>

<pre><code>$(FC) -O0 -g -o $@ $(OBJ) $(LIBFFT)
</code></pre>

<p>%.o : %.f90</p>

<pre><code>$(FC) $(OPTFC) $(OPTION) $(INC) -c $&lt;
</code></pre>

<p>.PHONY: clean
clean:</p>

<pre><code>rm -f *~ *.o *.mod incompact3d
</code></pre>

<p>.PHONY: realclean
realclean: clean</p>

<pre><code>rm -f *~ \#*\#
</code></pre>

<p>```</p>

<p>运行方式:
我的电脑刚好是8线程，就用8线程运行，你也可以选用4或者更多.</p>

<p><code>sh
mpirun -np 8  incompact3d  &gt; tail.out &amp;
</code></p>

<h1>4 The Algorithm of the DNS in Incompact3d</h1>

<p>Incompact3d的执行流程基本上是下面几个(当然得仔细阅读，并反复比对).我写得这段英文大体能够对得上.</p>

<p><code>sh
1. Initial the velocity field with noise(init subroutine).
2. Start the iterative process by guessing the pressure field. First we use convdiff subroutine take convection and diffusion of the flow into consideration.And then use pre_correc subroutine to correction the velocity value with the specified boundary condition.
3. Use the values of u,v,and w to get the initialize of the pp3 in the spectral space from subroutine divergence(…pp3,1…)(first sign to turbulent spot).Then we use poisson solver decomp_2d_poisson_stag to get the value of the pp3 in the spectral space.
4. Since they were obtained from the guessed values of u,v,w,the values pp3,when substituted into the divergence equation,will not necessarily satisfy that that equation.Hence ,using the gradp subroutine,get the pressure gradients in the physics space,then using corgp subroutine ,get the velocity correction by the pressure gradient in the physics space.Use subroutine divergence(…dv3,2…) to do another monitor for turbulent spot(second sign to turbulent spot) .At the end of the current step, we go to step2 again until the simulation have been fully developed.
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Incompact3d如何通过结果处理出迹线]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dru-he-tong-guo-jie-guo-chu-li-chu-ji-xian/"/>
    <updated>2015-06-22T16:20:48+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2015/06/22/incompact3dru-he-tong-guo-jie-guo-chu-li-chu-ji-xian</id>
    <content type="html"><![CDATA[<p>Incompact3D获得的数据都是二进制的数据文件，为了获得内部的文件
需要进一步通过编程获得，下面是一个获得pathline的源代码。</p>

<!--more-->


<p>说明：</p>

<ol>
<li>通过 module.f90文件读取 nx ny nz的值</li>
<li>把下面的源代码编译并放在ux uy uz所在的文件夹当中</li>
<li>进一步的相关信息，可以参考注释。</li>
</ol>


<p>``` fortran
PROGRAM b
IMPLICIT NONE
Integer,parameter :: nx=128,ny=129,nz=84
INTEGER :: I,J,K,COUNT,LN=128,COL=129,VOL=84
REAL(8),DIMENSION(nx,ny,nz) :: ux,uy,uz
CHARACTER(len=12)::NAME1=&ldquo;Incompact3d&rdquo;,NAME2=&ldquo;ux&rdquo;,NAME3=&ldquo;uy&rdquo;,NAME4=&ldquo;uz&rdquo;
character(len=15) :: temp,temp1,temp2,temp3
CHARACTER(len=20) :: CFILEux
integer :: num</p>

<p>real,dimension(nx):: y1
real,dimension(ny):: y2
real,dimension(nz):: y3</p>

<p>!generation of the mesh
do i=1,nx
   y1(i)=(i-1)*0.098174770425 !0.8 is DX ! incompact3d.prm的配置长度除以网格尺度即可。
enddo</p>

<p>do j=1,ny
   y2(j)=(j-1)*0.015503875968992248 !0.8 is DY
enddo</p>

<p>do k=1,nz
   y3(k)=(k-1)*0.04986655005702381!0.8 is DZ
enddo</p>

<p>! 下面只是对于读取文件进行的一个后处理，只是为了方便批处理而已
22 format(I1)
23 format(I2)
DO num=1,30</p>

<pre><code>if(num .lt. 10) then
    write(temp,22) num
    temp1 =trim(NAME2)//trim('00')//trim(temp)
    temp2 =trim(NAME3)//trim('00')//trim(temp)
    temp3 =trim(NAME4)//trim('00')//trim(temp)
else 
    write(temp,23) num
    temp1 =trim(NAME2)//trim('0')//trim(temp)
    temp2 =trim(NAME3)//trim('0')//trim(temp)
    temp3 =trim(NAME4)//trim('0')//trim(temp)
end if
</code></pre>

<p>! 产生实际的文件名
CFILEux=trim(&lsquo;./pathchange/&rsquo;)//trim(temp1)//&lsquo;.dat&rsquo;
!read the ux 读取ux00*的数据
OPEN(10,FILE=temp1,FORM=&lsquo;UNFORMATTED&rsquo;,&amp;
ACCESS=&lsquo;DIRECT&rsquo;, RECL=8, STATUS=&lsquo;OLD&rsquo;)</p>

<p>! read the uy
OPEN(11,FILE=temp2,FORM=&lsquo;UNFORMATTED&rsquo;,&amp;
ACCESS=&lsquo;DIRECT&rsquo;, RECL=8, STATUS=&lsquo;OLD&rsquo;)
!read the uz
OPEN(12,FILE=temp3,FORM=&lsquo;UNFORMATTED&rsquo;,&amp;
ACCESS=&lsquo;DIRECT&rsquo;, RECL=8, STATUS=&lsquo;OLD&rsquo;)</p>

<p>! 新建一个结果文件，并添加上tecplot的数据头</p>

<p>OPEN(20,FILE=CFILEux,FORM=&lsquo;FORMATTED&rsquo;)
WRITE (20,&lsquo;(A6,A12)&rsquo;)               &lsquo;TITLE=&rsquo;,TRIM(ADJUSTL(NAME1))
 WRITE (20,&lsquo;(A36)&rsquo;)    &lsquo;VARIABLES=&ldquo;X&rdquo;,&ldquo;Y&rdquo;,&ldquo;Z&rdquo;,&ldquo;VX&rdquo;,&ldquo;VY&rdquo;,&ldquo;VZ&rdquo;&rsquo;</p>

<pre><code>  WRITE (20,'(A7,I4,A1,A2,I4,A1,A2,I4,A1,A7)') 'ZONE I=',LN,',','J=',COL,',','K=',VOL,',','F=POINT'
</code></pre>

<p>COUNT = 1
DO K=1,nz</p>

<pre><code>DO J=1,ny
    DO I=1,nx
        READ(10,REC=COUNT) ux(I,J,K)
        READ(11,REC=COUNT) uy(I,J,K)
        READ(12,REC=COUNT) uz(I,J,K)
    !    WRITE(20,30) I,J,K,ux(I,J,K),uy(I,J,K),uz(I,J,K)
         WRITE(20,30) y1(i),y2(j),y3(k),ux(I,J,K),uy(I,J,K),uz(I,J,K)
        30 format(I3,1X,I3,1X,I3,1X,E11.4,1x,E11.4,1x,E11.4)
        COUNT = COUNT + 1
    ENDDO
ENDDO
</code></pre>

<p>ENDDO
ENDDO
CLOSE(10)
CLOSE(11)
CLOSE(10)
CLOSE(20)
END PROGRAM b
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[U+-Y+]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2015/05/31/u-plus-y-plus/"/>
    <updated>2015-05-31T09:31:05+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2015/05/31/u-plus-y-plus</id>
    <content type="html"><![CDATA[<p>这个gnuplot脚本是我用于处理Incompact3d产生出来的统计结果(如何统计部分，暂时未写)的画图脚本。</p>

<!--more-->


<h2>数据段</h2>

<p>注意gnuplot处理数据文件按照空行划分index部分。所以下面的部分总共有四个index，调用方式是</p>

<ul>
<li>plot &ldquo;文件名&rdquo; index 0   第一部分文件信息的打印</li>
<li>plot &ldquo;文件名&rdquo; index 1</li>
<li>plot &ldquo;文件名&rdquo; index 2</li>
<li>plot &ldquo;文件名&rdquo; index 3</li>
</ul>


<p>具体看gnuplot脚本部分。</p>

<p>``` sh
0 2.9684e-24
0.7369 0.73552
1.4746 1.4677
2.2139 2.195
2.9556 2.915
3.7005 3.6242
4.4495 4.3184
5.2034 4.9934
5.9631 5.6455
6.7295 6.2713
7.5034 6.8686
8.2859 7.4358
9.078 7.9722
9.8806 8.4777
10.695 8.9528
11.522 9.3986
12.363 9.8162
13.219 10.207
14.092 10.573
14.983 10.916
15.894 11.236
16.825 11.537
17.779 11.819
18.759 12.084
19.764 12.334
20.799 12.569
21.864 12.791
22.963 13.001
24.099 13.201
25.273 13.391
26.49 13.572
27.753 13.745
29.065 13.911
30.431 14.071
31.855 14.225
33.343 14.374
34.899 14.52
36.529 14.661
38.24 14.8
40.04 14.936
41.936 15.07
43.936 15.202
46.052 15.333
48.292 15.464
50.669 15.594
53.196 15.725
55.887 15.856
58.756 15.989
61.819 16.124
65.096 16.262
68.603 16.402
72.361 16.544
76.389 16.69
80.706 16.838
85.33 16.988
90.276 17.139
95.557 17.288
101.18 17.434
107.14 17.572
113.42 17.7
120 17.813
126.85 17.906
133.91 17.975
141.11 18.017
148.4 18.03</p>

<p>5 0
5 20</p>

<p>30 0
30 20</p>

<p>120 0
120 20</p>

<p>```</p>

<h2>gnuplot处理部分</h2>

<p>``` gnuplot
set ter &lsquo;png&rsquo;
set out &lsquo;fit1.png&rsquo;</p>

<p>set xlabel &ldquo;Y+&rdquo;
set ylabel &ldquo;U+&rdquo;
set xtics font &lsquo;Times-Roman, 15&rsquo;
f(x)=a<em>x+b
g(x)=1/k</em>log(x)+B
fit [0:5] f(x) &ldquo;umfit.dat&rdquo; index 0 via a,b
print &ldquo;a:=&rdquo;,a,&ldquo;b=&rdquo;,b
fit [30:148] g(x) &ldquo;umfit.dat&rdquo; index 0 via k,B
print &ldquo;k=&rdquo;,k,&ldquo;B=&rdquo;,B
set xtics 20
set samples 1280
set key right bottom box
set arrow from 20,5 to  5,2
set label  sprintf(&ldquo;viscous sub-layer fit:\n f(x)=%g<em>x +%g&rdquo;, a,b)  at 20,6
set arrow from 90,12 to  70,16
set label sprintf(&ldquo;logarithm range fit:\n f(x)=1/%g</em>log(x) +%g&rdquo;,k,B) at 90,11</p>

<h1>set logscale x</h1>

<h1>set xrange</h1>

<h1>set yrange [0:0.5]</h1>

<h1>[0:220][0:0.04]   # the most important place is here</h1>

<p>plot  [0:148][0:20]  &ldquo;umfit.dat&rdquo; index 0 w lp pt 1  t &ldquo;U+&mdash;Y+&rdquo;,f(x) w l lt -1 lw 2 t &ldquo;linear-fit&rdquo;,g(x)  w  l lt 3 lw 2 t &ldquo;log-fit&rdquo;,\
 &ldquo;&rdquo; index 1 w l lt 0 t &ldquo;linear-fit-end&rdquo;,&ldquo;&rdquo; index 2 w l lt 0 t &ldquo;log-law-start&rdquo;,&ldquo;&rdquo; index 3 w l lt 0 t &ldquo;log-law-end&rdquo;</p>

<p>```</p>

<h2>处理结果</h2>

<p><img src="/images/incompact3d/fit1.png" alt="处理结果" /></p>

<h2>一些实时监测部分</h2>

<h3>执行部分：</h3>

<p><strong>a.sh</strong>
<code>sh
mpirun -np 8  incompact3d  &gt;&gt; tail.out &amp;
</code></p>

<h3>获取信息部分</h3>

<p><strong>image.sh</strong>
``` sh
more tail.out | grep DIV | grep U* |grep Max|sed &lsquo;/final/d&rsquo;| awk -F'=&lsquo; &rsquo;{print $2}&lsquo; |sed '1,3d&rsquo;> divu
more tail.out | grep UT | awk  &lsquo;{print $4}&rsquo;|sed &lsquo;1,2d&rsquo; > flow-rate-correction-factor</p>

<h1>more tail.out | grep zhao | awk &lsquo;{print $2,$3,$4}&rsquo; > stretching</h1>

<p>more tail.out | grep PHI | grep max|awk -F'=&lsquo; &rsquo;{print $2}&lsquo; > PHImax</p>

<p>more tail.out | grep PHI|grep MOYEN | awk  -F":&ldquo; &lsquo;{print $2*10<sup>4</sup>}&rsquo;> PHImoyen</p>

<h1>gnuplot monitorFLOWRATE.gnu</h1>

<p>bash monitor.sh
```</p>

<h3>打印部分</h3>

<p><strong>monitor.sh</strong>
``` sh</p>

<h1>!/bin/bash</h1>

<h1>===============================================================================</h1>

<p>#</p>

<h1>FILE:  monitor.sh</h1>

<h1></h1>

<h1>USAGE:  ./monitor.sh</h1>

<h1></h1>

<h1>DESCRIPTION:</h1>

<h1></h1>

<h1>OPTIONS:  &mdash;&ndash;</h1>

<h1>REQUIREMENTS:  &mdash;&ndash;</h1>

<h1>BUGS:  &mdash;&ndash;</h1>

<h1>NOTES:  &mdash;&ndash;</h1>

<h1>AUTHOR:  Ye Zhaoliang (YZL), <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x7a;&#104;&#97;&#111;&#x74;&#117;&#114;&#x6b;&#107;&#101;&#x79;&#x40;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#109;">&#122;&#104;&#x61;&#111;&#116;&#117;&#x72;&#x6b;&#107;&#x65;&#x79;&#x40;&#49;&#x36;&#x33;&#46;&#99;&#x6f;&#109;</a></h1>

<h1>COMPANY:  NCEPU</h1>

<h1>VERSION:  1.0</h1>

<h1>CREATED:  2014年10月28日 09时42分15秒 CST</h1>

<h1>REVISION:  &mdash;&ndash;</h1>

<h1>===============================================================================</h1>

<h1>set yrange [0:2]</h1>

<h1>set xlabel</h1>

<h1>set ylabel</h1>

<p>function mainpoint()
{
 #   echo $0;</p>

<h1>echo $1;</h1>

<p>gnuplot&lt;&lt;EOF
set ter &lsquo;png&rsquo;
set out &lsquo;$1.png&rsquo;
set grid
plot &lsquo;$1&rsquo; w p pt 2
EOF</p>

<p>}</p>

<p>function mainline()
{
 #   echo $0;
 #   echo $1;
gnuplot&lt;&lt;EOF
set ter &lsquo;png&rsquo;
set out &lsquo;$1.png&rsquo;
set grid
set yrange [0:2]
plot &lsquo;$1&rsquo; w l lt 2
EOF</p>

<p>}</p>

<h1>mainpoint ux2</h1>

<h1>mainpoint uy2</h1>

<h1>mainpoint uz2</h1>

<h1>mainpoint ux5</h1>

<h1>mainpoint uy5</h1>

<h1>mainpoint uz5</h1>

<h1>mainline uy2</h1>

<p>mainpoint divu
mainpoint flow-rate-correction-factor</p>

<h1>mainpoint stretching</h1>

<p>mainpoint PHImax
mainpoint PHImoyen</p>

<h1>mainpoint averageux2</h1>

<h1>mainpoint averageux5</h1>

<h1>mainpoint rxx2</h1>

<h1>mainpoint rxx5</h1>

<h1>mainpoint dudy_bottom_spatial_only</h1>

<h1>mainpoint dudy_top_spatial_only</h1>

<h1>mainpoint dudy_bottom_spatial_time</h1>

<h1>mainpoint dudy_top_spatial_time</h1>

<h1>new add  stress</h1>

<h1>mainpoint umean</h1>

<h1>mainpoint vmean</h1>

<h1>mainpoint wmean</h1>

<h2>mainpoint uu</h2>

<h2>mainpoint vv</h2>

<h1>mainpoint ww</h1>

<h1>mainpoint stressu</h1>

<h1>mainpoint stressv</h1>

<h1>mainpoint stressw</h1>

<h1>mainpoint stressuv</h1>

<h1>mainpoint stressuw</h1>

<h1>mainpoint stressvw</h1>

<p>```</p>

<h3>整合部分</h3>

<p>cut -c的目的是获取具体对应的时间步,然后把所有的png相关信息 放到对应时间步文件夹中。</p>

<p>``` sh
cd /home/Cedric/diric/src &amp;&amp; more tail.out |grep Time|awk &lsquo;{print $4}&rsquo; |tail -1|cut -c 1-6 |awk &lsquo;{cmd=&ldquo;mkdir step&rdquo;$1;system(cmd);system(&ldquo;sh image.sh&rdquo;);cmd2=&ldquo;mv *.png step&rdquo;$1;system(cmd2);} &rsquo;</p>

<h1>END{cmd3=&ldquo;mv dudy* umean stress step&rdquo;$1;system(cmd3)}</h1>

<p>```</p>

<h3>实时浏览</h3>

<p>``` sh
切换到对应的文件夹
$ python -m SimpleHTTPServer</p>

<p>```</p>

<p>然后就可以打开 127.0.0.1:8000进行浏览了。</p>

<h3>You can also use crontab to execute program in real time</h3>

<p>``` sh</p>

<p>crontab -e
```</p>

<p>Then you can copy the info below,but modified the datatime.</p>

<p><code>
0 23 19 6 * sh /home/simulation2_128-117-128Re4200/main.sh
30 23 19 6 * sh /home/simulation2_128-117-128Re4200/main.sh
0 0 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
30 0 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
0 1 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
30 1 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
0 2 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
30 2 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
0 3 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
30 3 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
0 4 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
30 4 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
0 5 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
30 5 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
0 6 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
30 6 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
0 7 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
30 7 20 6 * sh /home/simulation2_128-117-128Re4200/main.sh
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Poisson]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2014/05/14/poisson/"/>
    <updated>2014-05-14T02:09:00+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2014/05/14/poisson</id>
    <content type="html"><![CDATA[<!--more-->


<p>```  fortran poisson.f90 code note <a href="http://jueqingsizhe66.github.io">http://jueqingsizhe66.github.io</a>  link</p>

<p>module decomp_2d_poisson</p>

<p>  use decomp_2d
  use decomp_2d_fft</p>

<p>  use param
  use variables</p>

<p>  implicit none</p>

<p>  private        ! Make everything private unless declared public</p>

<p>!  real(mytype), private, parameter :: PI = 3.14159265358979323846_mytype
!                                   This 0.0_mytype!!!!!!!!!!!!!1111</p>

<h1>ifdef DOUBLE_PREC</h1>

<p>  real(mytype), parameter :: epsilon = 1.e-16</p>

<h1>else</h1>

<p>  real(mytype), parameter :: epsilon = 1.e-8</p>

<h1>endif</h1>

<p>  ! boundary conditions
  integer, save :: bcx, bcy, bcz</p>

<p>  ! decomposition object for physical space
  TYPE(DECOMP_INFO), save :: ph</p>

<p>  ! decomposition object for spectral space
  TYPE(DECOMP_INFO), save :: sp</p>

<p>  ! store sine/cosine factors
  real(mytype), save, allocatable, dimension(:) :: az,bz
  real(mytype), save, allocatable, dimension(:) :: ay,by
  real(mytype), save, allocatable, dimension(:) :: ax,bx</p>

<p>  ! wave numbers
  complex(mytype), save, allocatable, dimension(:,:,:) :: kxyz
  !wave numbers for stretching in a pentadiagonal matrice
  complex(mytype), save, allocatable, dimension(:,:,:,:) :: a,a2,a3
  ! work arrays,
  ! naming convention: cw (complex); rw (real);
  !                    1 = X-pencil; 2 = Y-pencil; 3 = Z-pencil
  real(mytype), allocatable, dimension(:,:,:) :: rw1,rw1b,rw2,rw2b,rw3
  complex(mytype), allocatable, dimension(:,:,:) :: cw1,cw1b,cw2,cw22,cw2b,cw2c</p>

<p>  ! underlying FFT library only needs to be initialised once
  logical, save :: fft_initialised = .false.</p>

<p>  public :: decomp_2d_poisson_stg, decomp_2d_poisson_init, &amp;</p>

<pre><code>   decomp_2d_poisson_finalize
</code></pre>

<p>  ! For staggered mesh where main variables are defined in the centre of
  ! control volumes while boundary conditions are defined on interfaces
  interface decomp_2d_poisson_stg</p>

<pre><code> module procedure poisson
</code></pre>

<p>  end interface
contains</p>

<p>  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Initialise Poisson solver for given boundary conditions
  !                               given
  !                               given
  !   just for init
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine decomp_2d_poisson_init(bcx1, bcy1, bcz1)</p>

<pre><code>implicit none

integer, intent(IN) :: bcx1, bcy1, bcz1
integer :: nx, ny, nz, i

bcx = bcx1
bcy = bcy1
bcz = bcz1

nx = nx_global
ny = ny_global
nz = nz_global

! pressure-grid having 1 fewer point for non-periodic directions
if (bcx==1) nx=nx-1
if (bcy==1) ny=ny-1
if (bcz==1) nz=nz-1

allocate(ax(nx),bx(nx))
allocate(ay(ny),by(ny))
allocate(az(nz),bz(nz))
call abxyz(ax,ay,az,bx,by,bz,nx,ny,nz,bcx,bcy,bcz)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Initialise the ax bx
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Initialise the ay by
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Initialise the az bz
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1


call decomp_info_init(nx, ny, nz, ph)
call decomp_info_init(nx, ny, nz/2+1, sp)

! allocate work space
if (bcx==0 .and. bcy==0 .and. bcz==0) then
   allocate(cw1(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;
        sp%xst(3):sp%xen(3)))
   allocate(kxyz(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;
        sp%xst(3):sp%xen(3)))
   allocate(a(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
   allocate(a2(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
   allocate(a3(sp%yst(1):sp%yen(1),ny,sp%yst(3):sp%yen(3),5))
   ! (000)  ^c  ^kxyz ^a
else if (bcx==1 .and. bcy==0 .and. bcz==0) then
   allocate(cw1(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;
             sp%xst(3):sp%xen(3)))
   allocate(cw1b(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;
             sp%xst(3):sp%xen(3)))
   allocate(rw1(ph%xst(1):ph%xen(1),ph%xst(2):ph%xen(2), &amp;
        ph%xst(3):ph%xen(3)))
   allocate(rw1b(ph%xst(1):ph%xen(1),ph%xst(2):ph%xen(2), &amp;
        ph%xst(3):ph%xen(3)))
   allocate(rw2(ph%yst(1):ph%yen(1),ph%yst(2):ph%yen(2), &amp;
        ph%yst(3):ph%yen(3)))
   allocate(kxyz(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;
        sp%xst(3):sp%xen(3)))
   allocate(a(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
   allocate(a2(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
   allocate(a3(sp%yst(1):sp%yen(1),ny,sp%yst(3):sp%yen(3),5))
   !(100)      consist :: cw1 cw1b   rw1   rw1b   rw2    ^a
else if (bcx==0 .and. bcy==1 .and. bcz==0) then
   allocate(rw2(ph%yst(1):ph%yen(1),ph%yst(2):ph%yen(2), &amp;
        ph%yst(3):ph%yen(3)))
   allocate(rw2b(ph%yst(1):ph%yen(1),ph%yst(2):ph%yen(2), &amp;
        ph%yst(3):ph%yen(3)))
   allocate(cw1(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;
             sp%xst(3):sp%xen(3)))
   allocate(cw2(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;
             sp%yst(3):sp%yen(3)))
   allocate(cw22(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;
        sp%yst(3):sp%yen(3)))
   allocate(cw2b(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;
             sp%yst(3):sp%yen(3)))
   allocate(cw2c(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;
             sp%yst(3):sp%yen(3)))
   allocate(kxyz(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;
        sp%yst(3):sp%yen(3)))
   allocate(a(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
   allocate(a2(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
   allocate(a3(sp%yst(1):sp%yen(1),ny,sp%yst(3):sp%yen(3),5))
   !(010)  rw2 rw2b cw2 cw22 cw2b cw2c kxyz  ^a
else if (bcx==1 .and. bcy==1) then
   allocate(cw1(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;
             sp%xst(3):sp%xen(3)))
   allocate(cw1b(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;
             sp%xst(3):sp%xen(3)))
   allocate(cw2(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;
             sp%yst(3):sp%yen(3)))
   allocate(cw22(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;
        sp%yst(3):sp%yen(3)))
   allocate(cw2b(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;
             sp%yst(3):sp%yen(3)))
   allocate(cw2c(sp%yst(1):sp%yen(1),sp%yst(2):sp%yen(2), &amp;
             sp%yst(3):sp%yen(3)))
   allocate(rw1(ph%xst(1):ph%xen(1),ph%xst(2):ph%xen(2), &amp;
        ph%xst(3):ph%xen(3)))
   allocate(rw1b(ph%xst(1):ph%xen(1),ph%xst(2):ph%xen(2), &amp;
        ph%xst(3):ph%xen(3)))
   allocate(rw2(ph%yst(1):ph%yen(1),ph%yst(2):ph%yen(2), &amp;
        ph%yst(3):ph%yen(3)))
   allocate(rw2b(ph%yst(1):ph%yen(1),ph%yst(2):ph%yen(2), &amp;
        ph%yst(3):ph%yen(3)))
    !(11*) cw1 cw1b cw2 cw2b  cw2c  rw1 rw1b rw2b
   if (bcz==1) then  
      allocate(rw3(ph%zsz(1),ph%zsz(2),ph%zsz(3)))
   end if
   allocate(kxyz(sp%xst(1):sp%xen(1),sp%xst(2):sp%xen(2), &amp;
        sp%xst(3):sp%xen(3)))    
   allocate(a(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
   allocate(a2(sp%yst(1):sp%yen(1),ny/2,sp%yst(3):sp%yen(3),5))
   allocate(a3(sp%yst(1):sp%yen(1),nym,sp%yst(3):sp%yen(3),5))      
   !(111) rw3  kxyz  ^a
end if

call waves()

return
</code></pre>

<p>  end subroutine decomp_2d_poisson_init</p>

<p>  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Release memory used by Poisson solver
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine decomp_2d_poisson_finalize</p>

<pre><code>implicit none

deallocate(ax,bx,ay,by,az,bz)

call decomp_info_finalize(ph)
call decomp_info_finalize(sp)

call decomp_2d_fft_finalize
fft_initialised = .false.

deallocate(kxyz)

if (bcx==0 .and. bcy==0 .and. bcz==0) then
   deallocate(cw1)
   ! (000) cw1
else if (bcx==1 .and. bcy==0 .and. bcz==0) then
   deallocate(cw1,cw1b,rw1,rw1b,rw2)
   ! (100)   cw1 cw1b rw1 rw1b rw2
else if (bcx==0 .and. bcy==1 .and. bcz==0) then
   deallocate(cw1,cw2,cw2b,rw2,rw2b)
   ! (010)   cw1 cw2  cw2b  rw2 rw2b
else if (bcx==1 .and. bcy==1) then
   deallocate(cw1,cw1b,cw2,cw2b,rw1,rw1b,rw2,rw2b)
   ! (11*)   cw1,cw1b,cw2,cw2b,rw1,rw1b,rw2,rw2b
   if (bcz==1) then
      deallocate(rw3)
    !(111)    rw3
   end if
end if

return
</code></pre>

<p>  end subroutine decomp_2d_poisson_finalize</p>

<p>  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Top level wrapper
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine poisson(rhs, bcx, bcy, bcz)</p>

<pre><code>implicit none

real(mytype), dimension(:,:,:), intent(INOUT) :: rhs
integer, intent(IN) :: bcx, bcy, bcz  ! boundary conditions
integer :: i

if (bcx==0 .and. bcy==0 .and. bcz==0) then
   call poisson_000(rhs)
else if (bcx==1 .and. bcy==0 .and. bcz==0) then
   call poisson_100(rhs)
else if (bcx==0 .and. bcy==1 .and. bcz==0) then
   call poisson_010(rhs)
else if (bcx==1 .and. bcy==1) then   ! 110 &amp; 111
   call poisson_11x(rhs, bcz)
else
   stop 'boundary condition not supported'
end if

return
</code></pre>

<p>  end subroutine poisson</p>

<p>  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Solving 3D Poisson equation with periodic B.C in all 3 dimensions
  !                                                      3
  !                                                      3
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine poisson_000(rhs)</p>

<pre><code>use derivX
use derivY
use derivZ

! right-hand-side of Poisson as input
! solution of Poisson as output
real(mytype), dimension(:,:,:), intent(INOUT) :: rhs

integer, dimension(3) :: fft_start, fft_end, fft_size

complex(mytype) :: xyzk

complex(mytype) :: ytt,xtt,ztt,yt1,xt1,yt2,xt2
complex(mytype) :: xtt1,ytt1,ztt1,zt1,zt2


real(mytype) :: tmp1, tmp2,x ,y, z

integer :: nx,ny,nz, i,j,k

nx = nx_global
ny = ny_global
nz = nz_global

if (.not. fft_initialised) then
   call decomp_2d_fft_init(PHYSICAL_IN_Z)
   fft_initialised = .true.
end if

! compute r2c transform   r2c:real to complex by zhaoliang
! cw1 is 3dim data structrue
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!! only fft to transform the real data to complex data while (100) twice
!!!!! one is tranform and then fft  (you can see poisson100
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
call decomp_2d_fft_3d(rhs,cw1)


! normalisation
!  why this below is called normalisation ??????  just divide 3dim grid number
cw1 = cw1 / real(nx, kind=mytype) /real(ny, kind=mytype) &amp;
     / real(nz, kind=mytype)

do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)

         ! post-processing in spectral space

         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !!!!!!!!!!!!!!!!!post-processing in 3-direction can be
         !!!!!!!!!!!!!!!!! set in the same cycle,because they are
         !!!!!!!!!!!!!!!!!! similar
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         ! POST PROCESSING IN Z
         tmp1 = real(cw1(i,j,k), kind=mytype)   !  get the real number of cw1
         tmp2 = aimag(cw1(i,j,k))               !  get the imagenumber of cw1
         cw1(i,j,k) = cmplx(tmp1*bz(k)+tmp2*az(k), &amp;
              tmp2*bz(k)-tmp1*az(k), kind=mytype)   ! modify the cw1 in the spectral space Z
                                                !  bz  az
                                                !  by  ay
                                                !  bx  ax

         ! POST PROCESSING IN Y
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         cw1(i,j,k) = cmplx(tmp1*by(j)+tmp2*ay(j), &amp;
              tmp2*by(j)-tmp1*ay(j), kind=mytype)
         if (j.gt.(ny/2+1)) cw1(i,j,k)=-cw1(i,j,k)   ! why should be axisymmetry!

         ! POST PROCESSING IN X
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         cw1(i,j,k) = cmplx(tmp1*bx(i)+tmp2*ax(i), &amp;
              tmp2*bx(i)-tmp1*ax(i), kind=mytype)
         if (i.gt.(nx/2+1)) cw1(i,j,k)=-cw1(i,j,k)

         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !!!!!!!!!!!!!!! Solve Poisson
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         tmp1=real(kxyz(i,j,k), kind=mytype)
         tmp2=aimag(kxyz(i,j,k))
         ! CANNOT DO A DIVISION BY ZERO
         !  Yes ! division  by zero is impossible!!!-----------------------------------&lt;
         if ((tmp1.lt.epsilon).or.(tmp2.lt.epsilon)) then   !epsilon?  what does it mean?
            cw1(i,j,k)=0._mytype
</code></pre>

<p>!                print *,&lsquo;DIV 0&rsquo;,i,j,k,epsilon</p>

<pre><code>         else
            cw1(i,j,k)=cmplx( real(cw1(i,j,k), kind=mytype) / (-tmp1), &amp;
                 aimag(cw1(i,j,k))/(-tmp2), kind=mytype)
         end if

       !Print result in spectal space after Poisson
  !     if (abs(out(i,j,k)) &gt; 1.0e-4) then
  !        write(*,*) 'AFTER',i,j,k,out(i,j,k),xyzk
  !     end if


         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         ! post-processing backward
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

         ! POST PROCESSING IN Z
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         cw1(i,j,k) = cmplx(tmp1*bz(k)-tmp2*az(k), &amp;
              -tmp2*bz(k)-tmp1*az(k), kind=mytype)
          !                                          bz    az
          !                                          by    ay
          !                                          bx    ax

         ! POST PROCESSING IN Y
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         cw1(i,j,k) = cmplx(tmp1*by(j)+tmp2*ay(j), &amp;
              tmp2*by(j)-tmp1*ay(j), kind=mytype)
         if (j.gt.(ny/2+1)) cw1(i,j,k)=-cw1(i,j,k)

         ! POST PROCESSING IN X
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         cw1(i,j,k) = cmplx(tmp1*bx(i)+tmp2*ax(i), &amp;
              -tmp2*bx(i)+tmp1*ax(i), kind=mytype)
         if (i.gt.(nx/2+1)) cw1(i,j,k)=-cw1(i,j,k)

      end do
   end do
end do

! compute c2r transform
call decomp_2d_fft_3d(cw1,rhs)    !  from complex  to real!
</code></pre>

<p> !   call decomp_2d_fft_finalize</p>

<pre><code>return
</code></pre>

<p>  end subroutine poisson_000</p>

<p>  subroutine poisson_100(rhs)</p>

<pre><code>  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!! get the rhs and then modify rhs ,at last return the rhs
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


implicit none

real(mytype), dimension(:,:,:), intent(INOUT) :: rhs

complex(mytype) :: xyzk
real(mytype) :: tmp1, tmp2, tmp3, tmp4
real(mytype) :: xx1,xx2,xx3,xx4,xx5,xx6,xx7,xx8

integer :: nx,ny,nz, i,j,k, itmp
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!  8 transform   from x --&gt;y --&gt;z then z--&gt; y ---&gt;x at the beginning
!!!!!!!!!!!!!!!!!!from x --&gt;y --&gt;z then z--&gt; y ---&gt;x at the endding
!!!!!  (100 add 8 more transform than 000) while 000 is 0 transform
!!!!!  so rhs is in the z pencil ,no there are not z pencil at all!
!!!!!   the program is  2-dim pm*pn decomp !  so only  xpencil and y pencil
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

               !!!!!!!!!!!!!!twice real to complex
                 !!!!!!!!!!! 1: transform rhs-rw2-rw1
                 !!!!!!!!!!! 2: fft       rhs-----rw1
               !!!!!!!!!!!!!!twice complex to real
                 !!!!!!!!!!! 1: transfrom rw1-rw2--rhs
                 !!!!!!!!!!! 2: fft       rw1------rhs
               !!!!!!!!!!!!! post-processing operations is under the complex condition
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!   input real rhs(:.:,:) in the z pencil
!!!!!!!!!!!!   2+2 transform    |destination: modify the rhs
!!!!!!!!!!!!   1 normalisation
!!!!!!!!!!!!   1 FFT forward
!!!!!!!!!!!!   3 post-processing   z--&gt;y---&gt;x  direction not pencil
!!!!!!!!!!!!   1 poisson solver
!!!!!!!!!!!!   3 post-processing backward  x---&gt;y----&gt;z  direction
!!!!!!!!!!!!   1 FFT backward
!!!!!!!!!!!!   2+2 transform    |destination: modify the rhs
!!!!!!!!!!!!   output real rhs(:,:,:)  in the z pencil
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
</code></pre>

<p>100 format(1x,a8,3I4,2F12.6)</p>

<pre><code>nx = nx_global - 1
ny = ny_global
nz = nz_global

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
! rhs is in Z-pencil(wrong!There isn't Z pencil)(wrong
  !again, there is Z pencil))but requires global operations in X
! why should do the transpose!!!!!!!!!!!!!!
   ! why in the poisson_000 is not needed!???????????????
!   two steps to change from z to x
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1

call transpose_z_to_y(rhs,rw2,ph)  ! z pencil in y pencil but in the physical space
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!rw2 is the complex 3-dim data the same as rw1
call transpose_y_to_x(rw2,rw1,ph)
do k=ph%xst(3),ph%xen(3)
   do j=ph%xst(2),ph%xen(2)
      do i=1,nx/2
          !!! rw1  rw1b   1 means  x pencil   
          !!! rw2  rw2b   2 means  y pencil
         rw1b(i,j,k)=rw1(2*(i-1)+1,j,k)  ! the odd terms  is for the half before
      enddo
      do i=nx/2+1,nx
         rw1b(i,j,k)=rw1(2*nx-2*i+2,j,k)  ! the reverse terms is for the half after
      enddo
   enddo
end do

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
!!!!3 layers data
!!!! rw1b is the top lay data  xpencil     physical space
!!!! rw2  is in the middle lay data   y pencil   physical space
!!!! rw1 rhs  is in the outer lay data    z pencil  spectral space
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11

call transpose_x_to_y(rw1b,rw2,ph)    ! let x pencil rw1b to y pencil
call transpose_y_to_z(rw2,rhs,ph)     ! let y pencil rw2 to  z pencil's rhs
!!!!!!!!!!!!first time get what we want

if (.not. fft_initialised) then
   call decomp_2d_fft_init(PHYSICAL_IN_Z,nx,ny,nz)
   fft_initialised = .true.
end if

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! compute r2c transform
!           why should force the before pre-posting   ------------------------------&lt;&lt;&lt;&lt;
!!!!!!!!!the most key operation :::: the fft operator: decomp_2d_fft_3d
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

call decomp_2d_fft_3d(rhs,cw1)  !  from real to complex!  and begin poission solver


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! in the z pencil we did the fft transform
    !!!!!!!!!!!!!!!!!! so cw1 is 3d complex data ,yeah (:,:,:)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



! normalisation
cw1 = cw1 / real(nx, kind=mytype) /real(ny, kind=mytype) &amp;
     / real(nz, kind=mytype)
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         if (abs(cw1(i,j,k)) &gt; 1.0e-4) then
            write(*,100) 'START',i,j,k,cw1(i,j,k)
         end if
      end do
   end do
end do
</code></pre>

<h1>endif</h1>

<pre><code>! post-processing in spectral space

! POST PROCESSING IN Z
do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         cw1(i,j,k) = cmplx(tmp1*bz(k)+tmp2*az(k), &amp;
              tmp2*bz(k)-tmp1*az(k), kind=mytype)
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>         if (abs(cw1(i,j,k)) &gt; 1.0e-4) &amp;
              write(*,100) 'after z',i,j,k,cw1(i,j,k)
</code></pre>

<h1>endif</h1>

<pre><code>      end do
   end do
end do

! POST PROCESSING IN Y
do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         cw1(i,j,k) = cmplx(tmp1*by(j)+tmp2*ay(j), &amp;
              tmp2*by(j)-tmp1*ay(j), kind=mytype)
         if (j.gt.(ny/2+1)) cw1(i,j,k)=-cw1(i,j,k)
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>         if (abs(cw1(i,j,k)) &gt; 1.0e-4) &amp;
              write(*,100) 'after y',i,j,k,cw1(i,j,k)
</code></pre>

<h1>endif</h1>

<pre><code>      end do
   end do
end do

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!because (100)
               !!!!!!!!!!!!!!!!!!!!!so the post processing in x is different
               !!!!!!!!!!!!!!!!!!!!!from the  y and z
! POST PROCESSING IN X
do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      cw1b(1,j,k)=cw1(1,j,k)
      do i = 2,nx
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         tmp3 = real(cw1(nx-i+2,j,k), kind=mytype) !!! the 2~nx
         tmp4 = aimag(cw1(nx-i+2,j,k))    !!!!!!!!!!!!     2~nx
         xx1=tmp1*bx(i)/2._mytype
         xx2=tmp1*ax(i)/2._mytype
         xx3=tmp2*bx(i)/2._mytype
         xx4=tmp2*ax(i)/2._mytype
         xx5=tmp3*bx(i)/2._mytype
         xx6=tmp3*ax(i)/2._mytype
         xx7=tmp4*bx(i)/2._mytype
         xx8=tmp4*ax(i)/2._mytype
         cw1b(i,j,k) = cmplx(xx1+xx4+xx5-xx8,-xx2+xx3+xx6+xx7, &amp;
              kind=mytype)  
      end do
   end do
end do
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  While  you set the -Debug in the compile period
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         if (abs(cw1b(i,j,k)) &gt; 1.0e-4) then
            write(*,100) 'after x',i,j,k,cw1b(i,j,k)
         end if
      end do
   end do
end do
</code></pre>

<h1>endif</h1>

<p>!!!!!!!!!!!!!!!!!!!!!from now on, the cw1b in x,y,z direction(not pencil)
!!!!!!!!!!!!!!!!!!!!is calculated ,so now you can calculate cw1b in the
!!!!!!!!!!!!!!!!!!!!!!! poisson condition ,yes poisson solver</p>

<pre><code>! Solve Poisson
do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         !tmp1=real(zk2(k)+yk2(j)+xk2(i), kind=mytype)
         !tmp2=aimag(zk2(k)+yk2(j)+xk2(i))
         tmp1=real(kxyz(i,j,k), kind=mytype)
         tmp2=aimag(kxyz(i,j,k))
         !xyzk=cmplx(tmp1,tmp2, kind=mytype)
         ! CANNOT DO A DIVISION BY ZERO
</code></pre>

<p>! yes</p>

<pre><code>         if ((abs(tmp1).lt.epsilon).and.(abs(tmp2).lt.epsilon)) then    
            cw1b(i,j,k)=cmplx(0._mytype,0._mytype, kind=mytype)
         end if
         if ((abs(tmp1).lt.epsilon).and.(abs(tmp2).ge.epsilon)) then
            cw1b(i,j,k)=cmplx(0._mytype, &amp;
                 aimag(cw1b(i,j,k))/(-tmp2), kind=mytype)
         end if
         if ((abs(tmp1).ge.epsilon).and.(abs(tmp2).lt.epsilon)) then    
            cw1b(i,j,k)=cmplx( real(cw1b(i,j,k), kind=mytype) &amp;
                 /(-tmp1), 0._mytype, kind=mytype)
         end if
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         !!!!!!!!!!!!!!!!!!the most dayly processing
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         if ((abs(tmp1).ge.epsilon).and.(abs(tmp2).ge.epsilon)) then
            cw1b(i,j,k)=cmplx( real(cw1b(i,j,k), kind=mytype) &amp;
                 /(-tmp1), &amp;
                 aimag(cw1b(i,j,k))/(-tmp2), kind=mytype)
         end if
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>         if (abs(cw1b(i,j,k)) &gt; 1.0e-4) &amp;
              write(*,100) 'AFTER',i,j,k,cw1b(i,j,k)
</code></pre>

<h1>endif</h1>

<pre><code>      end do
   end do
end do

! post-processing backward
</code></pre>

<p>!!!!!!!!!!!!!!!!!!!!!!  You know cw1b is the cw1&rsquo;s another form in the spectral
!!!!!!!!!!!!!!!!!!!!!! space ,so you need to change the spetral space to physical
!!!!!!!!!!!!!!!!!!!!!!! space again ,yes get the cw1
!!!!!!!!!!!!!!!!!!!!!!!! from now on ,you will found that the calculate of poisson
!!!!!!!!!!!!!!!!!!!!!!!! equation is in the spectral space ,from the fft,then 3 post
!!!!!!!!!!!!!!!!!!!!!!!!!! processing in x,y,z 3 directions, then calculate the  poisson
!!!!!!!!!!!!!!!!!!!!!!!!!! equation. OK,then you start next!</p>

<pre><code>! POST PROCESSING IN X
do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      cw1(1,j,k)=cw1b(1,j,k)
      do i = 2,nx
         tmp1 = real(cw1b(i,j,k), kind=mytype)
         tmp2 = aimag(cw1b(i,j,k))
         tmp3 = real(cw1b(nx-i+2,j,k), kind=mytype)
         tmp4 = aimag(cw1b(nx-i+2,j,k))
         xx1=tmp1*bx(i)
         xx2=tmp1*ax(i)
         xx3=tmp2*bx(i)
         xx4=tmp2*ax(i)
         xx5=tmp3*bx(i)
         xx6=tmp3*ax(i)
         xx7=tmp4*bx(i)
         xx8=tmp4*ax(i)
         cw1(i,j,k) = cmplx(xx1-xx4+xx6+xx7,-(-xx2-xx3+xx5-xx8), &amp;
              kind=mytype)        
          !!!!!the buterfly algorithm!!!!!!!!!!!!!!!!!!!!!!!
      end do
   end do
end do
!!!!!!!!!!!!!!!!!!!!!!!from now on x direction ,the spectral data has been transform to
!!!!!!!!!!!!!!!!!!!!!!!! physical space, but still the complex
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         if (abs(cw1(i,j,k)) &gt; 1.0e-4) then
            write(*,100) 'AFTER X',i,j,k,cw1(i,j,k)
         end if
      end do
   end do
end do
</code></pre>

<h1>endif</h1>

<pre><code>! POST PROCESSING IN Y
do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         cw1(i,j,k) = cmplx(tmp1*by(j)-tmp2*ay(j), &amp;
              tmp2*by(j)+tmp1*ay(j), kind=mytype)
         if (j.gt.(ny/2+1)) cw1(i,j,k)=-cw1(i,j,k)
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>         if (abs(cw1(i,j,k)) &gt; 1.0e-4) &amp;
              write(*,100) 'AFTER Y',i,j,k,cw1(i,j,k)
</code></pre>

<h1>endif</h1>

<pre><code>      end do
   end do
end do

                                !!!!!!!!!!!!!!!!!!!!!! by  ay
                                !!!!!!!!!!!!!!!!!!!!!! bz  az
! POST PROCESSING IN Z
do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         cw1(i,j,k) = cmplx(tmp1*bz(k)-tmp2*az(k), &amp;
              tmp2*bz(k)+tmp1*az(k), kind=mytype)
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>         if (abs(cw1(i,j,k)) &gt; 1.0e-4) &amp;
              write(*,100) 'END',i,j,k,cw1(i,j,k)
</code></pre>

<h1>endif</h1>

<pre><code>      end do
   end do
end do

! compute c2r transform
call decomp_2d_fft_3d(cw1,rhs)

! rhs is in Z-pencil but requires global operations in X
call transpose_z_to_y(rhs,rw2,ph)
call transpose_y_to_x(rw2,rw1,ph)
do k=ph%xst(3),ph%xen(3)
   do j=ph%xst(2),ph%xen(2)
      do i=1,nx/2
         rw1b(2*i-1,j,k)=rw1(i,j,k)   ! the odd terms is setted!
      enddo
      do i=1,nx/2
         rw1b(2*i,j,k)=rw1(nx-i+1,j,k)  ! the even terms is setted
      enddo
   enddo
end do
call transpose_x_to_y(rw1b,rw2,ph)
call transpose_y_to_z(rw2,rhs,ph)
</code></pre>

<p>!!!!!!!!!!!!!the finally outcome rhs</p>

<p>  !  call decomp_2d_fft_finalize</p>

<pre><code>return
</code></pre>

<p>  end subroutine poisson_100</p>

<p>  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Neumann!!!!!!!!!!!!!!!!!!!!!!!!!!!111
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</p>

<p>  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Solving 3D Poisson equation: Neumann in Y; periodic in X &amp; Z
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine poisson_010(rhs)</p>

<pre><code>implicit none

real(mytype), dimension(:,:,:), intent(INOUT) :: rhs

complex(mytype) :: xyzk
real(mytype) :: tmp1, tmp2, tmp3, tmp4
real(mytype) :: xx1,xx2,xx3,xx4,xx5,xx6,xx7,xx8

integer :: nx,ny,nz, i,j,k
</code></pre>

<p>100 format(1x,a8,3I4,2F12.6)</p>

<pre><code>nx = nx_global
ny = ny_global - 1  ! (010)  so have fewer1 ny!
nz = nz_global

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!so if (11*)  you need to ?what pencil??????
!!!!??
! rhs is in Z-pencil but requires global operations in Y  because(010)

               !!!!!!!!!!!!!!twice real to complex
                 !!!!!!!!!!! 1: transform rhs-rw2-rw1
                 !!!!!!!!!!! 2: fft       rhs-----rw1
               !!!!!!!!!!!!!!twice complex to real
                 !!!!!!!!!!! 1: transfrom rw1-rw2--rhs
                 !!!!!!!!!!! 2: fft       rw1------rhs
               !!!!!!!!!!!!! post-processing operations is under the complex condition
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!   input real rhs(:.:,:) in the z pencil
!!!!!!!!!!!!   1+1 transform  z-&gt;y y-&gt;z  |destination: modify the rhs  because z-y=1  rather than z-x=2
!!!!!!!!!!!!   1 normalisation
!!!!!!!!!!!!   1 FFT forward
!!!!!!!!!!!!   2 post-processing   z--&gt;x  direction not pencil
!!!!!!!!!!!!   1 transform z-y
!!!!!!!!!!!!   1 post-processing   y
!!!!!!!!!!!!   1 poisson solver
!!!!!!!!!!!!   1 matrice_refinement
!!!!!!!!!!!!   3 inversion5_v1  inversion5_v2
!!!!!!!!!!!!   1 post-processing backward  Y
!!!!!!!!!!!!   1 transform y-z
!!!!!!!!!!!!   2 post-processing backward  x----&gt;z  direction
!!!!!!!!!!!!   1 FFT backward
!!!!!!!!!!!!   1+1 transform    |destination: modify the rhs
!!!!!!!!!!!!   output real rhs(:,:,:)  in the z pencil
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
               !!!!!!!!!!!!!!!!!!so the key factor  a  a2  a3    ax bx
               !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ay by
               !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! az bz

call transpose_z_to_y(rhs,rw2,ph)
do k=ph%yst(3),ph%yen(3)
   do i=ph%yst(1),ph%yen(1)
      do j=1,ny/2
         rw2b(i,j,k)=rw2(i,2*(j-1)+1,k)
      enddo
      do j=ny/2+1,ny
         rw2b(i,j,k)=rw2(i,2*ny-2*j+2,k)
      enddo
   enddo
end do
call transpose_y_to_z(rw2b,rhs,ph)

if (.not. fft_initialised) then
   call decomp_2d_fft_init(PHYSICAL_IN_Z,nx,ny,nz)
   fft_initialised = .true.
end if
! compute r2c transform
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
call decomp_2d_fft_3d(rhs,cw1)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! normalisation
cw1 = cw1 / real(nx, kind=mytype) /real(ny, kind=mytype) &amp;
     / real(nz, kind=mytype)
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         if (abs(cw1(i,j,k)) &gt; 1.0e-4) then
            write(*,100) 'START',i,j,k,cw1(i,j,k)
         end if
      end do
   end do
end do
</code></pre>

<h1>endif</h1>

<pre><code>! post-processing in spectral space

! POST PROCESSING IN Z
do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         cw1(i,j,k) = cmplx(tmp1*bz(k)+tmp2*az(k), &amp;
              tmp2*bz(k)-tmp1*az(k), kind=mytype)
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>         if (abs(cw1(i,j,k)) &gt; 1.0e-4) &amp;
              write(*,100) 'after z',i,j,k,cw1(i,j,k)
</code></pre>

<h1>endif</h1>

<pre><code>      end do
   end do
end do

! POST PROCESSING IN X
do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         cw1(i,j,k) = cmplx(tmp1*bx(i)+tmp2*ax(i), &amp;
              tmp2*bx(i)-tmp1*ax(i), kind=mytype)
         if (i.gt.(nx/2+1)) cw1(i,j,k)=-cw1(i,j,k)
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>         if (abs(cw1(i,j,k)) &gt; 1.0e-4) &amp;
              write(*,100) 'after x',i,j,k,cw1(i,j,k)
</code></pre>

<h1>endif</h1>

<pre><code>      end do
   end do
end do

! POST PROCESSING IN Y
! NEED TO BE IN Y PENCILS!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!sp!!!!!!!!!!!!!!!!!!!!!!!!!!!!
call transpose_x_to_y(cw1,cw2,sp)

!!!!!!!!!!!!!!!!!!!!!sp!!!!!!!!!!!!!!!!!!!!!!!!!!!!
do k = sp%yst(3), sp%yen(3)
   do i = sp%yst(1), sp%yen(1)
      cw2b(i,1,k)=cw2(i,1,k)
      do j = 2,ny      
         tmp1 = real(cw2(i,j,k), kind=mytype)
         tmp2 = aimag(cw2(i,j,k))
         tmp3 = real(cw2(i,ny-j+2,k), kind=mytype)
         tmp4 = aimag(cw2(i,ny-j+2,k))
         xx1=tmp1*by(j)/2._mytype
         xx2=tmp1*ay(j)/2._mytype
         xx3=tmp2*by(j)/2._mytype
         xx4=tmp2*ay(j)/2._mytype
         xx5=tmp3*by(j)/2._mytype
         xx6=tmp3*ay(j)/2._mytype
         xx7=tmp4*by(j)/2._mytype
         xx8=tmp4*ay(j)/2._mytype
         cw2b(i,j,k) = cmplx(xx1+xx4+xx5-xx8,-xx2+xx3+xx6+xx7, &amp;
              kind=mytype)
      end do
   end do
end do
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>do k = sp%yst(3), sp%yen(3)
   do j = sp%yst(2), sp%yen(2)
      do i = sp%yst(1), sp%yen(1)
         if (abs(cw2b(i,j,k)) &gt; 1.0e-4) then
            write(*,100) 'after y',i,j,k,cw2b(i,j,k)
            print *,kxyz(i,j,k)
         end if
      end do
   end do
end do
</code></pre>

<h1>endif</h1>

<pre><code>if (istret==0) then

! Solve Poisson
! doing wave number division in Y-pencil
do k = sp%yst(3), sp%yen(3)
   do j = sp%yst(2), sp%yen(2)
      do i = sp%yst(1), sp%yen(1)
         !tmp1=real(zk2(k)+yk2(j)+xk2(i), kind=mytype)
         !tmp2=aimag(zk2(k)+yk2(j)+xk2(i))
         tmp1=real(kxyz(i,j,k), kind=mytype)
         tmp2=aimag(kxyz(i,j,k))
         !xyzk=cmplx(tmp1,tmp2, kind=mytype)
         !CANNOT DO A DIVISION BY ZERO
         if ((abs(tmp1).lt.epsilon).and.(abs(tmp2).lt.epsilon)) then    
            cw2b(i,j,k)=cmplx(0._mytype,0._mytype, kind=mytype)
         end if
         if ((abs(tmp1).lt.epsilon).and.(abs(tmp2).ge.epsilon)) then
            cw2b(i,j,k)=cmplx(0._mytype, &amp;
                 aimag(cw2b(i,j,k))/(-tmp2), kind=mytype)
         end if
         if ((abs(tmp1).ge.epsilon).and.(abs(tmp2).lt.epsilon)) then    
            cw2b(i,j,k)=cmplx( real(cw2b(i,j,k), kind=mytype) &amp;
                 /(-tmp1), 0._mytype, kind=mytype)
         end if
         if ((abs(tmp1).ge.epsilon).and.(abs(tmp2).ge.epsilon)) then
            cw2b(i,j,k)=cmplx( real(cw2b(i,j,k), kind=mytype) &amp;
                 /(-tmp1), &amp;
                 aimag(cw2b(i,j,k))/(-tmp2), kind=mytype)
         end if
      end do
   end do
end do

else

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   call matrice_refinement()
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
</code></pre>

<p>!       do k = sp%yst(3), sp%yen(3)
!          do j = 1,ny/2
!             do i = sp%yst(1), sp%yen(1)
!                print <em>,i,j,k,a(i,j,k,3)
!!                if (nrank.le.1) print </em>,i,j,k,a(i,j,k,3)
!!                if (nrank.gt.1) print *,i+4,j,k,a(i,j,k,3)
!             enddo
!          enddo
!       enddo</p>

<p>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!istret  !=3
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</p>

<pre><code>   if (istret.ne.3) then
      cw2(:,:,:)=0.;cw2c(:,:,:)=0.
      do k = sp%yst(3), sp%yen(3)
      do j = 1,ny/2
      do i = sp%yst(1), sp%yen(1)
         cw2(i,j,k)=cw2b(i,2*j-1,k)
         cw2c(i,j,k)=cw2b(i,2*j,k)
      enddo
      enddo
      enddo
</code></pre>

<p> !   do k = sp%yst(3), sp%yen(3)
 !      do j = 1,ny/2
 !         do i = sp%yst(1), sp%yen(1)
 !            if (abs(cw2(i,j,k)) > 1.0e-4) then
 !               write(<em>,</em>) &lsquo;before IN&rsquo;,i,j,k,cw2(i,j,k)!*2.
 !!            end if
  !        end do
  !     end do
  !  end do</p>

<p>  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!for the strech  grid!!!!!!!!!!!!!!!!!!!!!!!</p>

<pre><code>     call inversion5_v1(a,cw2,sp)
     call inversion5_v1(a2,cw2c,sp)
</code></pre>

<p>!         cw2(1,1,1)=cw2(1,1,1)*0.5</p>

<p>!   do k = sp%yst(3), sp%yen(3)
!       do j = 1,ny/2
!          do i = sp%yst(1), sp%yen(1)
!             if (abs(cw2c(i,j,k)) > 1.0e-4) then
!                write(<em>,</em>) &lsquo;after IN&rsquo;,i,j,k,cw2c(i,j,k)!*2.
!             end if
!          end do
!       end do
!    end do</p>

<pre><code>      cw2b(:,:,:)=0.
      do k=sp%yst(3), sp%yen(3)
      do j=1,ny-1,2
      do i=sp%yst(1), sp%yen(1)
         cw2b(i,j,k)=cw2(i,(j+1)/2,k)
      enddo
      enddo
      do j=2,ny,2
      do i=sp%yst(1), sp%yen(1)
         cw2b(i,j,k)=cw2c(i,j/2,k)
      enddo
      enddo
      enddo
      !do k=sp%yst(3), sp%yen(3)
      !do i=sp%yst(1), sp%yen(1)
      !   if ((xkx(i)==0).and.(zkz(k)==0)) then
      !   !   cw2b(i,1,1)=0.
      !   !   cw2b(i,ny,1)=0.
      !   endif
      !enddo
      !enddo
   else
      do k = sp%yst(3), sp%yen(3)
      do j = 1,ny
      do i = sp%yst(1), sp%yen(1)
         cw2(i,j,k)=cw2b(i,j,k)
      enddo
      enddo
      enddo
      call inversion5_v2(a3,cw2,sp)
      do k = sp%yst(3), sp%yen(3)
      do j = 1,ny
      do i = sp%yst(1), sp%yen(1)
         cw2b(i,j,k)=cw2(i,j,k)
      enddo
      enddo
      enddo
   endif

endif
</code></pre>

<p>!    print *,nrank, sp%yst(3),sp%yen(3),sp%yst(1),sp%yen(1)</p>

<p>!we are in Y pencil</p>

<pre><code>do k = sp%yst(3), sp%yen(3)  
do i = sp%yst(1), sp%yen(1)
   if ((i==nx/2+1).and.(k==nz/2+1)) then
      cw2b(i,:,k)=0.
   endif
enddo
enddo
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>do k = sp%yst(3), sp%yen(3)
   do j = sp%yst(2), sp%yen(2)
      do i = sp%yst(1), sp%yen(1)
         if (abs(cw2b(i,j,k)) &gt; 1.0e-4) then
            write(*,100) 'AFTER',i,j,k,cw2b(i,j,k)
            print *,kxyz(i,j,k)
         end if
      end do
   end do
end do
</code></pre>

<h1>endif</h1>

<pre><code>! post-processing backward

! POST PROCESSING IN Y
do k = sp%yst(3), sp%yen(3)
   do i = sp%yst(1), sp%yen(1)
      cw2(i,1,k)=cw2b(i,1,k)
      do j = 2,ny
         tmp1 = real(cw2b(i,j,k), kind=mytype)
         tmp2 = aimag(cw2b(i,j,k))
         tmp3 = real(cw2b(i,ny-j+2,k), kind=mytype)
         tmp4 = aimag(cw2b(i,ny-j+2,k))
         xx1=tmp1*by(j)
         xx2=tmp1*ay(j)
         xx3=tmp2*by(j)
         xx4=tmp2*ay(j)
         xx5=tmp3*by(j)
         xx6=tmp3*ay(j)
         xx7=tmp4*by(j)
         xx8=tmp4*ay(j)
         cw2(i,j,k) = cmplx(xx1-xx4+xx6+xx7,-(-xx2-xx3+xx5-xx8), &amp;
              kind=mytype)
      end do
   end do
end do

! Back to X-pencil
call transpose_y_to_x(cw2,cw1,sp)
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         if (abs(cw1(i,j,k)) &gt; 1.0e-4) then
            write(*,100) 'AFTER Y',i,j,k,cw1(i,j,k)
         end if
      end do
   end do
end do
</code></pre>

<h1>endif</h1>

<pre><code>! POST PROCESSING IN X
do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         cw1(i,j,k) = cmplx(tmp1*bx(i)-tmp2*ax(i), &amp;
              tmp2*bx(i)+tmp1*ax(i), kind=mytype)
         if (i.gt.(nx/2+1)) cw1(i,j,k)=-cw1(i,j,k)
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>         if (abs(cw1(i,j,k)) &gt; 1.0e-4) &amp;
              write(*,100) 'AFTER X',i,j,k,cw1(i,j,k)
</code></pre>

<h1>endif</h1>

<pre><code>      end do
   end do
end do

! POST PROCESSING IN Z
do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         cw1(i,j,k) = cmplx(tmp1*bz(k)-tmp2*az(k), &amp;
              tmp2*bz(k)+tmp1*az(k), kind=mytype)
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>         if (abs(cw1(i,j,k)) &gt; 1.0e-4) &amp;
              write(*,100) 'END',i,j,k,cw1(i,j,k)
</code></pre>

<h1>endif</h1>

<pre><code>      end do
   end do
end do

! compute c2r transform, back to physical space

call decomp_2d_fft_3d(cw1,rhs)

! rhs is in Z-pencil but requires global operations in Y
call transpose_z_to_y(rhs,rw2,ph)
do k=ph%yst(3),ph%yen(3)
   do i=ph%yst(1),ph%yen(1)
      do j=1,ny/2
         rw2b(i,2*j-1,k)=rw2(i,j,k)
      enddo
      do j=1,ny/2
         rw2b(i,2*j,k)=rw2(i,ny-j+1,k)
      enddo
   enddo
end do
call transpose_y_to_z(rw2b,rhs,ph)
</code></pre>

<p>  !  call decomp_2d_fft_finalize</p>

<pre><code>return
</code></pre>

<p>  end subroutine poisson_010</p>

<p>  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!Neumann!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!11x!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!Neumann Neumann Neumann!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!Neumann Neumann periodic!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</p>

<p>  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Solving 3D Poisson equation: Neumann in X, Y; Neumann/periodic in Z
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine poisson_11x(rhs, nclz1)</p>

<pre><code>               !!!!!!!!!!!!!!twice real to complex
                 !!!!!!!!!!! 1: transform rhs-rw2-rw1
                 !!!!!!!!!!! 2: fft       rhs-----rw1
               !!!!!!!!!!!!!!twice complex to real
                 !!!!!!!!!!! 1: transfrom rw1-rw2--rhs
                 !!!!!!!!!!! 2: fft       rw1------rhs
               !!!!!!!!!!!!! post-processing operations is under the complex condition
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!   input real rhs(:.:,:) in the z pencil
!!!!!!!!!!!!   2+2 transform    z--y  y-&gt;x   x-y y-z|destination: modify the rhs
!!!!!!!!!!!!   1 normalisation
!!!!!!!!!!!!   1 FFT forward
!!!!!!!!!!!!   1 post-processing  z
!!!!!!!!!!!!   1 transpose  x--y
!!!!!!!!!!!!   1 post-processing  y
!!!!!!!!!!!!   1 transpose  y--x
!!!!!!!!!!!!   1 post-processing  x (because  he thinks he is in X pencil, Zhaoliang said no)
!!!!!!!!!!!!   1 poisson solver
!!!!!!!!!!!!   1 matrice_refinemento
!!!!!!!!!!!!   1 transpse   x--y  (for strecting  because strecthing is in the y direction)
!!!!!!!!!!!!   1 inversion5_v1
!!!!!!!!!!!!   1 transpose  y---x
!!!!!!!!!!!!  
!!!!!!!!!!!!   1 post-processing x
!!!!!!!!!!!!   1 transpose  x-y
!!!!!!!!!!!!   1 post-processing y
!!!!!!!!!!!!   1 transpose  y-x
!!!!!!!!!!!!   1 post-processing z
!!!!!!!!!!!!!
!!!!!!!!!!!!   1 FFT backward
!!!!!!!!!!!!   2+2 transform    |destination: modify the rhs
!!!!!!!!!!!!   output real rhs(:,:,:)  in the z pencil
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



implicit none

integer, intent(IN) :: nclz1    
real(mytype), dimension(:,:,:), intent(INOUT) :: rhs

complex(mytype) :: xyzk
real(mytype) :: tmp1, tmp2, tmp3, tmp4
real(mytype) :: xx1,xx2,xx3,xx4,xx5,xx6,xx7,xx8

integer :: nx,ny,nz, i,j,k
</code></pre>

<p>100 format(1x,a8,3I4,2F12.6)</p>

<pre><code>nx = nx_global - 1   ! becasuse (110)
ny = ny_global - 1

if (nclz1==1) then     !!!!!the free-slip boundary condition
   nz = nz_global - 1
else if (nclz1==0) then
   nz = nz_global
end if

if (nclz1==1) then  
   do j=1,ph%zsz(2)
      do i=1,ph%zsz(1)
         do k=1,nz/2
            rw3(i,j,k)=rhs(i,j,2*(k-1)+1)
         end do
         do k=nz/2+1,nz
            rw3(i,j,k)=rhs(i,j,2*nz-2*k+2)
         end do
      end do
   end do
   call transpose_z_to_y(rw3,rw2,ph)
else if (nclz1==0) then     
   call transpose_z_to_y(rhs,rw2,ph)
end if


do k=ph%yst(3),ph%yen(3)
   do i=ph%yst(1),ph%yen(1)
      do j=1,ny/2
         rw2b(i,j,k)=rw2(i,2*(j-1)+1,k)
      end do
      do j=ny/2+1,ny
         rw2b(i,j,k)=rw2(i,2*ny-2*j+2,k)
      end do
   end do
end do

! the global operations in X
call transpose_y_to_x(rw2b,rw1,ph)

do k=ph%xst(3),ph%xen(3)
   do j=ph%xst(2),ph%xen(2)
      do i=1,nx/2
         rw1b(i,j,k)=rw1(2*(i-1)+1,j,k)
      end do
      do i=nx/2+1,nx
         rw1b(i,j,k)=rw1(2*nx-2*i+2,j,k)
      end do
   end do
end do

! back to Z-pencil
call transpose_x_to_y(rw1b,rw2,ph)
call transpose_y_to_z(rw2,rhs,ph)

if (.not. fft_initialised) then
   call decomp_2d_fft_init(PHYSICAL_IN_Z,nx,ny,nz)
   fft_initialised = .true.
end if

! compute r2c transform

call decomp_2d_fft_3d(rhs,cw1)



! normalisation
cw1 = cw1 / real(nx, kind=mytype) /real(ny, kind=mytype) &amp;
     / real(nz, kind=mytype)
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         if (abs(cw1(i,j,k)) &gt; 1.0e-4) then
            write(*,100) 'START',i,j,k,cw1(i,j,k)
         end if
      end do
   end do
end do
</code></pre>

<h1>endif</h1>

<pre><code>! post-processing in spectral space

! POST PROCESSING IN Z
do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         cw1(i,j,k) = cmplx(tmp1*bz(k)+tmp2*az(k), &amp;
              tmp2*bz(k)-tmp1*az(k), kind=mytype)
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>         if (abs(cw1(i,j,k)) &gt; 1.0e-4) &amp;
              write(*,100) 'after z',i,j,k,cw1(i,j,k)
</code></pre>

<h1>endif</h1>

<pre><code>      end do
   end do
end do


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!while  1  should be in the corresponding pencils
!!!!!!!!!!!!!!!!!!!!!!!!!!!characteristic 2 : there sholud be tmp1*2*3*4
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

! POST PROCESSING IN Y
! WE HAVE TO BE IN Y PENCILS



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!No  we should be the z pencil!  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!there is something wrong in the source code!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!But now we are in the z pencil not in
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  the x pencil!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!so,it should be
!!!!!!!!!!!!!!!!!call transpose_z_to_y rather than transpose_x_to_y
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
call transpose_x_to_y(cw1,cw2,sp)
do k = sp%yst(3), sp%yen(3)
   do i = sp%yst(1), sp%yen(1)
      cw2b(i,1,k)=cw2(i,1,k)
      do j = 2,ny
         tmp1 = real(cw2(i,j,k), kind=mytype)
         tmp2 = aimag(cw2(i,j,k))
         tmp3 = real(cw2(i,ny-j+2,k), kind=mytype)
         tmp4 = aimag(cw2(i,ny-j+2,k))
         xx1=tmp1*by(j)/2._mytype
         xx2=tmp1*ay(j)/2._mytype
         xx3=tmp2*by(j)/2._mytype
         xx4=tmp2*ay(j)/2._mytype
         xx5=tmp3*by(j)/2._mytype
         xx6=tmp3*ay(j)/2._mytype
         xx7=tmp4*by(j)/2._mytype
         xx8=tmp4*ay(j)/2._mytype
         cw2b(i,j,k) = cmplx(xx1+xx4+xx5-xx8,-xx2+xx3+xx6+xx7, &amp;
              kind=mytype)  
      end do
   end do
end do

! back to X-pencil
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!the same wrong ,now you should
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!go back to the z pencil rather than the x pencil
call transpose_y_to_x(cw2b,cw1,sp)
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         if (abs(cw1(i,j,k)) &gt; 1.0e-4) then
            write(*,100) 'after y',i,j,k,cw1(i,j,k)
         end if
      end do
   end do
end do
</code></pre>

<h1>endif</h1>

<pre><code>! POST PROCESSING IN X
do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      cw1b(1,j,k)=cw1(1,j,k)
      do i = 2,nx
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         tmp3 = real(cw1(nx-i+2,j,k), kind=mytype)
         tmp4 = aimag(cw1(nx-i+2,j,k))
         xx1=tmp1*bx(i)/2._mytype
         xx2=tmp1*ax(i)/2._mytype
         xx3=tmp2*bx(i)/2._mytype
         xx4=tmp2*ax(i)/2._mytype
         xx5=tmp3*bx(i)/2._mytype
         xx6=tmp3*ax(i)/2._mytype
         xx7=tmp4*bx(i)/2._mytype
         xx8=tmp4*ax(i)/2._mytype
         cw1b(i,j,k) = cmplx(xx1+xx4+xx5-xx8,-xx2+xx3+xx6+xx7, &amp;
              kind=mytype)  
      end do
   end do
end do
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         if (abs(cw1b(i,j,k)) &gt; 1.0e-4) then
            write(*,*) 'BEFORE',i,j,k,cw1b(i,j,k)
         end if
      end do
   end do
end do
</code></pre>

<h1>endif</h1>

<pre><code>if (istret==0) then

! Solve Poisson
do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         !tmp1=real(zk2(k)+yk2(j)+xk2(i), kind=mytype)
         !tmp2=aimag(zk2(k)+yk2(j)+xk2(i))
         tmp1=real(kxyz(i,j,k), kind=mytype)
         tmp2=aimag(kxyz(i,j,k))
         !xyzk=cmplx(tmp1,tmp2, kind=mytype)
         !CANNOT DO A DIVISION BY ZERO
         if ((abs(tmp1).lt.epsilon).and.(abs(tmp2).lt.epsilon)) then    
            cw1b(i,j,k)=cmplx(0._mytype,0._mytype, kind=mytype)
         end if
         if ((abs(tmp1).lt.epsilon).and.(abs(tmp2).ge.epsilon)) then
            cw1b(i,j,k)=cmplx(0._mytype, &amp;
                 aimag(cw1b(i,j,k))/(-tmp2), kind=mytype)
         end if
         if ((abs(tmp1).ge.epsilon).and.(abs(tmp2).lt.epsilon)) then    
            cw1b(i,j,k)=cmplx( real(cw1b(i,j,k), kind=mytype) &amp;
                 /(-tmp1), 0._mytype, kind=mytype)
         end if
         if ((abs(tmp1).ge.epsilon).and.(abs(tmp2).ge.epsilon)) then
            cw1b(i,j,k)=cmplx( real(cw1b(i,j,k), kind=mytype) &amp;
                 /(-tmp1), &amp;
                 aimag(cw1b(i,j,k))/(-tmp2), kind=mytype)
         end if
      end do
   end do
end do

else
   call matrice_refinement()
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11so       we  should  z-&gt;y pencil but not  x-&gt;ypencil
</code></pre>

<p>! the stretching is only working in Y pencils</p>

<p>!!!!!!!!!!!!!!!why the default the pencil is  x pencil rather than z pencil!!!</p>

<pre><code>   call transpose_x_to_y(cw1b,cw2b,sp)
   !we are now in Y pencil

   if (istret.ne.3) then
      cw2(:,:,:)=0.;cw2c(:,:,:)=0.
      do k = sp%yst(3), sp%yen(3)
      do j = 1,ny/2
      do i = sp%yst(1), sp%yen(1)
         cw2(i,j,k)=cw2b(i,2*j-1,k)
         cw2c(i,j,k)=cw2b(i,2*j,k)
      enddo
      enddo
      enddo
      call inversion5_v1(a,cw2,sp)
      call inversion5_v1(a2,cw2c,sp)

      cw2b(:,:,:)=0.
      do k=sp%yst(3), sp%yen(3)
      do j=1,ny-1,2
      do i=sp%yst(1), sp%yen(1)
         cw2b(i,j,k)=cw2(i,(j+1)/2,k)
      enddo
      enddo
      do j=2,ny,2
      do i=sp%yst(1), sp%yen(1)
         cw2b(i,j,k)=cw2c(i,j/2,k)
      enddo
      enddo
      enddo
   else
      cw2(:,:,:)=0.
      do k = sp%yst(3), sp%yen(3)
      do j = sp%yst(2), sp%yen(2)
      do i = sp%yst(1), sp%yen(1)
         cw2(i,j,k)=cw2b(i,j,k)
      enddo
      enddo
      enddo

      call inversion5_v2(a3,cw2,sp)

      do k = sp%yst(3), sp%yen(3)
      do j = sp%yst(2), sp%yen(2)
      do i = sp%yst(1), sp%yen(1)
         cw2b(i,j,k)=cw2(i,j,k)
      enddo
      enddo
      enddo
   endif
</code></pre>

<p>!we have to go back in X pencils</p>

<pre><code>   call transpose_y_to_x(cw2b,cw1b,sp)
endif
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         if (abs(cw1b(i,j,k)) &gt; 1.0e-6) then
            write(*,*) 'AFTER',i,j,k,cw1b(i,j,k)
         end if
      end do
   end do
end do
</code></pre>

<h1>endif</h1>

<p>!stop</p>

<pre><code>! post-processing backward

do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      cw1(1,j,k)=cw1b(1,j,k)
      do i = 2,nx
         tmp1 = real(cw1b(i,j,k), kind=mytype)
         tmp2 = aimag(cw1b(i,j,k))
         tmp3 = real(cw1b(nx-i+2,j,k), kind=mytype)
         tmp4 = aimag(cw1b(nx-i+2,j,k))
         xx1=tmp1*bx(i)
         xx2=tmp1*ax(i)
         xx3=tmp2*bx(i)
         xx4=tmp2*ax(i)
         xx5=tmp3*bx(i)
         xx6=tmp3*ax(i)
         xx7=tmp4*bx(i)
         xx8=tmp4*ax(i)
         cw1(i,j,k) = cmplx(xx1-xx4+xx6+xx7,-(-xx2-xx3+xx5-xx8), &amp;
              kind=mytype)        
      end do
   end do
end do
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         if (abs(cw1(i,j,k)) &gt; 1.0e-4) then
            write(*,100) 'AFTER X',i,j,k,cw1(i,j,k)
         end if
      end do
   end do
end do
</code></pre>

<h1>endif</h1>

<pre><code>! POST PROCESSING IN Y
! NEED to be in Y-pencil
call transpose_x_to_y(cw1,cw2,sp)
do k = sp%yst(3), sp%yen(3)
   do i = sp%yst(1), sp%yen(1)
      cw2b(i,1,k)=cw2(i,1,k)
      do j = 2,ny
         tmp1 = real(cw2(i,j,k), kind=mytype)
         tmp2 = aimag(cw2(i,j,k))
         tmp3 = real(cw2(i,ny-j+2,k), kind=mytype)
         tmp4 = aimag(cw2(i,ny-j+2,k))
         xx1=tmp1*by(j)
         xx2=tmp1*ay(j)
         xx3=tmp2*by(j)
         xx4=tmp2*ay(j)
         xx5=tmp3*by(j)
         xx6=tmp3*ay(j)
         xx7=tmp4*by(j)
         xx8=tmp4*ay(j)
         cw2b(i,j,k) = cmplx(xx1-xx4+xx6+xx7,-(-xx2-xx3+xx5-xx8), &amp;
              kind=mytype)        
      end do
   end do
end do
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>do k = sp%yst(3), sp%yen(3)
   do j = sp%yst(2), sp%yen(2)
      do i = sp%yst(1), sp%yen(1)
         if (abs(cw2b(i,j,k)) &gt; 1.0e-4) then
            write(*,100) 'AFTER Y',i,j,k,cw2b(i,j,k)
         end if
      end do
   end do
end do
</code></pre>

<h1>endif</h1>

<pre><code>! back to X-pencil
call transpose_y_to_x(cw2b,cw1,sp)

! POST PROCESSING IN Z
do k = sp%xst(3),sp%xen(3)
   do j = sp%xst(2),sp%xen(2)
      do i = sp%xst(1),sp%xen(1)
         tmp1 = real(cw1(i,j,k), kind=mytype)
         tmp2 = aimag(cw1(i,j,k))
         cw1(i,j,k) = cmplx(tmp1*bz(k)-tmp2*az(k), &amp;
              tmp2*bz(k)+tmp1*az(k), kind=mytype)
</code></pre>

<h1>ifdef DEBUG</h1>

<pre><code>         if (abs(cw1(i,j,k)) &gt; 1.0e-4) &amp;
              write(*,100) 'END',i,j,k,cw1(i,j,k)
</code></pre>

<h1>endif</h1>

<pre><code>      end do
   end do
end do

! compute c2r transform, back to physical space
call decomp_2d_fft_3d(cw1,rhs)

if (nclz1==1) then
   do j=1,ph%zsz(2)
      do i=1,ph%zsz(1)
         do k=1,nz/2
            rw3(i,j,2*k-1)=rhs(i,j,k)
         end do
         do k=1,nz/2
            rw3(i,j,2*k)=rhs(i,j,nz-k+1)
         end do
      end do
   end do
   call transpose_z_to_y(rw3,rw2,ph)
else if (nclz1==0) then
   call transpose_z_to_y(rhs,rw2,ph)   
end if

do k=ph%yst(3),ph%yen(3)
   do i=ph%yst(1),ph%yen(1)
      do j=1,ny/2
         rw2b(i,2*j-1,k)=rw2(i,j,k)
      end do
      do j=1,ny/2
         rw2b(i,2*j,k)=rw2(i,ny-j+1,k)
      end do
   enddo
end do
call transpose_y_to_x(rw2b,rw1,ph)
do k=ph%xst(3),ph%xen(3)
   do j=ph%xst(2),ph%xen(2)
      do i=1,nx/2
         rw1b(2*i-1,j,k)=rw1(i,j,k)
      enddo
      do i=1,nx/2
         rw1b(2*i,j,k)=rw1(nx-i+1,j,k)
      enddo
   enddo
end do
call transpose_x_to_y(rw1b,rw2,ph)
call transpose_y_to_z(rw2,rhs,ph)
</code></pre>

<p>  !  call decomp_2d_fft_finalize</p>

<pre><code>return
</code></pre>

<p>  end subroutine poisson_11x</p>

<p>  subroutine abxyz(ax,ay,az,bx,by,bz,nx,ny,nz,bcx,bcy,bcz)</p>

<pre><code>use param

implicit none

integer, intent(IN) :: nx,ny,nz
integer, intent(IN) :: bcx,bcy,bcz
real(mytype), dimension(:), intent(OUT) :: ax,bx
real(mytype), dimension(:), intent(OUT) :: ay,by
real(mytype), dimension(:), intent(OUT) :: az,bz

integer :: i,j,k

if (bcx==0) then
   do i=1,nx
       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       !!!!!!!!!!!!!! generate the x direction coeficiency!!!!!!!!!!!
       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      ax(i) = sin(real(i-1, kind=mytype)*PI/real(nx, kind=mytype))
      bx(i) = cos(real(i-1, kind=mytype)*PI/real(nx, kind=mytype))
   end do
else if (bcx==1) then
   do i=1,nx
       !!!!!!!!!!!!!!!!!!!!!!!!!one and a half of PI
      ax(i) = sin(real(i-1, kind=mytype)*PI/2.0_mytype/ &amp;
           real(nx, kind=mytype))
      bx(i) = cos(real(i-1, kind=mytype)*PI/2.0_mytype/ &amp;
           real(nx, kind=mytype))
   end do
end if

if (bcy==0) then
   do j=1,ny
      ay(j) = sin(real(j-1, kind=mytype)*PI/real(ny, kind=mytype))
      by(j) = cos(real(j-1, kind=mytype)*PI/real(ny, kind=mytype))
   end do
else if (bcy==1) then
   do j=1,ny
      ay(j) = sin(real(j-1, kind=mytype)*PI/2.0_mytype/ &amp;
           real(ny, kind=mytype))
      by(j) = cos(real(j-1, kind=mytype)*PI/2.0_mytype/ &amp;
           real(ny, kind=mytype))
   end do
end if

if (bcz==0) then
   do k=1,nz
      az(k) = sin(real(k-1, kind=mytype)*PI/real(nz, kind=mytype))
      bz(k) = cos(real(k-1, kind=mytype)*PI/real(nz, kind=mytype))
   end do
else if (bcz==1) then
   do k=1,nz
      az(k) = sin(real(k-1, kind=mytype)*PI/2.0_mytype/ &amp;
           real(nz, kind=mytype))
      bz(k) = cos(real(k-1, kind=mytype)*PI/2.0_mytype/ &amp;
           real(nz, kind=mytype))
   end do
end if

return
</code></pre>

<p>  end subroutine abxyz</p>

<p>! <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>
!
subroutine waves ()
!
!</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>

<p>USE derivX
USE derivY
USE derivZ
USE param
USE decomp_2d
USE variables
use decomp_2d_fft</p>

<p>implicit none</p>

<p>integer :: i,j,k
real(mytype) :: w,wp,w1,w1p
complex(mytype) :: xyzk
complex(mytype) :: ytt,xtt,ztt,yt1,xt1,yt2,xt2
complex(mytype) :: xtt1,ytt1,ztt1,zt1,zt2,tmp1,tmp2,tmp3
complex(mytype) :: tmp4,tmp5,tmp6</p>

<p>xkx(:)=0. ; xk2(:)=0. ; yky(:)=0. ; yk2(:)=0.
zkz(:)=0. ; zk2(:)=0.</p>

<p>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!WAVE NUMBER IN X
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
if (nclx==0) then
   do i=1,nx/2+1</p>

<pre><code>  w=2.*pi*(i-1)/nx
  wp=acix6*2.*dx*sin(w/2.)+(bcix6*2.*dx)*sin(3./2.*w)
  wp=wp/(1.+2.*alcaix6*cos(w))
  xkx(i)=cmplx(nx*wp/xlx,nx*wp/xlx, kind=mytype)
  exs(i)=cmplx(nx*w/xlx,nx*w/xlx, kind=mytype)
  xk2(i)=cmplx((nx*wp/xlx)**2,(nx*wp/xlx)**2, kind=mytype)
</code></pre>

<p>   enddo
   do i=nx/2+2,nx</p>

<pre><code>  xkx(i)=xkx(nx-i+2)
  exs(i)=exs(nx-i+2)
  xk2(i)=xk2(nx-i+2)
</code></pre>

<p>   enddo
else
   do i=1,nx</p>

<pre><code>  w=2.*pi*0.5*(i-1)/nxm
  wp=acix6*2.*dx*sin(w/2.)+(bcix6*2.*dx)*sin(3./2.*w)
  wp=wp/(1.+2.*alcaix6*cos(w))
  xkx(i)=cmplx(nxm*wp/xlx,nxm*wp/xlx, kind=mytype)
  exs(i)=cmplx(nxm*w/xlx,nxm*w/xlx, kind=mytype)
  xk2(i)=cmplx((nxm*wp/xlx)**2,(nxm*wp/xlx)**2, kind=mytype)
</code></pre>

<p>   enddo
   xkx(1)=0.
   exs(1)=0.
   xk2(1)=0.
endif</p>

<p>!WAVE NUMBER IN Y
if (ncly==0) then
   do j=1,ny/2+1</p>

<pre><code>  w=2.*pi*(j-1)/ny
  wp=aciy6*2.*dy*sin(w/2.)+(bciy6*2.*dy)*sin(3./2.*w)
  wp=wp/(1.+2.*alcaiy6*cos(w))
  if (istret==0) yky(j)=cmplx(ny*wp/yly,ny*wp/yly, kind=mytype)
  if (istret.ne.0) yky(j)=cmplx(ny*wp,ny*wp, kind=mytype)
  eys(j)=cmplx(ny*w/yly,ny*w/yly, kind=mytype)
  yk2(j)=cmplx((ny*wp/yly)**2,(ny*wp/yly)**2, kind=mytype)
</code></pre>

<p>   enddo
   do j=ny/2+2,ny</p>

<pre><code>  yky(j)=yky(ny-j+2)
  eys(j)=eys(ny-j+2)
  yk2(j)=yk2(ny-j+2)
</code></pre>

<p>   enddo
else
   do j=1,ny</p>

<pre><code>  w=2.*pi*0.5*(j-1)/nym
  wp=aciy6*2.*dy*sin(w/2.)+(bciy6*2.*dy)*sin(3./2.*w)
  wp=wp/(1.+2.*alcaiy6*cos(w))
  if (istret==0) yky(j)=cmplx(nym*wp/yly,nym*wp/yly, kind=mytype)
  if (istret.ne.0) yky(j)=cmplx(nym*wp,nym*wp, kind=mytype)
  eys(j)=cmplx(nym*w/yly,nym*w/yly, kind=mytype)
  yk2(j)=cmplx((nym*wp/yly)**2,(nym*wp/yly)**2, kind=mytype)
</code></pre>

<p>   enddo
   yky(1)=0.
   eys(1)=0.
   yk2(1)=0.
endif</p>

<p>!WAVE NUMBER IN Z
if (nclz==0) then
   do k=1,nz/2+1</p>

<pre><code>  w=2.*pi*(k-1)/nz
  wp=aciz6*2.*dz*sin(w/2.)+(bciz6*2.*dz)*sin(3./2.*w)
  wp=wp/(1.+2.*alcaiz6*cos(w))
  zkz(k)=cmplx(nz*wp/zlz,nz*wp/zlz, kind=mytype)
  ezs(k)=cmplx(nz*w/zlz,nz*w/zlz, kind=mytype)
  zk2(k)=cmplx((nz*wp/zlz)**2,(nz*wp/zlz)**2, kind=mytype)
</code></pre>

<p>   enddo
else
   do k=1,nz/2+1</p>

<pre><code>  w=2.*pi*0.5*(k-1)/nzm
  w1=2.*pi*0.5*(nzm-k+1)/nzm
  wp=aciz6*2.*dz*sin(w/2.)+(bciz6*2.*dz)*sin(3./2.*w)
  wp=wp/(1.+2.*alcaiz6*cos(w))
  w1p=aciz6*2.*dz*sin(w1/2.)+(bciz6*2.*dz)*sin(3./2.*w1)
  w1p=w1p/(1.+2.*alcaiz6*cos(w1))     
  zkz(k)=cmplx(nzm*wp/zlz,-nzm*w1p/zlz, kind=mytype)
  ezs(k)=cmplx(nzm*w/zlz,nzm*w1/zlz, kind=mytype)
  zk2(k)=cmplx((nzm*wp/zlz)**2,(nzm*w1p/zlz)**2, kind=mytype)
</code></pre>

<p>   enddo
endif
!
!if (nrank==0) then
!   do i=1,nx
!      print *,i,ezs(i)
!   enddo
!endif
!stop</p>

<p>if ((nclx==0).and.(nclz==0).and.((ncly==1).or.(ncly==2))) then
do k = sp%yst(3), sp%yen(3)
do j = sp%yst(2), sp%yen(2)
do i = sp%yst(1), sp%yen(1)
   xtt=cmplx((bicix6<em>2.</em>cos(real(exs(i))<em>3.</em>dx/2.)+&amp;</p>

<pre><code>    cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)),&amp;
    (bicix6*2.*cos(real(exs(i), kind=mytype)*3.*dx/2.)+&amp;
    cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)), kind=mytype)
</code></pre>

<p>   ytt=cmplx((biciy6<em>2.</em>cos(real(eys(j), kind=mytype)<em>3.</em>dy/2.)+&amp;</p>

<pre><code>    ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)),&amp;
    (biciy6*2.*cos(real(eys(j), kind=mytype)*3.*dy/2.)+&amp;
    ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)), kind=mytype)
</code></pre>

<p>   ztt=cmplx((biciz6<em>2.</em>cos(real(ezs(k), kind=mytype)<em>3.</em>dz/2.)+&amp;</p>

<pre><code>    ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)),&amp;
    (biciz6*2.*cos(real(ezs(k), kind=mytype)*3.*dz/2.)+&amp;
    ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)), kind=mytype)
</code></pre>

<p>   xtt1=cmplx((aicix6<em>2.</em>cos(real(exs(i), kind=mytype)*dx/2.)),&amp;</p>

<pre><code>    (aicix6*2.*cos(real(exs(i), kind=mytype)*dx/2.)), kind=mytype)
</code></pre>

<p>   ytt1=cmplx((aiciy6<em>2.</em>cos(real(eys(j), kind=mytype)*dy/2.)),&amp;</p>

<pre><code>    (aiciy6*2.*cos(real(eys(j), kind=mytype)*dy/2.)), kind=mytype)
</code></pre>

<p>   ztt1=cmplx((aiciz6<em>2.</em>cos(real(ezs(k), kind=mytype)*dz/2.)),&amp;</p>

<pre><code>    (aiciz6*2.*cos(real(ezs(k), kind=mytype)*dz/2.)), kind=mytype)
</code></pre>

<p>   xt1=cmplx((1.+2.<em>ailcaix6</em>cos(real(exs(i), kind=mytype)*dx)),&amp;</p>

<pre><code>    (1.+2.*ailcaix6*cos(real(exs(i), kind=mytype)*dx)), kind=mytype)
</code></pre>

<p>   yt1=cmplx((1.+2.<em>ailcaiy6</em>cos(real(eys(j), kind=mytype)*dy)),&amp;</p>

<pre><code>    (1.+2.*ailcaiy6*cos(real(eys(j), kind=mytype)*dy)), kind=mytype)
</code></pre>

<p>   zt1=cmplx((1.+2.<em>ailcaiz6</em>cos(real(ezs(k), kind=mytype)*dz)),&amp;</p>

<pre><code>    (1.+2.*ailcaiz6*cos(real(ezs(k), kind=mytype)*dz)), kind=mytype)
</code></pre>

<p>   xt2=xk2(i)<em>((((ytt1+ytt)/yt1)</em>((ztt1+ztt)/zt1))<strong>2)
   yt2=yk2(j)<em>((((xtt1+xtt)/xt1)</em>((ztt1+ztt)/zt1))</strong>2)
   zt2=zk2(k)<em>((((xtt1+xtt)/xt1)</em>((ytt1+ytt)/yt1))<em>*2)
   xyzk=xt2+yt2+zt2
   kxyz(i,j,k)=xyzk
!   print </em>,i,j,k, kxyz(i,j,k)
enddo
enddo
enddo
else
   if (nclz==0) then</p>

<pre><code>  do k = sp%xst(3),sp%xen(3)
  do j = sp%xst(2),sp%xen(2)
  do i = sp%xst(1),sp%xen(1)
     xtt=cmplx((bicix6*2.*cos(real(exs(i), kind=mytype)*3.*dx/2.)+&amp;
          cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)),&amp;
          (bicix6*2.*cos(real(exs(i), kind=mytype)*3.*dx/2.)+&amp;
          cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)), kind=mytype)
     ytt=cmplx((biciy6*2.*cos(real(eys(j), kind=mytype)*3.*dy/2.)+&amp;
          ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)),&amp;
          (biciy6*2.*cos(real(eys(j), kind=mytype)*3.*dy/2.)+&amp;
          ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)), kind=mytype)
     ztt=cmplx((biciz6*2.*cos(real(ezs(k), kind=mytype)*3.*dz/2.)+&amp;
          ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)),&amp;
          (biciz6*2.*cos(real(ezs(k), kind=mytype)*3.*dz/2.)+&amp;
          ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)), kind=mytype)
     xtt1=cmplx((aicix6*2.*cos(real(exs(i), kind=mytype)*dx/2.)),&amp;
          (aicix6*2.*cos(real(exs(i), kind=mytype)*dx/2.)), kind=mytype)
     ytt1=cmplx((aiciy6*2.*cos(real(eys(j), kind=mytype)*dy/2.)),&amp;
          (aiciy6*2.*cos(real(eys(j), kind=mytype)*dy/2.)), kind=mytype)
     ztt1=cmplx((aiciz6*2.*cos(real(ezs(k), kind=mytype)*dz/2.)),&amp;
          (aiciz6*2.*cos(real(ezs(k), kind=mytype)*dz/2.)), kind=mytype)
     xt1=cmplx((1.+2.*ailcaix6*cos(real(exs(i), kind=mytype)*dx)),&amp;
          (1.+2.*ailcaix6*cos(real(exs(i))*dx)), kind=mytype)
     yt1=cmplx((1.+2.*ailcaiy6*cos(real(eys(j), kind=mytype)*dy)),&amp;
          (1.+2.*ailcaiy6*cos(real(eys(j), kind=mytype)*dy)), kind=mytype)
     zt1=cmplx((1.+2.*ailcaiz6*cos(real(ezs(k), kind=mytype)*dz)),&amp;
          (1.+2.*ailcaiz6*cos(real(ezs(k), kind=mytype)*dz)), kind=mytype)
     xt2=xk2(i)*((((ytt1+ytt)/yt1)*((ztt1+ztt)/zt1))**2)
     yt2=yk2(j)*((((xtt1+xtt)/xt1)*((ztt1+ztt)/zt1))**2)
     zt2=zk2(k)*((((xtt1+xtt)/xt1)*((ytt1+ytt)/yt1))**2)
     xyzk=xt2+yt2+zt2
     kxyz(i,j,k)=xyzk
</code></pre>

<p>!   print *,i,j,k, kxyz(i,j,k)</p>

<pre><code>  enddo
  enddo
  enddo
</code></pre>

<p>   else</p>

<pre><code>  do k = sp%xst(3),sp%xen(3)
  do j = sp%xst(2),sp%xen(2)
  do i = sp%xst(1),sp%xen(1)  
     xtt=cmplx((bicix6*2.*cos(real(exs(i), kind=mytype)*3.*dx/2.)+&amp;
          cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)),&amp;
          (bicix6*2.*cos(real(exs(i), kind=mytype)*3.*dx/2.)+&amp;
          cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)), kind=mytype)
     ytt=cmplx((biciy6*2.*cos(real(eys(j), kind=mytype)*3.*dy/2.)+&amp;
          ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)),&amp;
          (biciy6*2.*cos(real(eys(j), kind=mytype)*3.*dy/2.)+&amp;
          ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)), kind=mytype)
     !
     ztt=cmplx((biciz6*2.*cos(real(ezs(k), kind=mytype)*3.*dz/2.)+&amp;
          ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)),&amp;
          (biciz6*2.*cos(aimag(ezs(k))*3.*dz/2.)+&amp;
          ciciz6*2.*cos(aimag(ezs(k))*5.*dz/2.)), kind=mytype)
     !
     xtt1=cmplx((aicix6*2.*cos(real(exs(i), kind=mytype)*dx/2.)),&amp;
          (aicix6*2.*cos(real(exs(i), kind=mytype)*dx/2.)), kind=mytype)
     ytt1=cmplx((aiciy6*2.*cos(real(eys(j), kind=mytype)*dy/2.)),&amp;
          (aiciy6*2.*cos(real(eys(j), kind=mytype)*dy/2.)), kind=mytype)
     !
     ztt1=cmplx((aiciz6*2.*cos(real(ezs(k), kind=mytype)*dz/2.)),&amp;
          (aiciz6*2.*cos(aimag(ezs(k))*dz/2.)), kind=mytype)
     !
     xt1=cmplx((1.+2.*ailcaix6*cos(real(exs(i), kind=mytype)*dx)),&amp;
          (1.+2.*ailcaix6*cos(real(exs(i), kind=mytype)*dx)), kind=mytype)
     yt1=cmplx((1.+2.*ailcaiy6*cos(real(eys(j), kind=mytype)*dy)),&amp;
          (1.+2.*ailcaiy6*cos(real(eys(j), kind=mytype)*dy)), kind=mytype)
     zt1=cmplx((1.+2.*ailcaiz6*cos(real(ezs(k), kind=mytype)*dz)),&amp;
          (1.+2.*ailcaiz6*cos(aimag(ezs(k))*dz)), kind=mytype)

     tmp1=cmplx(real(ztt1+ztt, kind=mytype)/real(zt1, kind=mytype),&amp;
          aimag(ztt1+ztt)/aimag(zt1), kind=mytype)
     tmp2=cmplx(real(ytt1+ytt, kind=mytype)/real(yt1, kind=mytype),&amp;
          real(ytt1+ytt, kind=mytype)/real(yt1, kind=mytype), kind=mytype)
     tmp3=cmplx(real(xtt1+xtt, kind=mytype)/real(xt1, kind=mytype),&amp;
          real(xtt1+xtt, kind=mytype)/real(xt1, kind=mytype), kind=mytype)

     tmp4=cmplx((real(tmp1, kind=mytype)*real(tmp2, kind=mytype))**2,(aimag(tmp1)*aimag(tmp2))**2, kind=mytype)
     tmp5=cmplx((real(tmp1, kind=mytype)*real(tmp3, kind=mytype))**2,(aimag(tmp1)*aimag(tmp3))**2, kind=mytype)
     tmp6=cmplx((real(tmp3, kind=mytype)*real(tmp2, kind=mytype))**2,(aimag(tmp3)*aimag(tmp2))**2, kind=mytype)

     tmp1=cmplx(real(tmp4, kind=mytype)*real(xk2(i), kind=mytype),aimag(tmp4)*aimag(xk2(i)), kind=mytype)
     tmp2=cmplx(real(tmp5, kind=mytype)*real(yk2(j), kind=mytype),aimag(tmp5)*aimag(yk2(j)), kind=mytype)
     tmp3=cmplx(real(tmp6, kind=mytype)*real(zk2(k), kind=mytype),aimag(tmp6)*aimag(zk2(k)), kind=mytype)

     xyzk=tmp1+tmp2+tmp3
     kxyz(i,j,k)=xyzk
</code></pre>

<p>!         print *,i,j,k,zt1,yt1</p>

<pre><code>  enddo
  enddo
  enddo
</code></pre>

<p>   endif
endif</p>

<p>!          do k=1,1!nz
!          do j=1,ny
!          do i=1,1!!nx
!             print *,j,a(i,j,k,3),kxyz(i,j,k)
!          enddo
!          enddo
!          enddo</p>

<p>end subroutine waves</p>

<p>!<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>
!
subroutine matrice_refinement()
!
!</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>

<p>USE decomp_2d
USE variables
USE param
USE var
USE MPI
USE derivX
USE derivY
USE derivZ</p>

<p>implicit none</p>

<p>integer :: i,j,k</p>

<p>complex(mytype),dimension(sp%yst(1):sp%yen(1)) :: transx
complex(mytype),dimension(sp%yst(2):sp%yen(2)) :: transy
complex(mytype),dimension(sp%yst(3):sp%yen(3)) :: transz
real(mytype) :: xa0,xa1
complex(mytype) :: ytt,xtt,ztt,yt1,xt1,yt2,xt2
complex(mytype) :: xtt1,ytt1,ztt1,zt1,zt2,tmp1,tmp2,tmp3</p>

<p>do i = sp%yst(1),sp%yen(1)
   xtt=cmplx((bicix6<em>2.</em>cos(real(exs(i), kind=mytype)<em>3.</em>dx/2.)+&amp;</p>

<pre><code>    cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)),&amp;
    (bicix6*2.*cos(real(exs(i), kind=mytype)*3.*dx/2.)+&amp;
    cicix6*2.*cos(real(exs(i), kind=mytype)*5.*dx/2.)), kind=mytype)
</code></pre>

<p>   xtt1=cmplx((aicix6<em>2.</em>cos(real(exs(i), kind=mytype)*dx/2.)),&amp;</p>

<pre><code>    (aicix6*2.*cos(real(exs(i), kind=mytype)*dx/2.)), kind=mytype)
</code></pre>

<p>   xt1=cmplx((1.+2.<em>ailcaix6</em>cos(real(exs(i), kind=mytype)*dx)),&amp;</p>

<pre><code>    (1.+2.*ailcaix6*cos(real(exs(i), kind=mytype)*dx)), kind=mytype)
</code></pre>

<p>   transx(i)=cmplx(real(xtt1+xtt, kind=mytype)/real(xt1, kind=mytype),&amp;</p>

<pre><code>    real(xtt1+xtt, kind=mytype)/real(xt1, kind=mytype), kind=mytype)!(xtt+xtt)/xt1
</code></pre>

<p>enddo
do j = sp%yst(2),sp%yen(2)
   ytt=cmplx((biciy6<em>2.</em>cos(real(eys(j), kind=mytype)<em>3.</em>dy/2.)+&amp;</p>

<pre><code>    ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)),&amp;
    (biciy6*2.*cos(real(eys(j), kind=mytype)*3.*dy/2.)+&amp;
    ciciy6*2.*cos(real(eys(j), kind=mytype)*5.*dy/2.)), kind=mytype)
</code></pre>

<p>   ytt1=cmplx((aiciy6<em>2.</em>cos(real(eys(j), kind=mytype)*dy/2.)),&amp;</p>

<pre><code>    (aiciy6*2.*cos(real(eys(j), kind=mytype)*dy/2.)), kind=mytype)
</code></pre>

<p>   yt1=cmplx((1.+2.<em>ailcaiy6</em>cos(real(eys(j), kind=mytype)*dy)),&amp;</p>

<pre><code>    (1.+2.*ailcaiy6*cos(real(eys(j), kind=mytype)*dy)), kind=mytype)
</code></pre>

<p>   transy(j)=cmplx(real(ytt1+ytt, kind=mytype)/real(yt1, kind=mytype),&amp;</p>

<pre><code>    real(ytt1+ytt, kind=mytype)/real(yt1, kind=mytype), kind=mytype)!(ytt+ytt)/yt1
</code></pre>

<p>enddo
if (nclz==0) then
   do k = sp%yst(3),sp%yen(3)</p>

<pre><code>  ztt=cmplx((biciz6*2.*cos(real(ezs(k), kind=mytype)*3.*dz/2.)+&amp;
       ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)),&amp;
       (biciz6*2.*cos(real(ezs(k), kind=mytype)*3.*dz/2.)+&amp;
       ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)), kind=mytype)
  ztt1=cmplx((aiciz6*2.*cos(real(ezs(k), kind=mytype)*dz/2.)),&amp;
       (aiciz6*2.*cos(real(ezs(k), kind=mytype)*dz/2.)), kind=mytype)
  zt1=cmplx((1.+2.*ailcaiz6*cos(real(ezs(k), kind=mytype)*dz)),&amp;
       (1.+2.*ailcaiz6*cos(real(ezs(k), kind=mytype)*dz)), kind=mytype)
  transz(k)=cmplx(real(ztt1+ztt, kind=mytype)/real(zt1, kind=mytype),&amp;
       aimag(ztt1+ztt)/aimag(zt1), kind=mytype)!(ztt+ztt)/zt1
</code></pre>

<p>   enddo
else
   do k = sp%yst(3),sp%yen(3)</p>

<pre><code>  ztt=cmplx((biciz6*2.*cos(real(ezs(k), kind=mytype)*3.*dz/2.)+&amp;
       ciciz6*2.*cos(real(ezs(k), kind=mytype)*5.*dz/2.)),&amp;
       (biciz6*2.*cos(aimag(ezs(k))*3.*dz/2.)+&amp;
       ciciz6*2.*cos(aimag(ezs(k))*5.*dz/2.)), kind=mytype)
  ztt1=cmplx((aiciz6*2.*cos(real(ezs(k), kind=mytype)*dz/2.)),&amp;
       (aiciz6*2.*cos(aimag(ezs(k))*dz/2.)), kind=mytype)
  zt1=cmplx((1.+2.*ailcaiz6*cos(real(ezs(k), kind=mytype)*dz)),&amp;
       (1.+2.*ailcaiz6*cos(aimag(ezs(k))*dz)), kind=mytype)
  transz(k)=cmplx(real(ztt1+ztt, kind=mytype)/real(zt1, kind=mytype),&amp;
       aimag(ztt1+ztt)/aimag(zt1), kind=mytype)!(ztt+ztt)/zt1
</code></pre>

<p>   enddo
endif</p>

<p>if ((istret==1).or.(istret==2)) then</p>

<p>   xa0=alpha/pi+1./2./beta/pi
   if (istret==1) xa1=1./4./beta/pi
   if (istret==2) xa1=-1./4./beta/pi
!
!construction of the pentadiagonal matrice
!
   do k=sp%yst(3),sp%yen(3)
   do j=1,ny/2
   do i=sp%yst(1),sp%yen(1)</p>

<pre><code>  cw22(i,j,k)=cmplx(real(yky(2*j-1), kind=mytype)*real(transx(i), kind=mytype)*real(transz(k), kind=mytype),&amp;
       aimag(yky(2*j-1))*aimag(transx(i))*aimag(transz(k)), kind=mytype)
  cw2(i,j,k)=cmplx(real(yky(2*j), kind=mytype)*real(transx(i), kind=mytype)*real(transz(k), kind=mytype),&amp;
       aimag(yky(2*j))*aimag(transx(i))*aimag(transz(k)), kind=mytype)
</code></pre>

<p>   enddo
   enddo
   enddo</p>

<p>!main diagonal
   do k=sp%yst(3),sp%yen(3)
   do j=2,ny/2-1
   do i=sp%yst(1),sp%yen(1)</p>

<pre><code>  a(i,j,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(2*j-1), kind=mytype)*real(transy(2*j-1), kind=mytype)&amp;
       *real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;
       -(real(zk2(k), kind=mytype)*real(transy(2*j-1), kind=mytype)*real(transy(2*j-1), kind=mytype)*&amp;
       real(transx(i), kind=mytype)*real(transx(i), kind=mytype))&amp;
       -real(cw22(i,j,k), kind=mytype)*real(cw22(i,j,k), kind=mytype)*xa0*xa0-&amp;
       xa1*xa1*(real(cw22(i,j,k), kind=mytype)*real(cw22(i,j-1,k), kind=mytype)+real(cw22(i,j,k), kind=mytype)*&amp;
       real(cw22(i,j+1,k), kind=mytype)),&amp;
       -(aimag(xk2(i))*aimag(transy(2*j-1))*aimag(transy(2*j-1))*aimag(transz(k))*aimag(transz(k)))&amp;
       -(aimag(zk2(k))*aimag(transy(2*j-1))*aimag(transy(2*j-1))*aimag(transx(i))*aimag(transx(i)))&amp;
       -aimag(cw22(i,j,k))*aimag(cw22(i,j,k))*xa0*xa0-&amp;
       xa1*xa1*(aimag(cw22(i,j,k))*aimag(cw22(i,j-1,k))+aimag(cw22(i,j,k))*aimag(cw22(i,j+1,k))), kind=mytype)
  a2(i,j,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(2*j), kind=mytype)*real(transy(2*j), kind=mytype)*&amp;
       real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;
       -(real(zk2(k), kind=mytype)*real(transy(2*j), kind=mytype)*real(transy(2*j), kind=mytype)*&amp;
       real(transx(i), kind=mytype)*real(transx(i), kind=mytype))&amp;
       -real(cw2(i,j,k), kind=mytype)*real(cw2(i,j,k), kind=mytype)*xa0*xa0-&amp;
       xa1*xa1*(real(cw2(i,j,k), kind=mytype)*real(cw2(i,j-1,k), kind=mytype)+real(cw2(i,j,k), kind=mytype)*&amp;
       real(cw2(i,j+1,k), kind=mytype)),&amp;
       -(aimag(xk2(i))*aimag(transy(2*j))*aimag(transy(2*j))*aimag(transz(k))*aimag(transz(k)))&amp;
       -(aimag(zk2(k))*aimag(transy(2*j))*aimag(transy(2*j))*aimag(transx(i))*aimag(transx(i)))&amp;
       -aimag(cw2(i,j,k))*aimag(cw2(i,j,k))*xa0*xa0-&amp;
       xa1*xa1*(aimag(cw2(i,j,k))*aimag(cw2(i,j-1,k))+aimag(cw2(i,j,k))*aimag(cw2(i,j+1,k))), kind=mytype)
</code></pre>

<p>   enddo
   enddo
   do i=sp%yst(1),sp%yen(1)</p>

<pre><code>  a(i,1,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(1), kind=mytype)*real(transy(1), kind=mytype)*&amp;
       real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;
       -(real(zk2(k), kind=mytype)*real(transy(1), kind=mytype)*real(transy(1), kind=mytype)*&amp;
       real(transx(i), kind=mytype)*real(transx(i), kind=mytype))&amp;
       -real(cw22(i,1,k), kind=mytype)*real(cw22(i,1,k), kind=mytype)*xa0*xa0-xa1*xa1*(real(cw22(i,1,k), kind=mytype)*&amp;
       real(cw22(i,2,k), kind=mytype)),&amp;
       -(aimag(xk2(i))*aimag(transy(1))*aimag(transy(1))*aimag(transz(k))*aimag(transz(k)))&amp;
       -(aimag(zk2(k))*aimag(transy(1))*aimag(transy(1))*aimag(transx(i))*aimag(transx(i)))&amp;
       -aimag(cw22(i,1,k))*aimag(cw22(i,1,k))*xa0*xa0-xa1*xa1*(aimag(cw22(i,1,k))*aimag(cw22(i,2,k))), kind=mytype)
  a(i,ny/2,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(ny-2), kind=mytype)*real(transy(ny-2), kind=mytype)&amp;
       *real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;
       -(real(zk2(k), kind=mytype)*real(transy(ny-2), kind=mytype)*real(transy(ny-2), kind=mytype)*&amp;
       real(transx(i), kind=mytype)*real(transx(i), kind=mytype))&amp;
       -real(cw22(i,ny/2,k), kind=mytype)*real(cw22(i,ny/2,k), kind=mytype)*xa0*xa0-&amp;
       xa1*xa1*(real(cw22(i,ny/2,k), kind=mytype)*real(cw22(i,ny/2-1,k), kind=mytype)),&amp;
       -(aimag(xk2(i))*aimag(transy(ny-2))*aimag(transy(ny-2))*aimag(transz(k))*aimag(transz(k)))&amp;
       -(aimag(zk2(k))*aimag(transy(ny-2))*aimag(transy(ny-2))*aimag(transx(i))*aimag(transx(i)))&amp;
       -aimag(cw22(i,ny/2,k))*aimag(cw22(i,ny/2,k))*xa0*xa0-&amp;
       xa1*xa1*(aimag(cw22(i,ny/2,k))*aimag(cw22(i,ny/2-1,k))), kind=mytype)
  a2(i,1,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(2), kind=mytype)*real(transy(2), kind=mytype)*&amp;
       real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;
       -(real(zk2(k), kind=mytype)*real(transy(2), kind=mytype)*real(transy(2), kind=mytype)*&amp;
       real(transx(i), kind=mytype)*real(transx(i), kind=mytype))&amp;
       -real(cw2(i,1,k), kind=mytype)*real(cw2(i,1,k), kind=mytype)*(xa0-xa1)*(xa0+xa1)-xa1*xa1*(real(cw2(i,1,k), kind=mytype)*&amp;
       real(cw2(i,2,k), kind=mytype)),&amp;
       -(aimag(xk2(i))*aimag(transy(2))*aimag(transy(2))*aimag(transz(k))*aimag(transz(k)))&amp;
       -(aimag(zk2(k))*aimag(transy(2))*aimag(transy(2))*aimag(transx(i))*aimag(transx(i)))&amp;
       -aimag(cw2(i,1,k))*aimag(cw2(i,1,k))*(xa0-xa1)*(xa0+xa1)-xa1*xa1*(aimag(cw2(i,1,k))*aimag(cw2(i,2,k))), kind=mytype)
  a2(i,ny/2,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(ny-1), kind=mytype)*real(transy(ny-1), kind=mytype)*&amp;
       real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;
       -(real(zk2(k), kind=mytype)*real(transy(ny-1), kind=mytype)*real(transy(ny-1), kind=mytype)*&amp;
       real(transx(i), kind=mytype)*real(transx(i), kind=mytype))&amp;
       -real(cw2(i,ny/2,k), kind=mytype)*real(cw2(i,ny/2,k), kind=mytype)*(xa0+xa1)*(xa0+xa1)-&amp;
       xa1*xa1*(real(cw2(i,ny/2,k), kind=mytype)*real(cw2(i,ny/2-1,k), kind=mytype)),&amp;
       -(aimag(xk2(i))*aimag(transy(ny-1))*aimag(transy(ny-1))*aimag(transz(k))*aimag(transz(k)))&amp;
       -(aimag(zk2(k))*aimag(transy(ny-1))*aimag(transy(ny-1))*aimag(transx(i))*aimag(transx(i)))&amp;
       -aimag(cw2(i,ny/2,k))*aimag(cw2(i,ny/2,k))*(xa0+xa1)*(xa0+xa1)-&amp;
       xa1*xa1*(aimag(cw2(i,ny/2,k))*aimag(cw2(i,ny/2-1,k))), kind=mytype)
</code></pre>

<p>   enddo
   enddo</p>

<p>!sup diag +1
   do k=sp%yst(3),sp%yen(3)
   do j=2,ny/2-1
   do i=sp%yst(1),sp%yen(1)</p>

<pre><code>  a(i,j,k,4)=cmplx(xa0*xa1*(real(cw22(i,j,k), kind=mytype)*real(cw22(i,j+1,k), kind=mytype)+real(cw22(i,j+1,k), kind=mytype)*&amp;
       real(cw22(i,j+1,k), kind=mytype)),&amp;
       xa0*xa1*(aimag(cw22(i,j,k))*aimag(cw22(i,j+1,k))+aimag(cw22(i,j+1,k))*aimag(cw22(i,j+1,k))), kind=mytype)
  a2(i,j,k,4)=cmplx(xa0*xa1*(real(cw2(i,j,k), kind=mytype)*real(cw2(i,j+1,k), kind=mytype)+real(cw2(i,j+1,k), kind=mytype)*&amp;
       real(cw2(i,j+1,k), kind=mytype)),&amp;
       xa0*xa1*(aimag(cw2(i,j,k))*aimag(cw2(i,j+1,k))+aimag(cw2(i,j+1,k))*aimag(cw2(i,j+1,k))), kind=mytype)
</code></pre>

<p>   enddo
   enddo
   do i=sp%yst(1),sp%yen(1)</p>

<pre><code>  a(i,1,k,4)=2.*cmplx((xa0*xa1*(real(cw22(i,1,k), kind=mytype)*real(cw22(i,2,k), kind=mytype)+real(cw22(i,2,k), kind=mytype)*&amp;
       real(cw22(i,2,k), kind=mytype))),&amp;
       (xa0*xa1*(aimag(cw22(i,1,k))*aimag(cw22(i,2,k))+aimag(cw22(i,2,k))*aimag(cw22(i,2,k)))), kind=mytype)
  a2(i,1,k,4)=cmplx((xa0-xa1)*xa1*(real(cw2(i,1,k), kind=mytype)*real(cw2(i,2,k), kind=mytype))&amp;
       +xa0*xa1*(real(cw2(i,2,k), kind=mytype)*real(cw2(i,2,k), kind=mytype)),&amp;
       (xa0-xa1)*xa1*(aimag(cw2(i,1,k))*aimag(cw2(i,2,k)))&amp;
       +xa0*xa1*(aimag(cw2(i,2,k))*aimag(cw2(i,2,k))), kind=mytype)
  a2(i,ny/2-1,k,4)=cmplx(xa0*xa1*(real(cw2(i,ny/2-1,k), kind=mytype)*real(cw2(i,ny/2,k), kind=mytype))&amp;
       +(xa0+xa1)*xa1*(real(cw2(i,ny/2,k), kind=mytype)*real(cw2(i,ny/2,k), kind=mytype)),&amp;
       xa0*xa1*(aimag(cw2(i,ny/2-1,k))*aimag(cw2(i,ny/2,k)))&amp;
       +(xa0+xa1)*xa1*(aimag(cw2(i,ny/2,k))*aimag(cw2(i,ny/2,k))), kind=mytype)
  a2(i,ny/2,k,4)=0.
</code></pre>

<p>   enddo
   enddo</p>

<p>!sup diag +2
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1) <br/>
   do j=1,ny/2-2</p>

<pre><code>  a(i,j,k,5)=cmplx(-real(cw22(i,j+1,k), kind=mytype)*real(cw22(i,j+2,k), kind=mytype)*xa1*xa1,&amp;
       -aimag(cw22(i,j+1,k))*aimag(cw22(i,j+2,k))*xa1*xa1, kind=mytype)
  a2(i,j,k,5)=cmplx(-real(cw2(i,j+1,k), kind=mytype)*real(cw2(i,j+2,k), kind=mytype)*xa1*xa1,&amp;
       -aimag(cw2(i,j+1,k))*aimag(cw2(i,j+2,k))*xa1*xa1, kind=mytype)
</code></pre>

<p>   enddo
   a(i,1,k,5)=cmplx(real(a(i,1,k,5), kind=mytype)<em>2.,aimag(a(i,1,k,5))</em>2., kind=mytype)
   a(i,ny/2-1,k,5)=0.
   a(i,ny/2,k,5)=0.
   a2(i,ny/2-1,k,5)=0.
   a2(i,ny/2,k,5)=0.
   enddo
   enddo</p>

<p>!inf diag -1
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1) <br/>
   do j=2,ny/2</p>

<pre><code>  a(i,j,k,2)=cmplx(xa0*xa1*(real(cw22(i,j,k), kind=mytype)*real(cw22(i,j-1,k), kind=mytype)+real(cw22(i,j-1,k), kind=mytype)*&amp;
       real(cw22(i,j-1,k), kind=mytype)),&amp;
       xa0*xa1*(aimag(cw22(i,j,k))*aimag(cw22(i,j-1,k))+aimag(cw22(i,j-1,k))*aimag(cw22(i,j-1,k))), kind=mytype)
  a2(i,j,k,2)=cmplx(xa0*xa1*(real(cw2(i,j,k), kind=mytype)*real(cw2(i,j-1,k), kind=mytype)+real(cw2(i,j-1,k), kind=mytype)*&amp;
       real(cw2(i,j-1,k), kind=mytype)),&amp;
       xa0*xa1*(aimag(cw2(i,j,k))*aimag(cw2(i,j-1,k))+aimag(cw2(i,j-1,k))*aimag(cw2(i,j-1,k))), kind=mytype)
</code></pre>

<p>   enddo
   a(i,1,k,2)=0.
   a2(i,1,k,2)=0.
   a2(i,2,k,2)=cmplx(xa0<em>xa1</em>(real(cw2(i,2,k), kind=mytype)*real(cw2(i,1,k), kind=mytype))&amp;</p>

<pre><code>    +(xa0+xa1)*xa1*(real(cw2(i,1,k), kind=mytype)*real(cw2(i,1,k), kind=mytype)),&amp;
    xa0*xa1*(aimag(cw2(i,2,k))*aimag(cw2(i,1,k)))&amp;
    +(xa0+xa1)*xa1*(aimag(cw2(i,1,k))*aimag(cw2(i,1,k))), kind=mytype)
</code></pre>

<p>   a2(i,ny/2,k,2)=cmplx((xa0+xa1)<em>xa1</em>(real(cw2(i,ny/2,k), kind=mytype)*real(cw2(i,ny/2-1,k), kind=mytype))&amp;</p>

<pre><code>    +xa0*xa1*(real(cw2(i,ny/2-1,k), kind=mytype)*real(cw2(i,ny/2-1,k), kind=mytype)),&amp;
    (xa0+xa1)*xa1*(aimag(cw2(i,ny/2,k))*aimag(cw2(i,ny/2-1,k)))&amp;
    +xa0*xa1*(aimag(cw2(i,ny/2-1,k))*aimag(cw2(i,ny/2-1,k))), kind=mytype)
</code></pre>

<p>   enddo
   enddo
!inf diag -2
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)<br/>
   do j=3,ny/2</p>

<pre><code>  a(i,j,k,1)=cmplx(-real(cw22(i,j-1,k), kind=mytype)*real(cw22(i,j-2,k), kind=mytype)*xa1*xa1,&amp;
       -aimag(cw22(i,j-1,k))*aimag(cw22(i,j-2,k))*xa1*xa1, kind=mytype)
  a2(i,j,k,1)=cmplx(-real(cw2(i,j-1,k), kind=mytype)*real(cw2(i,j-2,k), kind=mytype)*xa1*xa1,&amp;
       -aimag(cw2(i,j-1,k))*aimag(cw2(i,j-2,k))*xa1*xa1, kind=mytype)
</code></pre>

<p>   enddo
   a(i,1,k,1)=0.
   a(i,2,k,1)=0.
   a2(i,1,k,1)=0.
   a2(i,2,k,1)=0.
   enddo
   enddo
!not to have a singular matrice
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)</p>

<pre><code>  if ((real(xk2(i), kind=mytype)==0.).and.(real(zk2(k), kind=mytype)==0)) then
     a(i,1,k,3)=cmplx(1.,1., kind=mytype)
     a(i,1,k,4)=0.
     a(i,1,k,5)=0.
  endif
</code></pre>

<p>   enddo
   enddo</p>

<p>else
   xa0=alpha/pi+1./2./beta/pi
   xa1=-1./4./beta/pi
!
!construction of the pentadiagonal matrice
! <br/>
   do k=sp%yst(3),sp%yen(3)
   do j=1,nym
   do i=sp%yst(1),sp%yen(1)</p>

<pre><code>  cw22(i,j,k)=cmplx(real(yky(j), kind=mytype)*real(transx(i), kind=mytype)*real(transz(k), kind=mytype),&amp;
       aimag(yky(j))*aimag(transx(i))*aimag(transz(k)), kind=mytype)
</code></pre>

<p>   enddo
   enddo
   enddo</p>

<p>!main diagonal
   do k=sp%yst(3),sp%yen(3)
   do j=2,nym-1
   do i=sp%yst(1),sp%yen(1)</p>

<pre><code>  a3(i,j,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(j), kind=mytype)*real(transy(j), kind=mytype)*&amp;
       real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;
       -(real(zk2(k), kind=mytype)*real(transy(j), kind=mytype)*real(transy(j), kind=mytype)*&amp;
       real(transx(i), kind=mytype)*real(transx(i), kind=mytype))&amp;
       -real(cw22(i,j,k), kind=mytype)*real(cw22(i,j,k), kind=mytype)*xa0*xa0-&amp;
       xa1*xa1*(real(cw22(i,j,k), kind=mytype)*real(cw22(i,j-1,k), kind=mytype)+real(cw22(i,j,k), kind=mytype)*&amp;
       real(cw22(i,j+1,k), kind=mytype)),&amp;
       -(aimag(xk2(i))*aimag(transy(j))*aimag(transy(j))*aimag(transz(k))*aimag(transz(k)))&amp;
       -(aimag(zk2(k))*aimag(transy(j))*aimag(transy(j))*aimag(transx(i))*aimag(transx(i)))&amp;
       -aimag(cw22(i,j,k))*aimag(cw22(i,j,k))*xa0*xa0-&amp;
       xa1*xa1*(aimag(cw22(i,j,k))*aimag(cw22(i,j-1,k))+aimag(cw22(i,j,k))*aimag(cw22(i,j+1,k))), kind=mytype)
</code></pre>

<p>   enddo
   enddo
   enddo</p>

<p>   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)</p>

<pre><code>  a3(i,1,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(1), kind=mytype)*real(transy(1), kind=mytype)*&amp;
       real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;
       -(real(zk2(k), kind=mytype)*real(transy(1), kind=mytype)*real(transy(1), kind=mytype)*real(transx(i), kind=mytype)*&amp;
       real(transx(i), kind=mytype))&amp;
       -real(cw22(i,1,k), kind=mytype)*real(cw22(i,1,k), kind=mytype)*xa0*xa0-xa1*xa1*(real(cw22(i,1,k), kind=mytype)*&amp;
       real(cw22(i,2,k), kind=mytype)),&amp;
       -(aimag(xk2(i))*aimag(transy(1))*aimag(transy(1))*aimag(transz(k))*aimag(transz(k)))&amp;
       -(aimag(zk2(k))*aimag(transy(1))*aimag(transy(1))*aimag(transx(i))*aimag(transx(i)))&amp;
       -aimag(cw22(i,1,k))*aimag(cw22(i,1,k))*xa0*xa0-xa1*xa1*(aimag(cw22(i,1,k))*aimag(cw22(i,2,k))), kind=mytype)
  a3(i,nym,k,3)=cmplx(-(real(xk2(i), kind=mytype)*real(transy(nym), kind=mytype)*real(transy(nym), kind=mytype)*&amp;
       real(transz(k), kind=mytype)*real(transz(k), kind=mytype))&amp;
       -(real(zk2(k), kind=mytype)*real(transy(nym), kind=mytype)*real(transy(nym), kind=mytype)*real(transx(i), kind=mytype)*&amp;
       real(transx(i), kind=mytype))&amp;
       -real(cw22(i,nym,k), kind=mytype)*real(cw22(i,nym,k), kind=mytype)*xa0*xa0-&amp;
       xa1*xa1*(real(cw22(i,nym,k), kind=mytype)*real(cw22(i,nym-1,k), kind=mytype)),&amp;
       -(aimag(xk2(i))*aimag(transy(nym))*aimag(transy(nym))*aimag(transz(k))*aimag(transz(k)))&amp;
       -(aimag(zk2(k))*aimag(transy(nym))*aimag(transy(nym))*aimag(transx(i))*aimag(transx(i)))&amp;
       -aimag(cw22(i,nym,k))*aimag(cw22(i,nym,k))*xa0*xa0-&amp;
       xa1*xa1*(aimag(cw22(i,nym,k))*aimag(cw22(i,nym-1,k))), kind=mytype)
</code></pre>

<p>   enddo
   enddo</p>

<p>!sup diag +1
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)
   do j=2,nym-1</p>

<pre><code>  a3(i,j,k,4)=cmplx(xa0*xa1*(real(cw22(i,j,k), kind=mytype)*real(cw22(i,j+1,k), kind=mytype)+real(cw22(i,j+1,k), kind=mytype)*&amp;
       real(cw22(i,j+1,k), kind=mytype)),&amp;
       xa0*xa1*(aimag(cw22(i,j,k))*aimag(cw22(i,j+1,k))+aimag(cw22(i,j+1,k))*aimag(cw22(i,j+1,k))), kind=mytype)
</code></pre>

<p>   enddo
   a3(i,1,k,4)=cmplx((xa0<em>xa1</em>(real(cw22(i,1,k), kind=mytype)<em>real(cw22(i,2,k), kind=mytype)+real(cw22(i,2,k), kind=mytype)</em>&amp;</p>

<pre><code>    real(cw22(i,2,k), kind=mytype))),&amp;
    (xa0*xa1*(aimag(cw22(i,1,k))*aimag(cw22(i,2,k))+aimag(cw22(i,2,k))*aimag(cw22(i,2,k)))), kind=mytype)
</code></pre>

<p>   enddo
   enddo
!sup diag +2
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)
   do j=1,nym-2</p>

<pre><code>  a3(i,j,k,5)=cmplx(-real(cw22(i,j+1,k), kind=mytype)*real(cw22(i,j+2,k), kind=mytype)*xa1*xa1,&amp;
       -aimag(cw22(i,j+1,k))*aimag(cw22(i,j+2,k))*xa1*xa1, kind=mytype)
</code></pre>

<p>   enddo
   !a3(i,1,k,5)=a3(i,1,k,5)*2.
   !a3(i,1,k,5)=0.
   a3(i,nym-1,k,5)=0.
   a3(i,nym,k,5)=0.
   enddo
   enddo</p>

<p>!inf diag -1
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)
   do j=2,nym</p>

<pre><code>  a3(i,j,k,2)=cmplx(xa0*xa1*(real(cw22(i,j,k), kind=mytype)*real(cw22(i,j-1,k), kind=mytype)+real(cw22(i,j-1,k), kind=mytype)*&amp;
       real(cw22(i,j-1,k), kind=mytype)),&amp;
       xa0*xa1*(aimag(cw22(i,j,k))*aimag(cw22(i,j-1,k))+aimag(cw22(i,j-1,k))*aimag(cw22(i,j-1,k))), kind=mytype)
</code></pre>

<p>   enddo
   a3(i,1,k,2)=0.
   enddo
   enddo
!inf diag -2
   do k=sp%yst(3),sp%yen(3)
   do i=sp%yst(1),sp%yen(1)
   do j=3,nym</p>

<pre><code>  a3(i,j,k,1)=cmplx(-real(cw22(i,j-1,k), kind=mytype)*real(cw22(i,j-2,k), kind=mytype)*xa1*xa1,&amp;
       -aimag(cw22(i,j-1,k))*aimag(cw22(i,j-2,k))*xa1*xa1, kind=mytype)
</code></pre>

<p>   enddo
   a3(i,1,k,1)=0.
   a3(i,2,k,1)=0.
   enddo
   enddo</p>

<p>!not to have a singular matrice
!   do k=sp%yst(3),sp%yen(3)
!   do i=sp%yst(1),sp%yen(1)
!      if ((xkx(i)==0.).and.(zkz(k)==0)) then
if (nrank==0) then
   a3(1,1,1,3)=cmplx(1.,1., kind=mytype)
   a3(1,1,1,4)=0.
   a3(1,1,1,5)=0.
endif
!      endif
!   enddo
!   enddo
endif</p>

<p>return
end subroutine matrice_refinement</p>

<p>end module decomp_2d_poisson
```</p>
]]></content>
  </entry>
  
</feed>
