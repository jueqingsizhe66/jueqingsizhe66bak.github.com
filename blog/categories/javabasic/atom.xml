<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaBasic | 网络书屋(Web Reading Room)]]></title>
  <link href="http://jueqingsizhe66.github.io/blog/categories/javabasic/atom.xml" rel="self"/>
  <link href="http://jueqingsizhe66.github.io/"/>
  <updated>2017-08-13T21:47:14+08:00</updated>
  <id>http://jueqingsizhe66.github.io/</id>
  <author>
    <name><![CDATA[Ye Zhaoliang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mysql乱码回顾]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2017/02/13/mysqlluan-ma-hui-gu/"/>
    <updated>2017-02-13T08:50:12+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2017/02/13/mysqlluan-ma-hui-gu</id>
    <content type="html"><![CDATA[<p>mysql是一个中型的数据库操作系统平台,他的<a href="http://www.linuxidc.com/Linux/2013-04/83581.htm">基本组成</a>由存储引擎、各个命令模块、优化器、缓存器、解析器、用户模块、链接器(connector)等组成，
<img src="/images/java/mysql/mysql-archetype.png" alt="mysql architect" /></p>

<p>其中存储引擎现在一般选用innodb居多(具体可以查看<a href="http://c.biancheng.net/cpp/html/1465.html">各个存储引擎的区别</a>)</p>

<!--more-->


<p>mysql操作级别：</p>

<ol>
<li>数据库级别</li>
<li>表级别</li>
<li>字段级别</li>
</ol>


<p>而这三个级别就影响这数据库的乱码级别。
一般事先使用<code>show variables like '%char%'</code> 来查看mysql的所有字符信息，参考<a href="http://www.jb51.net/article/74769.htm">mysql乱码解决</a>,
根据该文基本上可以解决问题，另外可以进一步查看各个字符集和mysql查询涉及到的<a href="http://www.jb51.net/article/31135.htm">各个字符集的关系(对应命令的求解)</a>,
查阅了<a href="http://www.pc6.com/infoview/Article_63586.html">多个链接</a>,都显示<code>set names gbk</code>对最终的显示有影响，根据我的使用经验来讲，</p>

<p><font color="red">当你使用<code>set names gbk</code>则可以显示正常，而<code>set names utf8</code>则出现乱码</font></p>

<p>我在建立数据库的时候也使用了<code>create database rupeng chracter set utf8</code>等，但试过一遍只有最终加上<code>set names gbk</code>有效果。</p>

<p><code>
set character_set_database=utf8;
set character_set_server=utf8;
set character_set_client=gbk;
set character_set_connection=gbk;
</code></p>

<p>```
系统变量：
client  为客户端使用的字符集。
connection  为连接数据库的字符集设置类型，如果程序没有指明连接数据库使用的字符集类型则按照服务器端默认的字符集设置。
database    为数据库服务器中某个库使用的字符集设定，如果建库时没有指明，将使用服务器安装时指定的字符集设置。
results 为数据库给客户端返回时使用的字符集设定，如果没有指明，使用服务器默认的字符集。
server  为服务器安装时指定的默认字符集设定。
system  为数据库系统使用的字符集设定。</p>

<p>– character_set_client：客户端来源数据使用的字符集
– character_set_connection：连接层字符集
– character_set_database：当前选中数据库的默认字符集
– character_set_results：查询结果字符集
– character_set_server：默认的内部操作字符集
– character_set_system：系统元数据(字段名等)字符集</p>

<p>```</p>

<p><a href="http://blog.csdn.net/sunqing0316/article/details/46680617">mysql字符集转换过程</a></p>

<p>```</p>

<ol>
<li>MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；</li>
<li>进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：
• 使用每个数据字段的CHARACTER SET设定值；
• 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；
• 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；
• 若上述值不存在，则使用character_set_server设定值。</li>
<li>将操作结果从内部操作字符集转换为character_set_results。
```</li>
</ol>


<p>参考<a href="http://www.2cto.com/database/201410/341144.html">myeclipse-mysql</a>,有一个原则就是不要让你的character出现<code>latin1</code>编码即可</p>

<p>我们操作所有数据库<a href="http://mysql.com/">mysql中型</a>,<a href="https://www.sqlite.org/">sqlite</a>,<a href="https://www.postgresql.org/">postgreSql流行</a>,<a href="http://www.ibm.com/analytics/us/en/technology/db2/">db2(IBM)企业级</a>,<a href="https://www.oracle.com/index.html">oracle大型运用企业级</a>,<a href="https://www.ibm.com/analytics/us/en/technology/informix/">informix(IBM)</a>,
<a href="https://www.microsoft.com/zh-cn/sql-server/">sql server</a></p>

<ul>
<li><a href="http://www.yiibai.com/mysql/mysql_quick_start.html">mysql快速入门学习</a></li>
<li><a href="http://www.w3school.com.cn/sql/sql_intro.asp">W3C sql入门教程</a></li>
<li><a href="http://blog.csdn.net/hgd613/article/details/50433135">左连接</a></li>
<li><a href="http://database.51cto.com/art/200511/12708.htm">51cto数据库论坛</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java开发nexus私服搭建]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2017/02/10/javakai-fa-nexussi-fu-da-jian/"/>
    <updated>2017-02-10T00:04:33+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2017/02/10/javakai-fa-nexussi-fu-da-jian</id>
    <content type="html"><![CDATA[<p>针对一台全新的电脑，安装java开发的maven私服，记录如下，并在IDEA中进行测试。</p>

<p>涉及到javase安装，maven安装，nexus私服安装，nexus本地配置，nexus界面介绍</p>

<!--more-->


<ol>
<li>安装JAVA jdk ,下载<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">javaSE安装包</a>,注意JDK和JRE不要放在同一文件夹下</li>
<li>配置JAVA_HOME为JDk目录，并添加JDK的bin目录(%JAVA_HOME%\bin)到path中
<img src="/images/java/nexus/java.png" alt="java" /></li>
<li>下载<a href="http://maven.apache.org/">maven</a>,并解压缩，配置MAVEN_HOME为maven的根目录，并添加%MAVEN_HOME%\bin到path
中
<img src="/images/java/nexus/home.png" alt="home" />
<img src="/images/java/nexus/bin.png" alt="bin" />
<img src="/images/java/nexus/java.png" alt="mvn" /></li>
</ol>


<p>显示了<code>mvn -v</code>,也就表示装完了maven
4. 下载<a href="https://www.sonatype.com/download-oss-sonatype">nexus2.14</a>,在windows下使用管理员身份打开cmd，并cd到nexus的bin目录，进行安装
<code>
nexus install
nexus start
</code>
注意一定得配置bin\jsw\wrapper.conf的java bin信息，否则出错。
<img src="/images/java/nexus/wrapper.png" alt="wrapper" /></p>

<p>出现的错误为无法启动，
<img src="/images/java/nexus/success.png" alt="success" /></p>

<hr/>


<p>做完前面的几步之后只是，把配置环境弄完了，还得进行私服镜像配置。
首先打开nexus私服页面，使用<code>http://localhost:8089/nexus/#welcome</code></p>

<p><img src="/images/java/nexus/nexus.png" alt="nexus" /></p>

<p>默认的登陆密码是</p>

<pre><code>账号：admin
密码：admin123
</code></pre>

<p>登陆完的界面
<img src="/images/java/nexus/repositories.png" alt="login" /></p>

<p>配置中心仓库:</p>

<p>中心仓库设置download remote indexes为真，为设置本地私服提供源。
<img src="/images/java/nexus/central.png" alt="central" /></p>

<p>配置了release和snapshot仓库
<img src="/images/java/nexus/release.png" alt="release" />
<img src="/images/java/nexus/snapshot.png" alt="snapshot" /></p>

<p>然后配置了第三方插件
<img src="/images/java/nexus/third.png" alt="third" /></p>

<p><strong>进入最关键的public Repositories设置</strong></p>

<p><img src="/images/java/nexus/public.png" alt="public" /></p>

<p>有时候可以使用试用Scheduled Tasks观看库的index是否正常进行。
<img src="/images/java/nexus/schedule.png" alt="scheduled" /></p>

<hr/>




<h2 id="imp">镜像私服配置</h2>


<p>maven中的settings.xml登陆私服的账户密码设置
<img src="/images/java/nexus/user.png" alt="user" /></p>

<p>```
  <servers></p>

<pre><code>&lt;server&gt; 
    &lt;id&gt;nexus-release&lt;/id&gt;
    &lt;username&gt;admin&lt;/username&gt;
    &lt;password&gt;admin123&lt;/password&gt;
&lt;/server&gt; 


&lt;server&gt; 
    &lt;id&gt;nexus-snapshot&lt;/id&gt;
    &lt;username&gt;admin&lt;/username&gt;
    &lt;password&gt;admin123&lt;/password&gt;
&lt;/server&gt; 


&lt;server&gt; 
    &lt;id&gt;nexus&lt;/id&gt;
    &lt;username&gt;admin&lt;/username&gt;
    &lt;password&gt;admin123&lt;/password&gt;
&lt;/server&gt; 
  &lt;!-- server
 | Specifies the authentication information to use when connecting to a particular server, identified by
 | a unique name within the system (referred to by the 'id' attribute below).
 |
 | NOTE: You should either specify username/password OR privateKey/passphrase, since these pairings are
 |       used together.
 |
&lt;server&gt;
  &lt;id&gt;deploymentRepo&lt;/id&gt;
  &lt;username&gt;repouser&lt;/username&gt;
  &lt;password&gt;repopwd&lt;/password&gt;
&lt;/server&gt;
--&gt;

&lt;!-- Another sample, using keys to authenticate.
&lt;server&gt;
  &lt;id&gt;siteServer&lt;/id&gt;
  &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt;
  &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt;
&lt;/server&gt;
--&gt;
</code></pre>

<p>  </servers></p>

<p>```</p>

<p><strong>镜像配置</strong></p>

<p>注意url链接的端口设置
```</p>

<p><mirrors>
<mirror></p>

<pre><code>&lt;id&gt;nexus&lt;/id&gt;
&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
&lt;url&gt;http://localhost:8089/nexus/content/groups/public/&lt;/url&gt;
</code></pre>

<p></mirror>
</mirrors>
<profiles>
<profile></p>

<pre><code>&lt;id&gt;nexus&lt;/id&gt;
</code></pre>

<p><repositories></p>

<pre><code>&lt;repository&gt;
    &lt;id&gt;central&lt;/id&gt;
    &lt;url&gt;http://central&lt;/url&gt;
    &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;
    &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;
&lt;/repository&gt;
</code></pre>

<p></repositories>
<pluginRepositories></p>

<pre><code>&lt;pluginRepository&gt;
    &lt;id&gt;central&lt;/id&gt;
    &lt;url&gt;http://central&lt;/url&gt;
    &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;
    &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;
&lt;/pluginRepository&gt;
</code></pre>

<p></pluginRepositories>
</profile>
</profiles>
<activeProfiles></p>

<pre><code>&lt;activeProfile&gt;nexus&lt;/activeProfile&gt;
</code></pre>

<p></activeProfiles></p>

<p>```</p>

<p>在maven中一般是需要设置下载控件jar包放在哪里,在没有私服的情况下，我一般
可以在setting.xml中设置localRepository
```
   | Default: ${user.home}/.m2/repository
  <localRepository>/path/to/local/repo</localRepository></p>

<p>```</p>

<p>当然IDEA在导入项目或者新建项目的时候都会提醒Environment Variable,设置一下setting和local repository
(类似的思路需要在myeclipse配置)
<img src="/images/java/nexus/setting.png" alt="impo" />
而私服nexus的存放地点，在nexus界面的时候就已经设置好了，所以也得在每台电脑操作一遍(<font color="red">一定不能错</font>)。</p>

<p>镜像的话，就不会执行maven的<code>mvn install</code>等命令还一直向外部仓库访问链接，结果是访问的链接
都是本地的，可看下节测试。</p>

<h2 id="ida">IDEA测试镜像私服</h2>


<p>现在只能通过这个激活了，下载license server
<img src="/images/java/nexus/license.png" alt="license" /></p>

<p>测试结果如下:
<code>mvn site</code></p>

<p><img src="/images/java/nexus/idea.png" alt="idea" /></p>

<p><code>
INFO] artifact org.springframework:spring-beans: checking for updates from nexus
[INFO] artifact org.springframework:spring-context: checking for updates from nexus
[INFO] artifact org.springframework:spring-context-support: checking for updates from nexus
[INFO] artifact org.springframework:spring-core: checking for updates from nexus
[INFO] artifact org.springframework:spring-expression: checking for updates from nexus
[INFO] artifact org.springframework:spring-instrument: checking for updates from nexus
[INFO] artifact org.springframework:spring-instrument-tomcat: checking for updates from nexus
[INFO] artifact org.springframework:spring-jdbc: checking for updates from nexus
[INFO] artifact org.springframework:spring-jms: checking for updates from nexus
[INFO] artifact org.springframework:spring-orm: checking for updates from nexus
[INFO] artifact org.springframework:spring-oxm: checking for updates from nexus
</code></p>

<h2 id="result">结论</h2>


<p>整个配置过程有效，测试通过，进一步可以参考<a href="http://vdisk.weibo.com/s/za2TN71LdL1tl">maven实战 许晓斌</a>,里面包含了maven的坐标空间概念等，详细介绍了
maven系统的各个组成和集成测试环境的搭建。</p>

<p>可以拓展阅读<a href="http://blog.csdn.net/c1481118216/article/category/6250182">java blog</a>
三个有用工具包:</p>

<ul>
<li><a href="https://github.com/venusdrogon/feilong-platform">飞龙 javase javaee(国产)</a></li>
<li><a href="http://feilong-core.mydoc.io/?t=149471">飞龙特别用心的手册</a></li>
<li><a href="https://github.com/venusdrogon/feilong-core/wiki/install">可以玩玩feilong-platform平台的安装 以及mvn site产生好看的javadoc</a></li>
<li><a href="https://github.com/looly/hutool">Hutool javase(国产)</a></li>
<li><a href="http://www.hutool.cn/apidocs/">hutool API手册</a>  <a href="http://hutool.mydoc.io/">Hutool Wiki</a></li>
<li><a href="http://ibeetl.com/guide/#beetl">闲大赋 beetl 好用的模板引擎(国产)</a></li>
<li><a href="http://cn.vuejs.org/">vue.js火热的前端js框架(国产)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Little Java Note]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2016/10/09/a-little-java-note/"/>
    <updated>2016-10-09T01:58:39+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2016/10/09/a-little-java-note</id>
    <content type="html"><![CDATA[<div align="center">目录</div>


<ul>
<li><a href="#1">1. 基础部分</a></li>
<li><a href="#2">2. 通过构造函数，构造出Natural recursion</a></li>
<li><a href="#3">3. 重新设计RemAV RemFishV RemIntV</a></li>
<li><a href="#4">4. 下一步把PieD的字段放入到对应的参数当中</a></li>
<li><a href="#5">5. 引入 this 关键字，指代访问者本身，同步修改对应的访问者类</a></li>
<li><a href="#6">6. 需要进一步提取出visitor部分的函数    </a></li>
<li><a href="#7">7. 统一bTreeVisitorI itreevisitori ttreevisitori</a></li>
<li><a href="#8">8. 重新设计RemAV RemFishV  RemIntV 为RemV(用Object替换）    </a></li>
<li><a href="#9">9. 然后现在把Remv 和Subst重新放入PieD</a></li>
<li><a href="#10">10. 紧接着 我们还想着把Remv  SubstV放入参数的位置</a></li>
<li><a href="#11">11. 紧接着我们可以进行下一步抽象   </a></li>
<li><a href="#12">12. 紧接着我们发现rem和subst代码类似 </a></li>
<li><a href="#13">13. 然后再实现Set集合类型</a></li>
<li><a href="#14">14. SetEvalV直接继承IntEvalV不合理?   </a></li>
<li><a href="#15">15. IntEvalD 和SetEvalD很多相似之处   </a></li>
<li><a href="#16">16. 根据extends使用Override增加函数的丰富性  </a></li>
</ul>


<p>视角没想到可以分成不同的classes，并在此基础上进行extends和implement，最终new通过constructors创造不同的value。两级在于基础元件和功能元件两部分。两级也可以分为extends和implements。集于一个class。</p>

<!--more-->


<p>学完<a href="http://www.ccs.neu.edu/home/matthias/BALJ/">《a little java》</a>的心得,</p>

<ol>
<li>构造函数：new通过构造函数，产生了datatype的值；构造函数由此进行了natural recursion， 并通过一个基类退出循环（详见PieD).new create values.</li>
<li>This,一般指向当前对象，但是在函数式编程中，this可能指代的是当前对象之后的所有剩余对象
&ldquo;this"指代的是自指对象 也就是函数某某的实例化对象，并且是一直不变的。Just self-referential，because this is a RemV, and it is exactly what we need to complete the job. 所以this指代函数莫某的对象</li>
<li>Top某某函数询问某种来自函数某某的forTop功能 ，并传递构造函数的fields值(properties）以及该某某函数comsumes的objects（arguments)</li>
<li>  升级版本 the method accepts a visitor(该visitor接口包含了forTop forBot抽象方法，该接口统一了不同的函数某某，所以所有函数某某统称为accept函数某某）and ask for its services， so we call it accept， 而该接口的通常实例化对象也被叫做ask， ask for services.</li>
<li>Object类型可以抽象int boolean 其他类型</li>
<li>函数的抽象大体表现为参数数据类型，返回值数据类型和函数body的具体实现。

<ol type="a">
<li>参数数据类型</li>
<li>返回值数据类型</li>
<li>body具体实现</li>
</ol>
</li>
<li>简化（简洁）、拓展性、方便</li>
<li>当我们的参数值从method变到fields，我们就没必要在反复调用对象的方法的时候 需要不断地comsume，而同时又保证了this对象，也就是不断地自指（期间不产生新的fields）所以也就是使得计算加快了。这也是this存在的原因（并且该this对象只用在访问者对象中）</li>
<li>We know that a visitorI contains one method each for the Circle, Square, and Trans variants,. And each of these methods
Consumes the fields of the respective kinds of objects(objects of types)
某某对象的某某函数，（携带函数某某和字段） 询问函数某某的for对象某某功能，（携带对象某某）
某某对象的accept携带ask并内部由 ask 的for对象某某携带对象某某组成，而for对象某某携带对象某某并内部由对象某某的accept携带当前ask对象构成。
某某对象的accept携带ask并内部由 ask 的for对象某某组成，而for对象某某携带对象某某并内部由对象某某的accept组成。</li>
</ol>


<p>在对象内部，某某对象的accept携带ask并内部由 ask 的for对象某某携带对象某某组成，而在visitor内部，for对象某某携带对象某某并内部由对象某某（也就是consumes the fields of the respective kinds of objects 占据对象类型的字段属性）的accept携带当前ask对象构成。
We don&rsquo;t specify fields in interfaces. And in 7 W hatever.
any case, we don&rsquo;t want anybody else to
see p.
This and that在对象间传递，而consume在函数间传递（Hangs over back and forth(fields 在对象间传递，而consume在函数间传递)
10. 该书包含着TLS TSS 和prolog编程的思想(因为你要理解new Top new Bot等需要有fact and rule的意识)（仔细去品尝 go to absorb) 还有就是skeleton and techniques技术
11. Extends interface,this extension produces an interface that contains all the obligations(i.e. names of methods and what they consume and produce) of shapeVisitorI and the additional one named forUnion(所以换个角度说，one class can implement many interfaces.
12. 重载override 相同的名字带着不同的输入类型
13. 点号可以读作 from   点号之前叫做from who  点号之后叫做service
14. 解释的重点是什么？？？ 要点是什么</p>

<p><img src="/images/alittlejava/duichen.png" alt="duichen" /></p>

<p>什么是思考力的三要素，讲这个问题之前我们先来了解一下什么是思考思维，首先思考是思维的一种探索活动，而在思维过程中产生的一种具有积极性和创造性的作用力这种就是思考力。据物理学理解，思考力具有三个基本要素：分别为大小、方向、作用点。思考力同样也离不开三个基本要素：分别为大小、方向、作用点。</p>

<ol>
<li>大小 ——思考力首先取决于思考者掌握的关于思考对象的知识和信息量（大小），如果没有相关的知识和信息，就不可能产生相关的思考活动。一般情况下，知识量和信息量越大，思考就越加具体、全面和完整，从而决定了思考的维度。</li>
<li>方向 ——我们这里所说的思考有别于妄想和幻想，而是一种有目的性和有计划性的思维活动，因此，这种思考需要有一定的价值导向，也就是思路——体现为目的性、方向性和一致性。漫无目的地思考难以发挥强有力的思考力，常常会把思考引进死胡同，导致思路夭折和无果而终。目的性、方向性、一致性和价值导向，决定着思考的角度和向度。</li>
<li>作用点 ——必须把思考集中在特定的对象上，并把握其中的关键点，这样的思考就会势如破竹。如果找不准思考的着力点，就会精力分散、思维紊乱、胡思乱想，出现东一榔头西一棒的现象。思考就会停留在事物的表面上浮光掠影，无法深刻认识事物的本质。思考在作用点上的集中性程度，决定着思考的强度和力度(广度和深度）。</li>
</ol>


<h3 id="1">基础部分</h3>


<p>理解分层。</p>

<p>```  java
KebabD(chapter2) 烤肉</p>

<pre><code>isVeggie();
whatHolder();
    Holder 烤肉摆放工具
        Object;
        Holder(Object);
        isVeggie();
        whatHolder();
    Shallot  葱
        KebabD;
        Shallot(KebabD);
        isVeggie();
        whatHolder();

    Shrimp 虾
        KebabD;
        Shrimp (KebabD);
        isVeggie();
        whatHolder();

    Radish 萝卜
        KebabD;
        Radish (KebabD);
        isVeggie();
        whatHolder();

    Pepper 胡椒粉
        KebabD;
        Pepper (KebabD);
        isVeggie();
        whatHolder();

    Zucchini 西葫芦
        KebabD;
        Zucchini (KebabD);
        isVeggie();
        whatHolder();
</code></pre>

<p>RodD(chapter2) 杆  将烤肉串起来工具(烤肉摆放方式1）</p>

<pre><code>Dagger 匕首
Sabre 军刀
Sword 剑
</code></pre>

<p>PlateD(chapter2) 盘子  （烤肉摆放方式2)</p>

<pre><code>Gold 金盘子
Silver
Brass 黄铜盘子
Copper 镀铜盘子
Wood   木盘子
</code></pre>

<p>PointD(chapter1,2) 点</p>

<pre><code>distanceTo0(int,int); //可以把它们移入到构造函数中
closerTo0();
    CartesianPt 笛卡尔坐标
        Int
        Int
        CartesianPt(int,int);
        distanceTo0();
        Closeto0();
    ManhattenPt 曼哈顿坐标
        Int
        Int
        ManhattenPt(int,int);
        distanceTo0();
        Closeto0();

    圆柱坐标系
    球坐标系
</code></pre>

<p>PieD</p>

<p>PizzaD（chapter3,4）</p>

<pre><code>remA 去除比萨饼的凤尾鱼订料（防止过咸）
topAwC() 在凤尾鱼顶料加上奶酪顶料（盖住咸味）
subAbC() 将所有的凤尾鱼顶料换成奶酪顶料
    Crust 面包皮
        remA();
        topAwC();
        subAbC();
    Cheese  奶酪
        pizzaD
        Cheese(PizzaD)
        remA();
        topAwC();
        subAbC();

    Olive   橄榄
        pizzaD
        Olive(PizzaD)
        remA();
        topAwC();
        subAbC();

    Anchovy 凤尾鱼
        pizzaD
        Anchovy(PizzaD)
        remA();
        topAwC();
        subAbC();

    Sausage 香肠
        pizzaD
        Sausage(PizzaD)
        remA();
        topAwC();
        subAbC();
    Spinach 菠菜
        pizzaD
        Spinach(PizzaD)
        remA();
        topAwC();
        subAbC();
</code></pre>

<p>Shape</p>

<p>Shish(chapter2，4) 羊肉串</p>

<pre><code>onlyOnions(); 
isVegetarian();
    Skew 架子 烤肉叉子
    Onion 洋葱
    Lamb  羔羊肉
    Tomato 西红柿
</code></pre>

<p>Tree</p>

<p>SeasoningD (chapter1) 调味品</p>

<pre><code>Sage(鼠尾草)
Pepper
Salt
Thyme(百里香)
</code></pre>

<p>NumD (chapter1)</p>

<pre><code>Zero
OneMoreThan
</code></pre>

<p>LayerD</p>

<pre><code>Base
Slice
</code></pre>

<p>FruitD</p>

<p>```</p>

<p><strong>第二条建议</strong></p>

<pre><code>When writing a function over a datatype,
place a method in each of the variants that make up the datatype.
If a field of a variant belongs to the same datatype,
the method may call the corresponding method of the field in
computing the function.（疑问子类 每继承一次父类 都得重写三个父类的抽象函数 有点费事。。 ----那么访问者模式到底是如何解决的？）
</code></pre>

<p><strong>第八条建议</strong></p>

<pre><code>When extending a class, use overriding
to enrich its functionality.
</code></pre>

<p>根据以上建议， LtdSubstV 可以直接在 SubstV 类上进行继承和扩展。
``` java
Shish(chapter2，4) 羊肉串
   OnlyOnionsV
   IsVegetarianV
   onlyOnions();
   isVegetarian();</p>

<pre><code>    Skew 架子 烤肉叉子
        onlyOnions();
        isVegetarian();
    Onion 洋葱
        ShishD
        Onion(ShishD);
        onlyOnions();
        isVegetarian();
    Lamb  羔羊肉
        ShishD
        Lamb(ShishD);
        onlyOnions();
        isVegetarian();

    Tomato 西红柿
        ShishD
        Tomato(ShishD);
        onlyOnions();
        isVegetarian();
</code></pre>

<p>OnlyOnionsV</p>

<pre><code>forSkew();
forOnion(ShishD);
forLamb(ShishD);
forTomato(ShishD);
</code></pre>

<p>isVegetatianV</p>

<pre><code>forSkew();
forOnion(ShishD);
forLamb(ShishD);
forTomato(ShishD);
</code></pre>

<p>ShishD
   OnlyOionsV ooFn
   IsVegeterian ivFn
   onlyOnions()a;
   isVegetarian()a;</p>

<pre><code>    Skew
        onlyOnions();
        isVegetarian();
    Onion
        onlyOnions();
        isVegetarian();
    Lamb
        onlyOnions();
        isVegetarian();
    Tomato
        onlyOnions();
        isVegetarian();
</code></pre>

<p>```</p>

<h3 id="2">通过构造函数，构造出Natural recursion部分，形成递归，递归出口为skew</h3>


<p>``` java
RemAV</p>

<pre><code>forCurst();
forCheese(PizzaD);
forOlive(PizzaD);
forAnchovy(PizzaD);
forSausage(PizzaD);
</code></pre>

<p>TopAwCV</p>

<pre><code>forCurst();
forCheese(PizzaD);
forOlive(PizzaD);
forAnchovy(PizzaD);
forSausage(PizzaD);
</code></pre>

<p>SubAbCV</p>

<pre><code>forCurst();
forCheese(PizzaD);
forOlive(PizzaD);
forAnchovy(PizzaD);
forSausage(PizzaD);
</code></pre>

<p>PizzaD
   RemAV remFn
   TopAwCV topFn
   SubAbCV  subFn
   remA()a;
   topAwC()a;
   subAbC()a;</p>

<pre><code>    Crust
        remA();
        topAwC();
        subAwC();
    Cheese
        PizzaD
        Cheese(PizzaD)
        remA();
        topAwC();
        subAwC();
    Olive
        PizzaD
        Olive(PizzaD)
        remA();
        topAwC();
        subAwC();
    Anchovy
        PizzaD
        Anchovy(PizzaD)
        remA();
        topAwC();
        subAwC();
    Sausage
        PizzaD
        Sausage(PizzaD
        remA();
        topAwC();
        subAwC();
</code></pre>

<p>PieD</p>

<pre><code>RemAV raFn
RemFish rfFn
remA()a;
remFish(FishD)a;
    Bot
        remA();
        remFish(FishD);
    Top
        Object
        PieD
        Top(Object, PieD)
        remA();
        remFish(FishD);
</code></pre>

<p>FishD</p>

<pre><code>Salmon 鲑鱼
Equals(Object);
Anchovy 凤尾鱼
Equals(Object);
Tuna  金枪鱼
Equals(Object);
</code></pre>

<p>RemAV</p>

<pre><code>forBot
fotTop(Object, PieD)
</code></pre>

<p>RemFishV</p>

<pre><code>forBot(FishD)
forTop(Object, PieD,  FishD)
</code></pre>

<p>RemIntV</p>

<pre><code>forBot(int)
forTop(Object, pieD, Integer)
</code></pre>

<p>```</p>

<h3 id="3">重新设计RemAV RemFishV  RemIntV 为RemV(用Object替换）</h3>


<p>``` java
RemV</p>

<pre><code>forBot(Object)
forTop(Object, pieD, Object)
</code></pre>

<p>```</p>

<h3 id="4">下一步把PieD的字段放入到对应的参数当中</h3>


<p>``` java</p>

<p>abstract class PieD {</p>

<pre><code>abstract PieD rem(RemV remFn, Object o);
abstract PieD subst(SubstV substFn, Object n, Object o);
</code></pre>

<p>}</p>

<p>PieD</p>

<pre><code>Rem()a;
Subst()a;
    Top
        Top(Object,Object)
        Rem();
        Subst();
    Bot
        Bot(Object,Object)
        Rem();
        Subst();
</code></pre>

<p>```</p>

<h3 id="5">引入 this 关键字，指代访问者本身，同步修改对应的访问者类。</h3>


<p>``` java
PieD</p>

<pre><code>Rem(Remv)a;
Subst(Subst)a;
    Top
        Top
        Rem
        Subst
    Bot
        Bot
        Rem
        Subst
</code></pre>

<p>```</p>

<h3 id="6">需要进一步提取出visitor部分的函数</h3>


<p>这样就可以把所有</p>

<p>``` java
PieVisitorI</p>

<pre><code>forBot();
forTop();
    Remv
        forBot();
        forTop();
    SubstV
        forBot();
        forTop();
</code></pre>

<p>pieD</p>

<pre><code>Accept(PieVisitorI)
    Bot
        Accept(pieVisitorI);
    Top
        Accept(pieVisitorI);
</code></pre>

<p>FruitD</p>

<pre><code>Peach
Apple
Pear
Lemon
Fig 无花果
</code></pre>

<p>TreeD</p>

<pre><code>Accept(bTreeVisitorI)
Accept(iTreeVisitorI)
Accept(tTreeVisitorI)
    Bub 芽
        Accept(bTreeVisitorI)
        Accept(iTreeVisitorI)
        Accept(tTreeVisitorI)
    Flat 平顶
        FruitD
        TreeD
        Flat(FruitD, TreeD)
        Accept(bTreeVisitorI)
        Accept(iTreeVisitorI)
        Accept(tTreeVisitorI)
    Split 分枝
        TreeD
        TreeD
        Split(TreeD, TreeD)
        Accept(bTreeVisitorI)
        Accept(iTreeVisitorI)
        Accept(tTreeVisitorI)
</code></pre>

<p>bTreeVisitorI</p>

<pre><code>forBud();
forFlat(FruitD, TreeD);
forSplit(TreeD, TreeD);
    bIsFlatV implements bTreeVisitorI
        forBud();
        forFlat(FruitD, TreeD);
        forSplit(TreeD, TreeD);
    bIsSplitV implements bTreeVisitorI
        forBud();
        forFlat(FruitD, TreeD);
        forSplit(TreeD, TreeD);
    bHasFruitV implements bTreeVisitorI
        forBud();
        forFlat(FruitD, TreeD);
        forSplit(TreeD, TreeD);
</code></pre>

<p>iTreeVisitorI</p>

<pre><code>forBud();
forFlat(FruitD, TreeD);
forSplit(TreeD, TreeD);
    iHeightV implements iTreeVisitorI
        forBud();
        forFlat(FruitD, TreeD);
        forSplit(TreeD, TreeD);
    iOccursV implements iTreeVisitorI
        FruitD
        iOccursV(FruitD)
        forBud();
        forFlat(FruitD, TreeD);
        forSplit(TreeD, TreeD);
</code></pre>

<p>tTreeVisitorI</p>

<pre><code>forBud();
forFlat(FruitD, TreeD);
forSplit(TreeD, TreeD);
    tSubstV implements tTreeVisitorI
        FruitD
        FruitD
        tSubstV(FruitD, FruitD)
        forBud();
        forFlat(FruitD, TreeD);
        forSplit(TreeD, TreeD);
     iOccursV implements tTreeVisitorI
        forBud();
        forFlat(FruitD, TreeD);
        forSplit(TreeD, TreeD);
</code></pre>

<p>```</p>

<h3 id="7">为了统一bTreeVisitorI 和 iTreeVisitorI   tTreeVisitorI</h3>


<p>（三个的不同就在于返回值分别为 boolean   int   treeD)</p>

<p>``` java
TreeVisitorI</p>

<pre><code>forBud();
forFlat(FruitD, TreeD);
forSplit(TreeD, TreeD);
     IsFlatV implements TreeVisitorI
        forBud();
        forFlat(FruitD, TreeD)
        forSplit(TreeD, TreeD)


    OccursV implements TreeVisitorI
        FruitD
        OccursV(FruitD)
        forBud();
        forFlat(FruitD, TreeD)
        forSplit(TreeD, TreeD)


    class OccursV implements TreeVisitorI {
        FruitD a;
        OccursV(FruitD _a) {
            a = _a;
        }
        public Object forBud() {
            return new Integer(0);
        }
        public Object forFlat(FruitD f, TreeD t) {
            if (f.equals(a))
                return new Integer(((Integer)(t.accept(this))).intValue() + 1);
            else
                return t.accept(this);
        }
        public int forSplit(TreeD l, TreeD r) {
            return new Integer(((Integer)(l.accept(this))).intValue()
                               +
                               ((Integer)(r.accept(this))).intValue());
        }
    }
</code></pre>

<p>TreeD</p>

<pre><code>Accept(TreeVisitorI)
    Bub 芽
        Accept(TreeVisitorI)
    Flat 平顶
        FruitD
        TreeD
        Flat(FruitD, TreeD)
        Accept(TreeVisitorI)
    Split 分枝
        TreeD
        TreeD
        Split(TreeD, TreeD)
        Accept(tTreeVisitorI)
</code></pre>

<p>PieD</p>

<pre><code>RemAV raFn
RemFish rfFn
remA()a;
remFish(FishD)a;
    Bot
        remA();
        remFish(FishD);
    Top
        Object
        PieD
        Top(Object, PieD)
        remA();
        remFish(FishD);
</code></pre>

<p>FishD</p>

<pre><code>Salmon 鲑鱼
Equals(Object);
Anchovy 凤尾鱼
Equals(Object);
Tuna  金枪鱼
Equals(Object);
</code></pre>

<p>RemAV</p>

<pre><code>forBot
fotTop(Object, PieD)
</code></pre>

<p>RemFishV</p>

<pre><code>forBot(FishD)
forTop(Object, PieD,  FishD)
</code></pre>

<p>RemIntV</p>

<pre><code>forBot(int)
forTop(Object, pieD, Integer)
</code></pre>

<p>```</p>

<h3 id="8">重新设计RemAV RemFishV  RemIntV 为RemV(用Object替换）</h3>


<p>``` java
RemV</p>

<pre><code>forBot(Object)
forTop(Object, pieD, Object)
</code></pre>

<p>PieD</p>

<pre><code>RemV
Rem(Object)
    Bot
        Rem(Object)
    Top
        Object
        PieD
        Top(Object, PieD)
        Rem(Object)
</code></pre>

<p>SubstFishV</p>

<pre><code>forBot(FishD, FishD)
forTop(Object , PieD, FishD, FishO)
</code></pre>

<p>SubstIntV</p>

<pre><code>forBot(Int, Int)
forTop(Object , PieD, Int, Int)
</code></pre>

<p>SubstV</p>

<pre><code>forBot(Object, Object)
forTop(Object , PieD, Object, Object)
</code></pre>

<p>```</p>

<h3 id="9">然后现在把Remv 和Subst重新放入PieD</h3>


<p>``` java
PieD</p>

<pre><code>Remv
SubstV
Rem(Object)
Subst(Object, Object)
    Bot
        Rem(Object)
        Subst(Object,Object)
    Top
        Object
        PieD
        Top(Object,PieD)
        Rem(Object)
        Subst(Object,Object)
</code></pre>

<p>```</p>

<h3 id="9">紧接着 我们还想着把Remv  SubstV放入参数的位置</h3>


<p>``` java
PieD</p>

<pre><code>Rem(Remv,Object)
Subst(SubstV,Object, Object)
    Bot
        Rem(Renv,Object)
        Subst(Substv,Object,Object)
    Top
        Object
        PieD
        Top(Object,PieD)
        Rem(RemV,Object)
        Subst(Substv,Object,Object)
</code></pre>

<p>```</p>

<h3 id="10">紧接着我们进一步比较RemV SubstV的实现(我们就得重新修改rem和subst了)</h3>


<p>``` java</p>

<p>class RemV {</p>

<pre><code>Object o;
RemV(Object _o) {
    o = _o;
}
PieD forBot(Object o){
    return new Bot();
}
PieD forTop(Object t, PieD r){
    if (o.equals(t))
        return r.rem(this);
    else
        return new Top(t, r.rem(this));
}
</code></pre>

<p>class RemV {</p>

<pre><code>PieD forBot(Object o) {
    return new Bot();
}
PieD forTop(Object t, PieD r, Object o) {
    if (o.equals(t))
        return r.rem(o);
    else
        return new Top(t, r.rem(o));
}
</code></pre>

<p>}</p>

<p>class SubstV {</p>

<pre><code>PieD forBot(Object n, Object o) {
    return new Bot();
}
PieD forTop (Object t, PieD r, Object n, Object o) {
    if (o.equals(t))
        return new Top(n, r.subst(n, o));
    else
        return new Top(t, r.subst(n, 0));
}
</code></pre>

<p>}
class SubstV {</p>

<pre><code>Object n;
Object o;
SubstV(Object _n, Object _o){
    n = _n;
    o = _o;
}
PieD forBot(Object n, Object o){
        return new Bot();
    }
PieD forTop(Object t, PieD r){
    if (o.equals(t))
        return new Top(n, r.subst(this));
    else
        return new Top(t, r.subst(this));
}
</code></pre>

<p>}</p>

<p>```</p>

<h3 id="11">紧接着我们可以进行下一步抽象</h3>


<p>``` java
PieD</p>

<pre><code>Rem(RemV)
Subst(SubstV)
    Top
        Object
        PieD
        Top(Object, PieD)
        Rem(RemV)
        Subst(SubstV)
    Bot
        Object
        PieD
        Bot(Object, PieD)
        Rem(RemV)
        Subst(SubstV)
</code></pre>

<p>```</p>

<h3 id="12">紧接着我们发现rem和subst代码类似</h3>


<p>``` java
PieVisitorI</p>

<pre><code>forBot
forTop
    RemV implement PieVisitorI
        Object
        RemV(Object)
        forBot();
        forTop(Object,PieD）
    SubstV implement PieVisitorI
        Object
        Object
        SubstV(Object, Object)
        forBot();
        forTop(Object,PieD）
    LtdSubstV implement PieVisitorI
        int
        Object
        Object
        LtdSubstV(int, Object, Object)
        forBot();
        forTop(Object,PieD）
</code></pre>

<p>PieD</p>

<pre><code>Accept(PieVisitorI)
    Bob
        Accept(pieVisitorI)
    Top
        Object
        PieD
        Top(Object,PieD)
        Accept(PieVisitorI)
</code></pre>

<p>ExprVisitorI</p>

<p>ExprVisitorI</p>

<pre><code>forPlus(ExprD, ExprD);
forDiff(ExprD, ExprD);
forProd(ExprD, ExprD);
forConst(ExprD, ExprD);
    IntEvalV implements  ExprVisitorI
        forPlus(ExprD, ExprD);
        forDiff(ExprD, ExprD);
        forProd(ExprD, ExprD);
        forConst(Object);
        Plus(Object, Object)
        Diff(Object, Object)
        Prod(Object, Object)
</code></pre>

<p>ExprD</p>

<pre><code>Accept(ExprVisitorI);
    Plus
        ExprD
        ExprD
        Plus(ExprD, ExprD);
        Accept(ExprVisitorI);
    Diff
        ExprD
        ExprD
        Diff(ExprD, ExprD);
        Accept(ExprVisitorI);
    Prod
        ExprD
        ExprD
        Prod(ExprD, ExprD);
        Accept(ExprVisitorI);
    ConstD
        Object
        ConstD(Object);
        Accept(ExprVisitorI);
</code></pre>

<p>```</p>

<h3 id="13">然后再实现Set集合的类型</h3>


<p>``` java
SetD</p>

<pre><code>Add(integer i);
Mem(integer i);
Plus(SetD);
Diff(SetD);
Prod(SetD);
    Empty
        Mem(integer i);
        Plus(SetD);
        Diff(SetD);
        Prod(SetD);

    Add
        Integer;
        SetD;
        Add(Integer, Integer)
        Mem(integer i);
        Plus(SetD);
        Diff(SetD);
        Prod(SetD);
</code></pre>

<p>ExprVisitorI</p>

<pre><code>forPlus(ExprD, ExprD);
forDiff(ExprD, ExprD);
forProd(ExprD, ExprD);
forConst(ExprD, ExprD);
    IntEvalV implements  ExprVisitorI
        forPlus(ExprD, ExprD);
        forDiff(ExprD, ExprD);
        forProd(ExprD, ExprD);
        forConst(Object);
        Plus(Object, Object)
        Diff(Object, Object)
        Prod(Object, Object)
            SetEvalV implements IntEvalV
                Plus(Object, Object)
                Diff(Object, Object)
                Prod(Object, Object)
</code></pre>

<p>```</p>

<h3 id="14">SetEvalV 直接集成IntEvalV不合理？</h3>


<p>从SetEvalV 和IntEvalV抽取出一个基类</p>

<p>``` java
EvalD implements ExprVisitorI</p>

<pre><code>forPlus(ExprD, ExprD);
forDiff(ExprD, ExprD);
forProd(ExprD, ExprD);
forConst(ExprD, ExprD);
Plus(Object, Object)
Diff(Object, Object)
Prod(Object, Object)
    IntEvalD
        Plus(Object,    Object)
        Diff(Object, Object)
        Prod(Object, Object)
        SetEvalD
        Plus(Object, Object)
        Diff(Object, Object)
        Prod(Object, Object)
</code></pre>

<p>```</p>

<h3 id="15">IntEvalD 和SetEvalD很多相似之处</h3>


<p>于是我们进一步提取</p>

<p>``` java
SubstD implements pieVisitorI</p>

<pre><code>Object
Object
SubstD(Object, Object)
forBot();
forTop(Object,PieD)
</code></pre>

<p>SubstV</p>

<pre><code>SubstV(Object, Object)
forTop(Object, Object)
</code></pre>

<p>LtdSubstV</p>

<pre><code>int
LtdSubstV(int,Object, Object)
forTop(Object, Object)
</code></pre>

<p>```</p>

<h3 id="16">根据extends使用override增加函数的丰富性</h3>


<p>``` java
SubstV implements PieVisitorI</p>

<pre><code>Object
Object
SubstV(Object, Object)
forBot()
forTop(Object, PieD)
</code></pre>

<p>LtdSubstV</p>

<pre><code>Int
Object
Object
LtdSubstV(int, Object, Object)
forTop(Object, PieD)
</code></pre>

<p>```</p>

<p>原来，抽象类可以有构造方法.抽象类只要有一个abstract函数就可以叫做抽象类
抽象类可以有构造方法，构造方法不可继承，但是可以供子类用super（）或者super（参数，参数。。。。）调用。
构造函数是对象的基本，没有构造函数就没有对象。
若果在父类中（这里就是你的抽象类）中显示的写了又参数的构造函数，在子类继承是就必须写一个构造函数来调用父类的构造函数。</p>

<p>``` java
PointD
PointD(chapter1,2) 点</p>

<pre><code>distanceTo0(int,int); //可以把它们移入到构造函数中
closerTo0();
PointD minus(PointD)
int moveBy(int ,int)
    CartesianPt 笛卡尔坐标
        Int
        Int
        CartesianPt(int,int);
        distanceTo0();
        Closeto0();
    ManhattenPt 曼哈顿坐标
        Int
        Int
        ManhattenPt(int,int);
        distanceTo0();
        Closeto0();
    圆柱坐标系
    球坐标系
</code></pre>

<p>ShadowedCartesia</p>

<pre><code>Int
Int
ShadowedCartesia(int, int, int, int)
distanceTo0()
</code></pre>

<p>shapeVisitorI</p>

<pre><code>forCircle(int)
forSquare(int)
forTrans(pointD, ShapeD)
UnionVisitorI
forUnion(ShapeD, ShapeD)
    HasPtV implements ShapeVisitorI
        PointD
        HasPt(PointD)
        forCircle(int)
        forSquare(int)
        forTrans(PointD, ShapeD)
    UnionHasPtV implements ShapeVisitorI
        UnionHasPtV(PointD)
        forUnion(ShapeD, ShapeD)
        return s.accept(new HasPtV(p.minus(q)));
    HasPtV implements ShapeVisitorI
        PointD
        HasPt(PointD)
        ShapeVisitorI newHasPt(PointD)
        forCircle(int)
        forSquare(int)
        forTrans(PointD, ShapeD)
    UnionHasPtV implements unionVisitorI
        UnionHasPtV(PointD)
        ShapeVisitorI newHasPt(PointD)_o
        forUnion(ShapeD, ShapeD)
        return s.accept(newHasPtV(p.minus(q)));
</code></pre>

<p>ShapeD</p>

<pre><code>Accept(ShapeVisitorI)
    Circle
        Int
        Circle(int)
        Accept(ShapeVisitorI)_o
    Square
        Int
        Square(int)
        Accept(ShapeVisitorI)_o
    Trans
        PointD
        ShapeD
        Trans(int)
        Accept(ShapeVisitorI)_o
    Union
        ShapeD
        ShapeD
        Union(ShapeD, ShapeD)
        Accetp(ShapeVisitorI)_o
</code></pre>

<p>```</p>

<h3 id="16">newHasPt和HasPtV are eta reduction</h3>


<p>``` java
PieManI</p>

<pre><code>Int addTop(Object)
Int remTop(Object)
Int substTop(Object,Object)
Int occTop(Object)
</code></pre>

<p>PieManM implements PieManI</p>

<pre><code>PieD
addTop(Object) _o
remTop(Object)_o
substTop(Object,Object)_o
occTop(Object)
</code></pre>

<p>PieVisitorI</p>

<pre><code>forBot();
forTop(Object, Object)
    OccursV
        Object
        OccursV(Object)
        forBot()_o
        forTop(Object,PieD)_o
    SubstV
        Object
        Object
        SubstV(Object, Object)
        forBot();
        forTop(Object,PieD)_o
    RemV
        Object
        RemV(Object)
        forBot(Object)
        forTop(Object,PieD)
</code></pre>

<p>PieD</p>

<pre><code>Accept(PieVisitorI)
    Bot
        Accept(PieVisitorI)_o
    Top
        Object
        PieD
        Top(Object, PieD)
        Accept(PieVisitorI)_o
</code></pre>

<p>PieVisitorI</p>

<pre><code>forBot(Bot)
foTop(Top)
    OccursV
        Object
        OccursV(Object)
        forBot(Bot that)
        forTop(Top that)
    SubstV
        Object
        Object
        SubstV(Object,Object)
        forBot(Bot that)
        forTop(Top That)
    RemV
        Object
        RemV(Object)
        forBot(Bot that)
        fotTop(Top that)
</code></pre>

<p>PieD</p>

<pre><code>Accept(PieVisitorI)
    Bot
        Accept(PieVisitorI)_o
    Top
        Object
        Object
        Top(Object, Objct)
        Accept(PieVisitor)_o
</code></pre>

<p>```</p>

<p><strong>每天你只能不断去思考 事情的要点和第一步和第二步 才能取得进步.</strong></p>

<p>What’s the point of the visitor pattern? What’s the point of the software design?</p>

<ul>
<li>亮点</li>
<li>突破点，并按照一定的方向。。</li>
<li>关键点</li>
</ul>


<p><img src="/images/alittlejava/closure.png" alt="closure" /></p>

<p><strong>Closure(Closure(this))</strong></p>

<p>具体java源代码参考<a href="https://github.com/jueqingsizhe66/ALittleJava">the little java</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java小结]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2016/07/19/javaxiao-jie/"/>
    <updated>2016-07-19T18:42:25+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2016/07/19/javaxiao-jie</id>
    <content type="html"><![CDATA[<p>很长没有做java小结，把最近浏览的几个链接添上去。</p>

<!--more-->


<p>java小结</p>

<ol>
<li><p><a href="https://github.com/JpressProjects/jpress">Jpress</a> 是一个不错的cms开源平台，慢慢可以取代wordpress,且速度较快。</p></li>
<li><p><a href="http://luxiaolei.com/">路小磊</a>的工具包<a href="https://github.com/looly/hutool">Hutools utility</a>有在更新中。</p></li>
<li><p>sourceTree可以用来做软件开发跟踪，内核当然是git。
<img src="/images/java/javaSourceTree.png" alt="sourcetree" /></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[压缩文件IO流的使用和简单封装（0213）]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2015/05/11/ya-suo-wen-jian-ioliu-de-shi-yong-he-jian-dan-feng-zhuang-%280213%29/"/>
    <updated>2015-05-11T14:58:47+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2015/05/11/ya-suo-wen-jian-ioliu-de-shi-yong-he-jian-dan-feng-zhuang-(0213)</id>
    <content type="html"><![CDATA[<!--more-->


<p>分为三个部分：
第一部分 ，先是试用了zipinputstream的用法
第二部分， 是进一步试用了压缩流zipoutputStream和加密的方法
第三部分 ， 则是对上述过程封装为一个OOZip类</p>

<p>功能简述：  分为普通的压缩和加密的压缩，对应的解压缩 。普通的压缩：文件和文件夹都可以。 加密的压缩：文件和文件夹都可以，当加密的时候，则生成的zip文件里面的文件打开时乱码，必须用对应的unzipCrypto方法进行解压才有效。当然不会像winzip会提醒你输入密码，可以让你打开，只不过打开的是乱码。</p>

<p>1： 先从com.rupeng.gtk4j挖出了zipInputStream的用法，用于解压缩，测试只能针对zip文件。
于是就有了初始版本的解压缩流：
```java
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;</p>

<p>/<em>*
* @author    叶昭良
* @time      2015年2月12日下午1:19:18
* @version   TestZipInputStream V1.0
</em>/
public class TestZipInputStream
{</p>

<pre><code>    /**
     * @param args
     */
    public static void main(String[] args)
    {
            //unZipShared("e:\\test\\test.zip");
            //unZipShared("e:\\test\\test1.zip");
            //rar暂时无法解压出来，但是zip文件是可以的
            unZipShared("e:\\test\\test1.zip","e:\\testOutput");
    }

    /**
     *   解压缩 zip文件，只能限制为rar
     * @param zipName        待解压的zip文件
     * @param outputfolder   解压zip文件到outputFoler文件夹下
     */
    public static void unZipShared(String zipName,String outputfolder)
    {
            File gtkDir = new File(outputfolder);// *.dll放的文件夹
            if (!gtkDir.exists())
            {
                    gtkDir.mkdirs();
            }
            InputStream inStream = null;
            try
            {
                    inStream = new  FileInputStream(zipName);
            } catch (FileNotFoundException e1)
            {
                    // TODO Auto-generated catch block
                    e1.printStackTrace();
            }
            //InputStream inStream = Utils.class.getResourceAsStream("/gtkshare.zip");
            if (inStream == null)
            {
                    throw new UnsatisfiedLinkError("没找到"+zipName);
            }
            try
            {                        
                    unZip(inStream, gtkDir.toString());
                    System.out.println(gtkDir.toString());
            } catch (IOException e)
            {
                    System.err.println("解压缩gtkshare.zip失败" + toFullString(e));
            }
    }

    /**
     * 把streamToZip这个zip文件流解压到硬盘的destDir文件夹，支持多级目录
     * @param streamToZip
     * @param destDir
     * @throws IOException
     */
    public static void unZip(InputStream streamToZip,String destDir)throws IOException
    {  
            ZipInputStream zipStream = new ZipInputStream(streamToZip);
            try
            {
                    ZipEntry zipEntry = null;
                    //通过zipEntry方式支持多级目录
                    while((zipEntry=zipStream.getNextEntry())!=null)
                    {
    if(zipEntry.isDirectory())
    {
            File dir = new File(destDir,zipEntry.getName());
            if(!dir.exists())
            {
                    dir.mkdirs();
            }
    }
    else
    {
            FileOutputStream fileOutStream = new FileOutputStream(new File(destDir,zipEntry.getName()));
            try
            {
                    copy(zipStream, fileOutStream);
            }
            finally
            {
                    close(fileOutStream);
            }
    }
</code></pre>

<p>}</p>

<pre><code>            }
            finally
            {
                    close(zipStream);
            }

}
    /**
     *     从zip文件包中拷贝文件
     * @param inStream       zipEntry的某个文件
     * @param outStream      输出的某个文件流
     * @throws IOException
     */
    static void copy(InputStream inStream, OutputStream outStream)
                    throws IOException
    {
            byte[] buffer = new byte[512 * 1024];// 0.5MB 的缓冲区
            int len;
            while ((len = inStream.read(buffer)) &gt;= 0)
            {
                    outStream.write(buffer, 0, len);
            }
    }
    /**
     *    摘自rupeng.gtk4j   不明白具体的作用    非主要问题
     * @param throwable
     * @return
     */
    static String toFullString(Throwable throwable)
    {
            StringWriter sw = null;
            PrintWriter pw = null;
            try
            {
                    sw = new StringWriter();
                    pw = new PrintWriter(sw);
                    throwable.printStackTrace(pw);
                    return sw.toString();
            } finally
            {
                    close(sw);
                    close(pw);
            }
    }
    /**
     *     让文件流安静的关闭
     * @param closeable   关闭接口
     */
    static void close(Closeable closeable)
    {
            if (closeable != null)
            {
                    try
                    {
                            closeable.close();
                    } catch (IOException e)
                    {

                    }
            }
    }
</code></pre>

<p>}
```</p>

<p>2：后来想着有解压缩，必然也是有着压缩，于是就摆了一下，参考了一篇百度知道文章</p>

<pre><code>2.1 首先加入了zip的方法
2.2 改进了zip方法的文件压缩流的写入过程，利用buffersize
2.3 常使用了文章中的加密过程，添加了加密压缩和加密解压缩的过程
2.4 想着实用命令流来进一步实现 压缩和解压缩的调用，后来弃用，改用封装一个OOZip类来实现
</code></pre>

<p>于是就有了下面的升级版的压缩和解压缩的程序：
```java
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Random;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;</p>

<p>import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.interfaces.PBEKey;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;
import javax.crypto.spec.SecretKeySpec;</p>

<p>/<em>*
* @author    叶昭良
* @time      2015年2月12日下午5:22:31
* @version   TestZipInputStreamUpdate V1.0  增加了压缩
*                              V2.0   ZipShared加入了 zosTemp.close(); 修复了 压缩的bug，删掉则无法压缩
*                              V3.0   升级了ZipShared 使用了copy函数。
*                              V4.0   增加了加密压缩 和解加密压缩
</em>/
public class TestZipInputStreamUpdate
{</p>

<pre><code>    /**
     * @param args
     */
    private static final String ALGORITHM = "PBEWithMD5AndDES";
    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
            TestZipInputStreamUpdate tisu = new TestZipInputStreamUpdate();
            //不需要再次加入zip文件后缀了
            //tisu.ZipShared("e://test1222bak","e://test1222");

            tisu.ZipSharedCrypto("e://test1222bak", "e://test1222passwdByZhao.zip", "123456");
            tisu.unzipCrypto("e://test1222passwdByZhao.zip","c://laoliang","123456");
    //        tisu.unzipCrypto("e://test1222passwdByZhao.zip","c://laoliang","1234565");

            /*
             *  你正在进入e:\test1222bak文件夹
                    你正在进入e:\test1222bak\test1222文件夹
                    你正在压缩a1.zip
                    你正在压缩test123.txt
                    你正在压缩test124.txt

                    通过这个实验总结了：所有操作系统内部的文件都是文件，无论是普通的文件
                    还是文件夹文件，还是管道文件，还是索引文件，还是设备文件，本质上都是
                    文件，只不过是在文件的头上面增加了一些特殊的标记，比如说你需要在文件夹
                    的路径增加一个\路径标志 反斜杠的道理是一样的。
             */

            /*  这是一个命令流的使用方式：：
             *         if(args.length==2){ 
        String name = args[1]; 
        Zip zip = new Zip(); 

        if(args[0].equals("-zip")) 
        {
                zipname = args[2];
                zip.doZip(name); 
        }

        else if(args[0].equals("-unzip")) 
        {
                outputfolder = args[2];
                 zip.unZip(name);          
        }     
    } 
    else{ 
        System.out.println("Usage:"); 
        System.out.println("压缩:java Zip -zip directoryName  zipname"); 
        System.out.println("解压:java Zip -unzip fileName.zip outputfolder"); 
        throw new Exception("Arguments error!"); 
    } 
             */
    }
    public void ZipShared(String fileinput,String zos)
    {
            try
            {
                    //加入"zip"后缀！
                    ZipOutputStream zosTemp = new ZipOutputStream(new FileOutputStream(zos+"zip"));
                    File fApple = new File(fileinput);
                    ZipShared(fApple,zosTemp,"");
                    try
                    {
                            /// 为什么加入这个就可以？？？？
                            //  不加入这有异常？？？？why   Tell me 
                            zosTemp.close();
                    } catch (IOException e)
                    {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                    }
            } catch (FileNotFoundException e)
            {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
            }

    }
    public  void ZipShared(File fileinput,ZipOutputStream zos,String base)
    {
            //ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(outputZipName));

            //File fileinput = new File(outputZipName);
</code></pre>

<p>if(fileinput.isDirectory())
{</p>

<pre><code>    System.out.println("你正在进入"+fileinput+"文件夹");
    File[] fBanana = fileinput.listFiles();
    try
    {
            //传进一个文件夹标志
            zos.putNextEntry(new ZipEntry(base+"/"));
            //让base加上一个/
            base = base.length()==0?"":base+"/";
            for(int i = 0; i &lt; fBanana.length; i++)
            {
                    ZipShared(fBanana[i],zos,base+fBanana[i].getName());
            }
    } catch (IOException e)
    {
            // TODO Auto-generated catch block
            System.out.println("压缩文件夹失败"+e.getMessage());
    }
</code></pre>

<p>}else
{</p>

<pre><code>    try
    {
            zos.putNextEntry(new ZipEntry(base));
            FileInputStream fis = new FileInputStream(fileinput);
            //改进写入的方式
            /*int b;
            while((b = fis.read())!= -1)
            {
                    zos.write(b); 
                    //效率很定不高  每一个字符  进行一次缓冲
                    //zos.flush();
            }*/
            copy(fis,zos); //利用汝鹏版的copy函数
            System.out.println("你正在压缩"+fileinput.getName());
            //fis.close();

            //zos.close();
    } catch (IOException e)
    {
            // TODO Auto-generated catch block
            System.out.println("压缩文件失败"+e.getMessage());
    } 
    //为什么加入则错误
    /*finally
    {
            try
            {
                    zos.close();
            }catch(IOException e)
            {
                    System.out.println("打开流错误！");
            }
    }*/
            }
    }
    public  void ZipSharedCrypto(String fileinput,String zosFile,String pwd)
    {

            try
            {        File f1 = new File(fileinput);
            //采用和ZipShared一样的FileOutputStream
                    ZipOutputStream zos  = null;
                    zos = new ZipOutputStream(new FileOutputStream(zosFile));
                    ZipSharedCrypto(f1,zos,"", pwd);
                    try
                    {
                            zos.close();
                    } catch (IOException e)
                    {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                    }
            } catch (FileNotFoundException e)
            {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
            }
            System.out.println("成了");
    }
    public  void ZipSharedCrypto(File fileinput,ZipOutputStream zos,String base,String pwd)
    {
</code></pre>

<p>if(fileinput.isDirectory())
{</p>

<pre><code>    System.out.println("你正在进入"+fileinput+"文件夹");
</code></pre>

<p>File[] fApples = fileinput.listFiles();
//因为ZipEntry的isDirectory()方法中，目录以"/&ldquo;结尾
try
{</p>

<pre><code>    zos.putNextEntry(new ZipEntry(base+"/"));
    base = base.length()==0?"":(base+"/");
    //一种比较新型的方式循环读写东西。
    for(File ftemp:fApples)
    {
            ZipSharedCrypto(ftemp,zos,base+ftemp.getName(),pwd);
    }
</code></pre>

<p>}catch(IOException e)
{</p>

<pre><code>    System.out.println("文件夹加密压缩失败");
    }
</code></pre>

<p>}else
{</p>

<pre><code>    try
    {
            zos.putNextEntry(new ZipEntry(base));
            FileInputStream fis = new FileInputStream(fileinput);
            System.out.println("你正在开始加密压缩"+fileinput+"文件");
    PBEKeySpec keySpec = new PBEKeySpec(pwd.toCharArray());
    SecretKeyFactory keyFactory = null;
    try
    {
            keyFactory = SecretKeyFactory.getInstance(ALGORITHM);
    } catch (NoSuchAlgorithmException e)
    {
            // TODO Auto-generated catch block
            e.printStackTrace();
    }
    SecretKey passwordKey = keyFactory.generateSecret(keySpec);
    //生成一个炸弹 进行加密
    byte[] bomb =  new byte[8];
    Random rnd = new Random();
    rnd.nextBytes(bomb);
    int iterations = 100;
    PBEParameterSpec parameterSpec = new PBEParameterSpec(bomb, iterations);
    Cipher cipher = null;
    try
    {
            cipher = Cipher.getInstance(ALGORITHM);
    } catch (NoSuchAlgorithmException
                    | NoSuchPaddingException e)
    {
            // TODO Auto-generated catch block
            e.printStackTrace();
    }
    cipher.init(Cipher.ENCRYPT_MODE, passwordKey,parameterSpec);
    //往输出流 添加炸弹
    zos.write(bomb);

    //添加加密的主文件内容  1KB缓存区
    byte[] inputBuffer = new byte[1024];
    int bytesRead = 0;
    //如果没有读到信息则为-1
    while((bytesRead = fis.read(inputBuffer))!= -1)
    {
            //每个缓冲区 进行加密写入
            byte[] output = cipher.update(inputBuffer);
            if(output != null)
            {
                    zos.write(output);
            }
    }

    //加密结束语
    byte[] outputFinal =null;
    try
    {
            outputFinal = cipher.doFinal();
    } catch (IllegalBlockSizeException | BadPaddingException e)
    {
            // TODO Auto-generated catch block
            e.printStackTrace();
    }
    if(outputFinal != null)
    {
            zos.write(outputFinal);
    }
</code></pre>

<p>/*        fis.close();</p>

<pre><code>    zos.flush();
    zos.close();*/
</code></pre>

<p>}catch(InvalidKeySpecException | InvalidKeyException | InvalidAlgorithmParameterException | IOException e)
{</p>

<pre><code>    System.out.println("加密失败");
    }
</code></pre>

<p>}</p>

<pre><code>    }
    /**
     *   解压缩 zip文件，只能限制为rar
     * @param zipName        待解压的zip文件
     * @param outputfolder   解压zip文件到outputFoler文件夹下
     */
    public static void unZipShared(String zipName,String outputfolder)
    {
            File gtkDir = new File(outputfolder);// *.dll放的文件夹
            //指定的目录不存在  则创建之
            if (!gtkDir.exists())
            {
                    gtkDir.mkdirs();
            }
            InputStream inStream = null;
            try
            {
                    inStream = new  FileInputStream(zipName);
            } catch (FileNotFoundException e1)
            {
                    // TODO Auto-generated catch block
                    e1.printStackTrace();
            }
            //InputStream inStream = Utils.class.getResourceAsStream("/gtkshare.zip");
            if (inStream == null)
            {
                    throw new UnsatisfiedLinkError("没找到"+zipName);
            }
            try
            {                        
                    unZip(inStream, gtkDir.toString());
                    System.out.println(gtkDir.toString());
            } catch (IOException e)
            {
                    System.err.println("解压缩gtkshare.zip失败" + toFullString(e));
            }
    }

    /**
     * 把streamToZip这个zip文件流解压到硬盘的destDir文件夹，支持多级目录
     * @param streamToZip
     * @param destDir
     * @throws IOException
     */
    public static void unZip(InputStream streamToZip,String destDir)throws IOException
    {  
            ZipInputStream zipStream = new ZipInputStream(streamToZip);
            try
            {
                    ZipEntry zipEntry = null;
                    //通过zipEntry方式支持多级目录
    while((zipEntry=zipStream.getNextEntry())!=null)
    {
            if(zipEntry.isDirectory())
            {
                    System.out.println("你正在创建文件夹文件 比较特殊");
                    File dir = new File(destDir,zipEntry.getName());
                    //如果指定的目录不存在 则创建之
                    if(!dir.exists())
                    {
                            dir.mkdirs();
                    }
            }
            else
            {
                    FileOutputStream fileOutStream = new FileOutputStream(new File(destDir,zipEntry.getName()));
                    try
                    {
                            copy(zipStream, fileOutStream);
                    }
                    finally
                    {
                            close(fileOutStream);
                    }
                    System.out.println("你正在解压缩压缩"+zipEntry.getName());
            }
    }
</code></pre>

<p>}
finally
{</p>

<pre><code>    close(zipStream);
</code></pre>

<p>}</p>

<pre><code>}
    /**
     *     从zip文件包中拷贝文件 ，按照0.5MB的缓冲写入文件(默认方式）
     * @param inStream       zipEntry的某个文件
     * @param outStream      输出的某个文件流
     * @throws IOException
     */
    static void copy(InputStream inStream, OutputStream outStream)
                    throws IOException
    {
            byte[] buffer = new byte[512 * 1024];// 0.5MB 的缓冲区
            int len;
            while ((len = inStream.read(buffer)) &gt;= 0)
            {
                    outStream.write(buffer, 0, len);
            }
    }
    /**
     *    摘自rupeng.gtk4j   不明白具体的作用    非主要问题
     * @param throwable
     * @return
     */
    static String toFullString(Throwable throwable)
    {
            StringWriter sw = null;
            PrintWriter pw = null;
            try
            {
                    sw = new StringWriter();
                    pw = new PrintWriter(sw);
                    throwable.printStackTrace(pw);
                    return sw.toString();
            } finally
            {
                    close(sw);
                    close(pw);
            }
    }
    /**
     *     让文件流安静的关闭
     * @param closeable   关闭接口
     */
    static void close(Closeable closeable)
    {
            if (closeable != null)
            {
                    try
                    {
                            closeable.close();
                    } catch (IOException e)
                    {

                    }
            }
    }

    // 加密解压缩
</code></pre>

<p>/**</p>

<pre><code>     * 功能描述：将压缩文件解压到指定的文件目录下
     * @param zipFileName      压缩文件名称(带路径)
     * @param outputDirectory  指定解压目录
     * @return
     * @throws Exception
     */
    public  void unzipCrypto(String zipFileName, String outputDirectory, String pwd)
    {
            ZipInputStream inputStream;
            try
            {
                    inputStream = new ZipInputStream(new FileInputStream(zipFileName));
                    unzipCrypto(inputStream, outputDirectory, pwd);
            } catch (Exception e)
            {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
            }

    }


    public  void unzipCrypto(ZipInputStream inputStream, String outputDirectory, String pwd) throws Exception
    {
            ZipEntry zipEntry = null;
            FileOutputStream outputStream = null;
            try{
                    while ((zipEntry = inputStream.getNextEntry()) != null) 
                    {
</code></pre>

<p>if (zipEntry.isDirectory())
{</p>

<pre><code>    System.out.println("你正在进入"+zipEntry.getName()+"文件夹");
    String name = zipEntry.getName();
    name = name.substring(0, name.length() - 1);
    File file = new File(outputDirectory + File.separator + name);
    file.mkdir();
</code></pre>

<p>}
else
{</p>

<pre><code>    File file = new File(outputDirectory + File.separator + zipEntry.getName());
    file.createNewFile();
    outputStream = new FileOutputStream(file);
    System.out.println("你正在解压缩"+file.getName()+"文件");
    PBEKeySpec keySpec = new PBEKeySpec(pwd.toCharArray());
SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);
SecretKey passwordKey = keyFactory.generateSecret(keySpec);
byte[] salt = new byte[8];
inputStream.read(salt);
int iterations = 100;
PBEParameterSpec parameterSpec = new PBEParameterSpec(salt, iterations);
Cipher cipher = Cipher.getInstance(ALGORITHM);
cipher.init(Cipher.DECRYPT_MODE, passwordKey, parameterSpec);
byte[] input = new byte[1024];
int bytesRead;
while ((bytesRead = inputStream.read(input)) != -1) 
{
        byte[] output = cipher.update(input, 0, bytesRead);
        if (output != null)
        {
                outputStream.write(output);
        }
}
byte[] output = cipher.doFinal();
if (output != null)
{
        outputStream.write(output);
}
</code></pre>

<p>/*                                    outputStream.flush();</p>

<pre><code>                                outputStream.close();*/
</code></pre>

<p>}</p>

<pre><code>                    }
                    //inputStream.close();
            }
            catch(IOException ex)
            {
                    throw new Exception("解压读取文件失败");
            }
            catch(Exception ex)
            {
                    throw new Exception("解压文件密码不正确");
            }
</code></pre>

<p>/*                finally</p>

<pre><code>            {
                    inputStream.close();
                    outputStream.flush();
                outputStream.close();
            }*/
    }
</code></pre>

<p>}
```</p>

<p>3：进一步 实现先前的想法，封装一个OOZip类，</p>

<pre><code>基本思想：
     1：抽取常用变量，比如bufferSize 缓冲区大小     buf缓冲区； 本想着加入压缩和解压缩的流变量，后来删掉了
     2：定义构造函数， 设置缓冲区大小
     3：复制之前的方法，并利用buffersize和buf改写copy函数和 文件的复制的函数
     4：进行简单地压缩和解压缩文件夹      加密压缩和解加密压缩文件夹   的测试。 并找到了压缩单个文件的bug
     5：bug修复
</code></pre>

<p>  完整代码如下：
```java
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Random;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;</p>

<p>/<em><em>
* @author    叶昭良
* @time      2015年2月12日下午9:51:11
* @version   OOZip    用于压缩和解压缩
*                   V1.0  增加了压缩
*                   V2.0   ZipShared加入了 zosTemp.close(); 修复了 压缩的bug
*                   V3.0   改进了构造函数 利用具有缓冲区的压缩
*                   V4.0   升级了ZipShared 使用了copy函数。
*                   V5.0   增加了加密压缩 和解加密压缩
*                   V6.0   改用了面向对象方式修改了一番
*                   V7.0   加入了一些压缩和解压缩完成的的console标记
*                   V8.0   修复了单个文件无法加密的bug   new ZipEntry(base) 改为
*                    new ZipEntry(base+fileinput.getName())，未添入到zipentry的缘故
*                    而若是文件夹遍历的时候则是有加入文件名的标记！所以在单个文件的时候也需要加入文件名的
*                    标记
*                   V9.0   若有中文问题，可以进一步采用import org.apache.tools.zip.</em> 的zip包！ 更好的支持中文
*                          具体参看<a href="http://blog.csdn.net/liu149339750/article/details/7887701  ">http://blog.csdn.net/liu149339750/article/details/7887701  </a>
*                                 <a href="http://szhnet.iteye.com/blog/199059">http://szhnet.iteye.com/blog/199059</a> ，这个链接当中提供了ant版本
*                          当然此版本，不需要org.apache.tool.zip包也不需要ant包  附录了ant版本的代码，的确看起来
*                          是简单的。
</em>/
public class OOZip
{</p>

<p>/<em>*
*  这几个私有变量的控制，主要体现在针对具体的文件的复制过程中
</em>/</p>

<pre><code>    private int bufSize ; //压缩和解压缩会用到。 一次从压缩文件zip读取多少文件信息
                                                             //或者一次写入多少文件信息到压缩流
    private byte[] buf;   //写入或者写出压缩流的字节数组
    private int readBytes = 0;  //实际写入或者写出文件流的大小。
    private static final String ALGORITHM = "PBEWithMD5AndDES";

    //构造函数的定义
</code></pre>

<p>   public OOZip(){</p>

<pre><code>       // 1025*512  //设置输入输出流的缓冲区的大小 ，统一设置
    this(1024*512); 
} 

public OOZip(int bufSize){ 
    this.bufSize = bufSize; 
    this.buf = new byte[this.bufSize]; 
} 

    //常用的类中 内部函数

    public static void main(String[] args)
    {
            // TODO Auto-generated method stub
            OOZip oz = new OOZip();
            //单个文件加密和非加密测试暂时失败
            oz.ZipShared("e://student.txt", "e://laoliang"); 
            //oz.ZipSharedCrypto("e://student.txt", "e://laoliang","1234");
            //输入文件夹路径则加密和非加密测试通过
            //oz.ZipShared("e://test1222bak", "e://laoliang");  //已测试通过
            //oz.ZipSharedCrypto("e://test1222bak", "e://laoliang", "123456");

            //解压缩，不用输入.zip后缀，只需要输入文件名
            //oz.unzipCrypto("e://laoliang", "c://laozi","123456");
            //测试成功
    }

    /**
     *     压缩名字为fileinput变量内容的文件夹
     * @param fileinput   文件夹名字
     * @param zos         zip文件夹名字
     */
    public void ZipShared(String fileinput,String zos)
    {
            try
            {
                    //加入"zip"后缀！
                    ZipOutputStream zosTemp = new ZipOutputStream(new FileOutputStream(zos+".zip"));
                    File fApple = new File(fileinput);
                    ZipShared(fApple,zosTemp,"");
                    try
                    {
                            /// 为什么加入这个就可以？？？？
                            //  不加入这有异常？？？？why   Tell me 
                            zosTemp.close();
                    } catch (IOException e)
                    {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                    }
            } catch (FileNotFoundException e)
            {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
            }
            System.out.println("success to create"+zos+".zip");
    }
    /**
     *     压缩文件夹的中间函数
     * @param fileinput    输入函数的文件对象
     * @param zos          压缩输出流对象
     * @param base         一般是"" 表示子目录的作用，在递归目录的时候会用到，在文件夹递归中，涉及到改变；
     */
    public  void ZipShared(File fileinput,ZipOutputStream zos,String base)
    {
</code></pre>

<p>if(fileinput.isDirectory())
{</p>

<pre><code>    System.out.println("你正在进入"+fileinput+"文件夹");
    File[] fBanana = fileinput.listFiles();
    try
    {
            //传进一个文件夹标志
            zos.putNextEntry(new ZipEntry(base+"/"));
            //让base加上一个/
            base = base.length()==0?"":base+"/";
            for(int i = 0; i &lt; fBanana.length; i++)
            {
                    ZipShared(fBanana[i],zos,base+fBanana[i].getName());
            }
    } catch (IOException e)
    {
            System.out.println("压缩文件夹失败"+e.getMessage());
    }
</code></pre>

<p>}else
{</p>

<pre><code>    try
    {
            zos.putNextEntry(new ZipEntry(base+fileinput.getName()));
            FileInputStream fis = new FileInputStream(fileinput);
            //改进写入的方式
            /*int b;
            while((b = fis.read())!= -1)
            {
                    zos.write(b); 
                    //效率很定不高  每一个字符  进行一次缓冲
                    //zos.flush();
            }*/
            copy(fis,zos); //利用汝鹏版的copy函数
            System.out.println("你正在压缩"+fileinput.getName());
    } catch (IOException e)
    {
            System.out.println("压缩文件失败"+e.getMessage());
    } 
</code></pre>

<p>}</p>

<pre><code>    }
    /**
     *     加密压缩文件夹
     * @param fileinput    文件夹字符串
     * @param zosFile      压缩字符串名字
     * @param pwd          加密的密码
     */
    public  void ZipSharedCrypto(String fileinput,String zosFile,String pwd)
    {

            try
            {        
                    File f1 = new File(fileinput);
                    //采用和ZipShared一样的FileOutputStream
                    ZipOutputStream zos  = null;
                    zos = new ZipOutputStream(new FileOutputStream(zosFile+".zip"));
                    ZipSharedCrypto(f1,zos,"", pwd);
                    try
                    {
                            zos.close();
                    } catch (IOException e)
                    {
                            e.printStackTrace();
                    }
            } catch (FileNotFoundException e)
            {
                    System.out.println("未找到文件"+e.getMessage());
            }
            System.out.println("success to create crypto "+zosFile+".zip");
    }
    /**
     *          加密压缩文件夹     
     * @param fileinput     压缩文件夹的File对象
     * @param zos           zip压缩输出流ZipOutputStream
     * @param base          一般是""
     * @param pwd           压缩的密码
     */
    public  void ZipSharedCrypto(File fileinput,ZipOutputStream zos,String base,String pwd)
    {
</code></pre>

<p>if(fileinput.isDirectory())
{</p>

<pre><code>    System.out.println("你正在进入"+fileinput+"文件夹");
    File[] fApples = fileinput.listFiles();
    //因为ZipEntry的isDirectory()方法中，目录以"/"结尾
    try
    {        
            zos.putNextEntry(new ZipEntry(base+"/"));
            base = base.length()==0?"":(base+"/");
            //一种比较新型的方式循环读写东西。
            for(File ftemp:fApples)
            {
                    ZipSharedCrypto(ftemp,zos,base+ftemp.getName(),pwd);
            }
    }catch(IOException e)
    {
            System.out.println("文件夹加密压缩失败");
    }
</code></pre>

<p>}else
{</p>

<pre><code>    try
    {
            zos.putNextEntry(new ZipEntry(base));
            FileInputStream fis = new FileInputStream(fileinput);
            System.out.println("你正在开始加密压缩"+fileinput+"文件");
            //加密过程的开始
            PBEKeySpec keySpec = new PBEKeySpec(pwd.toCharArray());
            SecretKeyFactory keyFactory = null;
            try
            {
                    keyFactory = SecretKeyFactory.getInstance(ALGORITHM);
            } catch (NoSuchAlgorithmException e)
            {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
            }
            SecretKey passwordKey = keyFactory.generateSecret(keySpec);
            //生成一个炸弹 进行加密
            byte[] bomb =  new byte[8];
            Random rnd = new Random();
            rnd.nextBytes(bomb);
            int iterations = 100;
            PBEParameterSpec parameterSpec = new PBEParameterSpec(bomb, iterations);
            Cipher cipher = null;
            try
            {
                    cipher = Cipher.getInstance(ALGORITHM);
            } catch (NoSuchAlgorithmException
                            | NoSuchPaddingException e)
            {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
            }
            cipher.init(Cipher.ENCRYPT_MODE, passwordKey,parameterSpec);
            //往输出流 添加炸弹
            zos.write(bomb);

            //添加加密的主文件内容  1KB缓存区
            //byte[] inputBuffer = new byte[1024];
            //int bytesRead = 0;
            //如果没有读到信息则为-1

            //改用 readBytes  buf在类头定义的私有变量，进行统一的buffer缓存区大小的控制
            while((this.readBytes = fis.read(this.buf))!= -1)
            {
                    //每个缓冲区 进行加密写入
                    byte[] output = cipher.update(this.buf);
                    if(output != null)
                    {
                            zos.write(output);
                    }
            }

            //加密结束语-------------加密结束
            byte[] outputFinal =null;
            try
            {
                    outputFinal = cipher.doFinal();
            } catch (IllegalBlockSizeException | BadPaddingException e)
            {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
            }
            if(outputFinal != null)
            {
                    zos.write(outputFinal);
            }        
    }catch(InvalidKeySpecException | InvalidKeyException | InvalidAlgorithmParameterException | IOException e)
    {
            System.out.println("加密失败");
    }
</code></pre>

<p>}</p>

<pre><code>    }
    /**
     *   解压缩 zip文件，只能限制为zip ,rar无法进行，利用如鹏版的
     * @param zipName        待解压的zip文件
     * @param outputfolder   解压zip文件到outputFoler文件夹下
     */
    public void unzip(String zipName,String outputfolder)
    {
            File gtkDir = new File(outputfolder);// *.dll放的文件夹
            //指定的目录不存在  则创建之
            if (!gtkDir.exists())
            {
                    gtkDir.mkdirs();
            }
            InputStream inStream = null;
            try
            {
                    //不用输入.zip后缀，只需要输入文件名
                    inStream = new  FileInputStream(zipName+".zip");
            } catch (FileNotFoundException e1)
            {
                    // TODO Auto-generated catch block
                    e1.printStackTrace();
            }
            //InputStream inStream = Utils.class.getResourceAsStream("/gtkshare.zip");
            if (inStream == null)
            {
                    throw new UnsatisfiedLinkError("没找到"+zipName);
            }
            try
            {                        
                    unzip(inStream, gtkDir.toString());
                    //System.out.println(gtkDir.toString());
                    System.out.println("成功解压缩"+zipName+".zip"+"文件 到"+outputfolder+"文件夹下");
            } catch (IOException e)
            {
                    System.err.println("解压缩"+zipName+".zip失败" + toFullString(e));
            }
    }

    /**
     * 把streamToZip这个zip文件流解压到硬盘的destDir文件夹，支持多级目录
     * @param streamToZip
     * @param destDir
     * @throws IOException
     */
    public  void unzip(InputStream streamToZip,String destDir)throws IOException
    {  
            ZipInputStream zipStream = new ZipInputStream(streamToZip);
</code></pre>

<p>try
{</p>

<pre><code>    ZipEntry zipEntry = null;
    //通过zipEntry方式支持多级目录
</code></pre>

<p>while((zipEntry=zipStream.getNextEntry())!=null)
{</p>

<pre><code>    if(zipEntry.isDirectory())
    {
            System.out.println("你正在创建文件夹文件 比较特殊");
            File dir = new File(destDir,zipEntry.getName());
            //如果指定的目录不存在 则创建之
            if(!dir.exists())
            {
                    dir.mkdirs();
            }
    }
    else
    {
            FileOutputStream fileOutStream = new FileOutputStream(new File(destDir,zipEntry.getName()));
            try
            {
                    copy(zipStream, fileOutStream);
            }
            finally
            {
                    close(fileOutStream);
            }
            System.out.println("你正在解压缩压缩"+zipEntry.getName());
    }
</code></pre>

<p>}</p>

<pre><code>            }
            finally
            {
                    close(zipStream);
            }

}
    /**
     *     从zip文件包中拷贝文件 ，按照0.5MB的缓冲写入文件(默认方式）
     * @param inStream       zipEntry的某个文件
     * @param outStream      输出的某个文件流
     * @throws IOException
     */
    public void copy(InputStream inStream, OutputStream outStream)
                    throws IOException
    {
            //byte[] buffer = new byte[512 * 1024];// 0.5MB 的缓冲区
            //int len;
            while ((this.readBytes = inStream.read(this.buf)) &gt;= 0)
            {
                    outStream.write(this.buf, 0, this.readBytes);
            }
    }
    /**
     *    摘自rupeng.gtk4j   不明白具体的作用    非主要问题
     * @param throwable
     * @return
     */
    public String toFullString(Throwable throwable)
    {
            StringWriter sw = null;
            PrintWriter pw = null;
            try
            {
                    sw = new StringWriter();
                    pw = new PrintWriter(sw);
                    throwable.printStackTrace(pw);
                    return sw.toString();
            } finally
            {
                    close(sw);
                    close(pw);
            }
    }
    /**
     *     让文件流安静的关闭
     * @param closeable   关闭接口
     */
    public void close(Closeable closeable)
    {
            if (closeable != null)
            {
                    try
                    {
                            closeable.close();
                    } catch (IOException e)
                    {

                    }
            }
    }

    // 加密解压缩
</code></pre>

<p>/**</p>

<pre><code>     * 功能描述：将压缩文件解压到指定的文件目录下
     * @param zipFileName      压缩文件名称(带路径)
     * @param outputDirectory  指定解压目录
     * @return
     * @throws Exception
     */
    public  void unzipCrypto(String zipFileName, String outputDirectory, String pwd)
    {
            ZipInputStream inputStream;
            File outputDir;
            try
            {
                    //不用输入.zip后缀，只需要输入文件名
                    inputStream = new ZipInputStream(new FileInputStream(zipFileName+".zip"));
                    outputDir = new File(outputDirectory);
                    unzipCrypto(inputStream, outputDir, pwd);
            } catch (Exception e)
            {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
            }
            System.out.println("成功解压缩"+zipFileName+".zip"+"文件 到"+outputDirectory+"文件夹下");

    }


    public void unzipCrypto(ZipInputStream inputStream, File outputDir, String pwd) throws Exception
    {
            ZipEntry zipEntry = null;
            FileOutputStream outputStream = null;
            try{
</code></pre>

<p>while ((zipEntry = inputStream.getNextEntry()) != null)
{</p>

<pre><code>    //如果是文件夹  则遍历
    if (zipEntry.isDirectory())
    {
            System.out.println("你正在进入"+zipEntry.getName()+"文件夹");
            String name = zipEntry.getName();
            name = name.substring(0, name.length() - 1);
            File file = new File(outputDir + File.separator + name);
            file.mkdir();
    } 
    //对单个普通文件进行处理
    else 
    {
            File file = new File(outputDir + File.separator + zipEntry.getName());
            file.createNewFile();
            outputStream = new FileOutputStream(file);
            System.out.println("你正在解压缩"+file.getName()+"文件");
            //解压加密过程的开始
            PBEKeySpec keySpec = new PBEKeySpec(pwd.toCharArray());
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);
        SecretKey passwordKey = keyFactory.generateSecret(keySpec);
        //准备排除加密的炸弹头
        byte[] apple = new byte[8];
        //在zip输入流添加read
        inputStream.read(apple);
        int iterations = 100;
        PBEParameterSpec parameterSpec = new PBEParameterSpec(apple, iterations);
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, passwordKey, parameterSpec);
        //byte[] input = new byte[1024];
        //int bytesRead;
        //利用全局的私有变量this.buf  this.readBytes ,已在类开头定义，统一控制
        while ((this.readBytes = inputStream.read(this.buf)) != -1) 
        {
                byte[] output = cipher.update(this.buf, 0, this.readBytes);
                if (output != null)
                {
                        outputStream.write(output);
                }
        }
        byte[] output = cipher.doFinal();
        if (output != null)
        {
                outputStream.write(output);
        }

    }
</code></pre>

<p>}</p>

<pre><code>            }
            catch(IOException ex)
            {
                    throw new Exception("解压读取文件失败");
            }
            catch(Exception ex)
            {
                    throw new Exception("解压文件密码不正确");
            }
    }
</code></pre>

<p>}
/*
*  附录ant版本的压缩实现<a href="http://szhnet.iteye.com/blog/199059">http://szhnet.iteye.com/blog/199059</a>
*  可以加入某些文件和删除某些文件
*  package net.szh.zip;</p>

<p>import java.io.File;</p>

<p>import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Zip;
import org.apache.tools.ant.types.FileSet;</p>

<p>public class ZipCompressorByAnt {</p>

<pre><code>    private File zipFile;

    public ZipCompressorByAnt(String pathName) {
            zipFile = new File(pathName);
    }

    public void compress(String srcPathName) {
            File srcdir = new File(srcPathName);
            if (!srcdir.exists())
                    throw new RuntimeException(srcPathName + "不存在！");

            Project prj = new Project();
            Zip zip = new Zip();
            zip.setProject(prj);
            zip.setDestFile(zipFile);
            FileSet fileSet = new FileSet();
            fileSet.setProject(prj);
            fileSet.setDir(srcdir);
            //fileSet.setIncludes("**//*.java"); 包括哪些文件或文件夹 eg:zip.setIncludes("*.java");
            //fileSet.setExcludes(...); 排除哪些文件或文件夹
            zip.addFileset(fileSet);

            zip.execute();
    }
</code></pre>

<p>}</p>

<p>ant版本的使用：
package net.szh.zip;</p>

<p>public class TestZip {</p>

<pre><code>    public static void main(String[] args) {                
            ZipCompressorByAnt zca = new ZipCompressorByAnt("E:\\szhzipant.zip");
            zca.compress("E:\\test");
    }
</code></pre>

<p>}
<em><br/>
</em>/
```</p>
]]></content>
  </entry>
  
</feed>
