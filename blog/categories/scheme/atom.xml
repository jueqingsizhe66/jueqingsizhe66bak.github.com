<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scheme | 网络书屋(Web Reading Room)]]></title>
  <link href="http://jueqingsizhe66.github.io/blog/categories/scheme/atom.xml" rel="self"/>
  <link href="http://jueqingsizhe66.github.io/"/>
  <updated>2017-08-13T21:47:14+08:00</updated>
  <id>http://jueqingsizhe66.github.io/</id>
  <author>
    <name><![CDATA[Ye Zhaoliang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[阅读source Code of My World]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2017/08/13/yue-du-source-code-of-my-world/"/>
    <updated>2017-08-13T21:42:17+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2017/08/13/yue-du-source-code-of-my-world</id>
    <content type="html"><![CDATA[<p>识贤者，戒游戏，做贡献，时而等闲,工程化行之。</p>

<!--more-->


<h3>贤者</h3>

<ul>
<li><p>可以读读有智慧的朋友 <a href="http://home.wangjianshuo.com/cn/cat_aecccc.html">王建硕</a>(比如很多话都是<a href="http://home.wangjianshuo.com/cn/20090307_aeaecaeaeec.htm">你以为，我以为更加接近现实,奥巴马也曾经以为</a>,当知道
了太多的你以为之后，你才能成长，成熟地感受痛苦。所以最应该送上<a href="http://www.huzheng.org/geniusreligion/TheSourceCodeOfMyWorld.pdf">&ldquo;批斗场&rdquo;</a>的词语应该是"以为")
When thinking changes your mind, that&rsquo;s philosophy.
When God changes your mind, that&rsquo;s faith.
When facts change your mind, that&rsquo;s science. That&rsquo;s the soul of <a href="https://www.edge.org/">edge.org</a></p></li>
<li><p>去<a href="https://www.edge.org/">edge.org</a>看看thinking(比如 <a href="https://www.edge.org/conversation/tania_lombrozo-learning-by-thinking">解释的力量</a> )
大项目和小项目智慧
  参加体检的时候，会有很多项目要进行，而先排队做花时间长的大项目的人会最先体检完，
  因为等你把大项目做完，再去进行小项目的时候，你会发现小项目早空了，没人排队了，而
  那些先排队做小项目的人现在正排着比你开始更长的队伍进行着大项目的体检，所以你轻松
  检查完小项目就可以先走了。去游乐园玩也是这样， 上午先排队玩大项目会是最优的选择，
  因为虽然一开始排大项目的人会很多，但你会发现到了下午，排大项目的人的队伍会变得更
  长，而那些小项目已经基本没什么人排队了，这样你轻松就最先玩完了大多数想玩的项目。
  人生的学习排队也会是有这样的最佳策略，年轻的时候先把那些要花四五年时间才能精通的
  大项目做完（比如Linux操作系统，软件开发技术），再去学习着装打扮这些几个月就能学
  会的小项目，你就会最先达到你的人生目标了。而那些开始没学大项目的人，青春过后，会
  发现再就很难拿出四五年的时间去学习大项目了，而他/她们以前学的那些小项目，别人会
  很快也学会，而且因为别人有了坚实的基础，会做得比他/她们更 好。这就是抓住重点先进
  行突破的秘诀了。就像往罐子里装石头和沙子一样，先放大石子，再灌沙子会充实得很满，
  而先装沙子再放石头就会有很多空隙不能填满了，而且有的石头也就再也放不进去了。可见，
  人生的学习排队策略也应该这样安排，这样才是有智慧的体现</p></li>
</ul>


<p><a href="http://mindhacks.cn/2008/07/07/the-importance-of-knowing-why/">Top-down</a>思想(书读厚)和Bottom-up(书读薄)深入思想,and recursive the procedure in your life(life is one book)，去理解<a href="http://blog.csdn.net/pongba/article/details/2412144">思考的背后</a>.</p>

<pre><code>跨情境运用：思维法则也是知识记忆，是问题解决策略。既然是记忆，就受到提取线索的制约，
这就是为什么当波利亚告诉你要“注意未知数”之后你还是不能真正在所有需要你“注意未知数”
的地方都能提醒自己“注意未知数”。很多时候未知数是很隐蔽的，未知数并不会总是头顶一个
大帽子上面写着“我是未知数”。所以很多时候缺乏对这个策略的“提醒”线索，这也是为什么你
学会了在解决数学问题的时候“注意未知数”却不一定能在解决现实生活中的问题中时刻都能
“注意你的未知数”（《你的灯亮着吗？》整本书的价值便在于此）
</code></pre>

<h3>游戏</h3>

<p>游戏的乐趣，而致瘾，则是对快乐的超前消费、透支消费，不得不说游戏的虚拟社会由对抗、暴力和欲望主宰，玩家们因此急功近利、恩怨分明、派系林立、残酷冷漠，模拟人物的性格弱点。所谓爽，很High，只不过是提前消费快乐罢了，从第二天的疲劳你就会了解得到。就像办了信用卡，可以提前消费，但并不是增加了你的财富。如果随意刷卡，或者太过度玩乐，就
会导致麻烦(由浪费而产生缺乏)，而得不偿失</p>

<h3>贡献</h3>

<p>万事即使无回报也得多做点贡献。</p>

<pre><code>比如历史上有一个伟大的发明家（或许是最伟大的发明家之一），却鲜为人知。他就是
Nikola Tesla。他发现或者开发了一系列伟大创新的基础技术，从无线电信号传输，到交流
电，从特斯拉变压器到X光，荧光灯直到现代电网。他和爱迪生一起工作，却相比之下，却
回报寥寥。不但老年穷困潦倒，也很少有人听说过他。1943年，这位为人类迎来电力时代
的天才去世的时候，身边只有几只他捡来的病鸽子
</code></pre>

<h3>等闲</h3>

<p>等闲，让自己有一些时间来让内心寂静, 等闲也是你的<a href="http://mindhacks.cn/">暗时间</a>,带着你关心的问题进行思考。</p>

<pre><code>寂静指的不是外部环境，而是人的内心。渴望智慧、力量或者任何取得不朽成就的人，都会
在内在世界中找到这些。内在世界会不断为你揭示各样的奥秘。那些粗心 大意的人可能会
认为，“寂静”非常简单而且容易实现,所以要记住，只有在绝对寂静的状态下，你才能够触摸
到神本身，才能领悟到永恒不变的法则并且受益。
怎样获取智慧？ 集中精神；它将为你开启智慧之门，智慧来源于内在
</code></pre>

<h3>工程</h3>

<p>一个工程一个项目的去干，书要干，也要写！多书则书呆，少书则没文化，书在古代也有写的意思。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CPS Intutive]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2017/08/11/cps-intutive/"/>
    <updated>2017-08-11T23:03:15+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2017/08/11/cps-intutive</id>
    <content type="html"><![CDATA[<p>通过deep&amp;coB 和deepB的不同CPS实现，说明letcc版本是直接跳出surrounding，而不管周边的其他计算。
并且可以这样认为所有的scheme lambda表达式都可以理解为kn表达式的过程<font color="red">(好处1)</font>，这种直观的解释方便理解
绕来绕去的过程。并且cps style尾巴的k既可以是变量也可以是函数 <font color="red">(好处2)</font>。</p>

<!--more-->


<h2>1. 普通形式</h2>

<p>``` scheme
;; Normal Form
(define append2
  (lambda (lisa lisb)</p>

<pre><code>(cond
  ((null? lisa) lisb)
  (else
   (cons (car lisa) (append2 (cdr lisa) lisb))))))
</code></pre>

<p>(define fact
  (lambda (n)</p>

<pre><code>(if (zero? n)
     1
     (* n (fact (- n 1))))))
</code></pre>

<p>(fact 4)</p>

<p>```</p>

<h2>2. Tail form</h2>

<p>``` scheme
(define append3
  (lambda (lisa lisb)</p>

<pre><code>(letrec ((ap2
          (lambda (a b)
            (cond
              ((null? a) b)
              (else (ap2 (cdr a) (cons (car a) b)))))))
  (ap2 (reverse lisa) lisb))))
</code></pre>

<p>(define fact2
  (lambda (n)</p>

<pre><code>(letrec ((fact-help (lambda (n help)
                      (if (zero? n)
                          help
                          (fact-help (- n 1) (* n help))))))
  (fact-help n 1))))
</code></pre>

<p>(fact2 4)</p>

<p>```</p>

<h2>3. deep&amp;coB</h2>

<p>``` scheme
(define deep&amp;coB
  (lambda (m k)</p>

<pre><code>(cond
  ((zero? m)
   (let ()
     (set! toppings k)
     (k 'pizza)))
  (else
   (deep&amp;coB (sub1 m)
             (lambda (x)
               (k (cons x '()))))))))
</code></pre>

<p>(deep&amp;coB 6 (lambda (x) x))         ; &lsquo;((((((pizza))))))
(deep&amp;coB 4 (lambda (x) x)) ; &rsquo;((((pizza))))
```</p>

<p>cps风格 lambda(x) x ,可以使用k1  k2 k3 的风格进行替换,cps风格仅仅是编程的风格，letcc是其中的一种体现.</p>

<h2>4. deepB</h2>

<p>letcc风格 直接跳出！！（也就是不管其他计算，直接他就是返回值！！）
``` scheme
(define toppings 0)
(define deepB
  (lambda (m)</p>

<pre><code>(cond
  ((zero? m)
   (call-with-current-continuation
    (lambda (jump)
      (set! toppings jump)
      'pizza)))
  (else
   (cons (deepB (sub1 m)) '())))))
</code></pre>

<p>```</p>

<h2>5. bons and kons</h2>

<p>进一步理解cps风格也可以看看kons和bons的实现</p>

<p>``` scheme</p>

<h1>lang racket</h1>

<p>; kons the magnificent
;
(define kons
  (lambda (kar kdr)</p>

<pre><code>(lambda (selector)          ; returns lambda (selector)
  (selector kar kdr))))     ; calls selector with kar and kdr arguments
</code></pre>

<p>; kar
;
(define kar
  (lambda &copy;                   ; applies selector on (a d) and returns &lsquo;a (car)</p>

<pre><code>(c (lambda (a d) a))))
</code></pre>

<p>; kdr
;
(define kdr
  (lambda &copy;                   ; applies selector on (a d) and returns d (cdr)</p>

<pre><code>(c (lambda (a d) d))))
</code></pre>

<p>; Examples of kons kar kdr
;
(kar (kons &lsquo;a &rsquo;()))                 ; &lsquo;a
(kdr (kons 'a &rsquo;()))                 ; &lsquo;()
(kar (kdr (kons 'a (kons 'b &rsquo;())))) ; &lsquo;b
(kar (kons 'a (kons 'b &rsquo;()))) ; &lsquo;a
; Another cons
;
(define bons
  (lambda (kar)</p>

<pre><code>(let ((kdr '()))
  (lambda (selector)
    (selector
     (lambda (x) (set! kdr x))
     kar
     kdr)))))
</code></pre>

<p>; Another kar
;
(define bar
  (lambda &copy;</p>

<pre><code>(c (lambda (s a d) a))))
</code></pre>

<p>; Another kdr
;
(define bdr
  (lambda &copy;</p>

<pre><code>(c (lambda (s a d) d))))
</code></pre>

<p>; set-kdr
;
(define set-kdr
  (lambda (c x)</p>

<pre><code>((c (lambda (s a d) s)) x)))
</code></pre>

<p>; create kons using set-kdr and bons
;
(define kons2
  (lambda (a d)</p>

<pre><code>(let ((c (bons a)))
  (set-kdr c d)
  c)))
</code></pre>

<p>; Example of kons2 bar and bdr
;
(bar (kons2 &lsquo;a &rsquo;(1 2 3)))       ; &lsquo;a
(bdr (kons2 'a &rsquo;(1 2 3)))       ; &lsquo;(1 2 3)
(define bad
  (lambda (x)</p>

<pre><code>(and (will-stop? bad)
     (eternity x))))
</code></pre>

<p>(define eternity
  (lambda (x)</p>

<pre><code>(eternity x)))
</code></pre>

<p>```</p>

<ul>
<li><a href="https://cgi.soic.indiana.edu/~c311/lib/exe/fetch.php?media=cps-notes.scm">cps变换教程</a></li>
<li><a href="http://www.ece.uc.edu/~franco/C511/html/Scheme/ycomb.html">Y combinator推导</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[From Little Scheme to Season Scheme]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2017/08/11/from-little-scheme-to-season-scheme/"/>
    <updated>2017-08-11T23:01:17+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2017/08/11/from-little-scheme-to-season-scheme</id>
    <content type="html"><![CDATA[<p>The Little Scheme(TLS) 提出了<a href="#rember">rember</a>,<a href="#multirember">multirember</a>,<a href="#mrs">multirember*</a>以及<a href="#mrsc">multirember&amp;Col collector</a>等系列函数的定义，而在The Season  Scheme(TSS) 进一步改进了rember系列函数，
使用<a href="#rlet">let</a>、<a href="#rletrec">letrec</a>、<a href="#rletcc">letcc</a>进行改写，并结合leftmost和deep函数的想法，又提出了<a href="#rs">rember*</a>的函数，该函数表示删除最左边的函数。在此过程中，剖析每一个简单的函数(并由此带来<strong>智趣</strong>)，
并进行改进，升级，提炼，从中可以体味到<a href="http://blog.sina.com.cn/s/blog_bffd70da0101f4sl.html">华罗庚老先生</a>说的"书越读越薄，并积厚薄书"的感觉,从繁杂中感受直观的本质，
借以理解事物，从另外一个角度看待事物。</p>

<ul>
<li><a href="#TLS">一、The Little Scheme</a>

<ul>
<li><a href="#rember">rember</a></li>
<li><a href="#multirember">multirember</a></li>
<li><a href="#mrs">multiremberStar</a></li>
<li><a href="#mrsc">multiremberStarCol</a></li>
</ul>
</li>
<li><a href="#TSS">二、The Season Scheme</a>

<ul>
<li><a href="#rlet">rember-let</a></li>
<li><a href="#rletrec">rember-letrec</a></li>
<li><a href="#rletcc">rember-letcc</a></li>
<li><a href="#rs">rember star</a></li>
<li><a href="#di">depthStar improvement</a></li>
</ul>
</li>
</ul>


<!--more-->




<h2 id="TLS"> 一、The Little Scheme </h2>


<hr/>


<p>scheme的核心数据结构是List，通过list进行算法的演算，而rember是其中的一种算法，用于去除其中的一个元素。
并在rember的同级函数中，也定义了subst，member，insert left, insert right等。在TLS书中也提出了这些函数的相同之处并最终使用insert-g来统一各个函数，这是不错的思想。</p>

<h3 id="rember">1.1 rember </h3>


<p>``` scheme
(define rember-f
  (lambda (test?)</p>

<pre><code>      (lambda (a lat)
        (cond
          ((null? lat) '())
          ((test? a (car lat))
           (cdr lat))
          (else
           (cons (car lat)
                 ((multirember-f test?) a (cdr lat))))))))
</code></pre>

<p>```</p>

<p>Another related procedures:</p>

<p>``` scheme
(define insertL
  (lambda (new old lat)</p>

<pre><code>(cond
  ((null? lat)
   '())
  ((eq? (car lat) old)
   (cons new (cons old (cdr lat))))
  (else
   (cons new (insertL new old (cdr lat)))))))
</code></pre>

<p>(define insertLR
  (lambda (new oldL oldR lat)</p>

<pre><code>(cond
  ((null? lat)
   '())
  ((eq? (car lat) oldL)
   (cons new (cons oldL (cdr lat))))
  ((eq? (car lat) oldR)
   (cons oldR (cons new (cdr lat))))
  (else
   (cons (car lat) (insertLR new oldL oldR (cdr lat)))))))
</code></pre>

<p>```</p>

<p>进一步可以参考 <a href="http://jueqingsizhe66.github.io/blog/2015/05/18/the-little-scheme-and-part-of-tss/">TLS and TSS Backup</a></p>

<hr/>


<p>为了更进一步删除一个列表(未嵌套多个list)时候所有的元素(定义为lat version)</p>

<h3 id="multirember">1.2 multirember </h3>


<p>``` scheme
(define multirember-f
  (lambda (test?)</p>

<pre><code>      (lambda (a lat)
        (cond
          ((null? lat) '())
          ((test? a (car lat))
           ((multirember-f test?) a (cdr lat)))
          (else
           (cons (car lat)
                 ((multirember-f test?) a (cdr lat))))))))
</code></pre>

<p>```</p>

<p>Another related procedures:</p>

<p>``` scheme
(define multiinsertLR
  (lambda (new oldL oldR lat)</p>

<pre><code>(cond
  ((null? lat)
   '())
  ((eq? (car lat) oldL)
   (cons new (cons oldL (multiinsertLR new oldL oldR (cdr lat)))))
  ((eq? (car lat) oldR)
   (cons oldR (cons new (multiinsertLR new oldL oldR (cdr lat)))))
  (else
   (cons (car lat) (multiinsertLR new oldL oldR (cdr lat)))))))
</code></pre>

<p>;(insertL &lsquo;a 'b &rsquo;(a b c (a b c)))
;&lsquo;(a a b c (a b c))</p>

<p>;(insertLR &lsquo;water 'a 'b &rsquo;(a bc b c d (a c b)))
;&lsquo;(water a bc b c d (a c b))</p>

<p> (multiinsertLR &lsquo;water 'a 'b &rsquo;(a b c d a b (a b c d)))
&lsquo;(water a b water c d water a b water (a b c d))</p>

<blockquote><p>(insertLR &lsquo;water 'a 'b &rsquo;(a b c d a b (a b c d)))
&lsquo;(water a b c d a b (a b c d))
```</p></blockquote>

<hr/>


<h3 id="mrs">1.3 multirember* </h3>


<p>``` scheme
(define multiinsertLR*
  (lambda (new oldL oldR lat)</p>

<pre><code>(define atom?
  (lambda (x)
    (and  (not (pair? x)) (not (null? x)))))
(cond
  ((null? lat)
   '())
  ((atom? (car lat))
   (cond 
     ((eq? (car lat) oldL)
      (cons new (cons oldL (multiinsertLR* new oldL oldR (cdr lat)))))
     ((eq? (car lat) oldR)
      (cons oldR (cons new (multiinsertLR* new oldL oldR (cdr lat)))))
     (else
      (cons (car lat) (multiinsertLR* new oldL oldR (cdr lat))))))
  (else
   (cons (multiinsertLR* new oldL oldR (car lat))
         (multiinsertLR* new oldL oldR (cdr lat)))))))
</code></pre>

<p>(define evens-only*
  (lambda (l)</p>

<pre><code>(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))
(cond
  ((null? l) '())
  ((atom? (car l))
   (cond
     ((even? (car l))
      (cons (car l) (evens-only* (cdr l))))
     (else (evens-only* (cdr l)))))
  (else
   (cons (evens-only* (car l))
         (evens-only* (cdr l)))))))
</code></pre>

<blockquote><p>(multiinsertLR* &lsquo;water 'a 'b &rsquo;(a b c d a b (a b c d)))
&lsquo;(water a b water c d water a b water (water a b water c d))
(multiinsertLR 'water 'a 'b &rsquo;(a b c d a b (a b c d)))
&lsquo;(water a b water c d water a b water (a b c d))</p></blockquote>

<p>```</p>

<p>Another related procedures:</p>

<p>``` scheme</p>

<p>(define multiinsertLR*let
  (lambda (new oldL oldR lat)</p>

<pre><code>(define atom?
  (lambda (x)
    (and  (not (pair? x)) (not (null? x)))))
(cond
  ((null? lat)
   '())
  ((atom? (car lat))
    (let ((rest (multiinsertLR* new oldL oldR (cdr lat))))
      (cond        
        ((eq? (car lat) oldL)
         (cons new (cons oldL rest)))
        ((eq? (car lat) oldR)
         (cons oldR (cons new rest)))
        (else
         (cons (car lat) rest)))))
  (else
   (let ((first (multiinsertLR* new oldL oldR (car lat)))
         (rest (multiinsertLR* new oldL oldR (cdr lat))))
   (cons first rest))))))
</code></pre>

<p>(define multiinsertLR*letrec
  (lambda (new oldL oldR lat)</p>

<pre><code>(define atom?
  (lambda (x)
    (and  (not (pair? x)) (not (null? x)))))
(define mul-help
  (lambda (lat)       
    (cond
      ((null? lat)
       '())
      ((atom? (car lat))
       (cond 
         ((eq? (car lat) oldL)
          (cons new (cons oldL (mul-help  (cdr lat)))))
         ((eq? (car lat) oldR)
          (cons oldR (cons new (mul-help  (cdr lat)))))
         (else
          (cons (car lat) (mul-help  (cdr lat))))))
      (else
       (cons (mul-help  (car lat))
             (mul-help  (cdr lat)))))))
(mul-help lat)))
</code></pre>

<blockquote><p>(multiinsertLR<em>let &lsquo;water 'a 'b &rsquo;(a b c d a b (a b c d)))
&lsquo;(water a b water c d water a b water (water a b water c d))
(multiinsertLR</em> 'water 'a 'b &rsquo;(a b c d a b (a b c d)))
&lsquo;(water a b water c d water a b water (water a b water c d))
(multiinsertLR 'water 'a 'b &rsquo;(a b c d a b (a b c d)))
&lsquo;(water a b water c d water a b water (a b c d))</p></blockquote>

<p>(multiinsertLR*letrec &lsquo;water 'a 'b &rsquo;(a b c d a b (a b c d)))
&lsquo;(water a b water c d water a b water (water a b water c d))</p>

<p>(define multiinsertLR*letreclet
  (lambda (new oldL oldR lat)</p>

<pre><code>(define atom?
  (lambda (x)
    (and  (not (pair? x)) (not (null? x)))))
(define mul-help
  (lambda (lat)       
    (cond
      ((null? lat)
       '())
      ((atom? (car lat))
       (let ((rest (mul-help  (cdr lat))))
       (cond 
         ((eq? (car lat) oldL)
          (cons new (cons oldL rest)))
         ((eq? (car lat) oldR)
          (cons oldR (cons new rest)))
         (else
          (cons (car lat) rest)))))
      (else
       (let ((first (mul-help  (car lat)))
             (rest (mul-help  (cdr lat))))
       (cons first rest))))))
(mul-help lat)))
</code></pre>

<p>(multiinsertLR*letreclet &lsquo;water 'a 'b &rsquo;(a b c d a b (a b c d)))
&lsquo;(water a b water c d water a b water (water a b water c d))</p>

<p>```</p>

<hr/>


<h3 id="mrsc">1.4 multiremberstar and collector </h3>


<p>``` scheme</p>

<p>(define multirember*co
  (lambda (a lat col)</p>

<pre><code>(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))
(cond
  (( null? lat)
   (col (quote ()) (quote ())))
  ((atom? (car lat))
   (cond
     ((eq? ( car lat) a)
     (multirember*co a (cdr lat)
                    (lambda ( newlat seen)
                      (col newlat (cons (car lat)
                                        seen)))))
   (else
    (multirember*co a (cdr lat)
                   (lambda (newlat seen)
                     (col (cons (car lat) newlat) seen))))))
  (else
   (multirember*co a (car lat)
                   (lambda (al as)
                     (multirember*co a (cdr lat)
                                     (lambda (dl ds)
                                       (col (cons al dl)
                                            (cons as ds))))))))))
</code></pre>

<p>```</p>

<p>Another related procedures:</p>

<p>``` scheme</p>

<p>(define col
   (lambda (x y)</p>

<pre><code>  (null? y)))
</code></pre>

<p>(define a-friend
   (lambda (x y)</p>

<pre><code>  (length x)))
</code></pre>

<p>(define a-friend-y
   (lambda (x y)</p>

<pre><code>  (length y)))
</code></pre>

<p>(define a-friend-z
   (lambda (x y)</p>

<pre><code>  (cons x (cons y '()))))
</code></pre>

<p>(define a-friend-zp
   (lambda (x y z)</p>

<pre><code>  (cons x (cons y (cons z '())))))
</code></pre>

<p>(define evens-only*col
  (lambda (l col)</p>

<pre><code>(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))
(cond
  ((null? l) (col '() 1 0))
  ((atom? (car l))
   (cond
     ((even? (car l))
      (evens-only*col (cdr l)
                      (lambda (newlat L R)
                        (col (cons (car l) newlat) (* (car l) L) R))))
     (else (evens-only*col (cdr l) (lambda (newlat L R)
                                  (col newlat L
                                       (+ (car l) R)))))))
  (else
   (evens-only*col (car l)
                   (lambda (al ale ari)
                     (evens-only*col (cdr l)
                                     (lambda (dl dle dri)
                                       (col (cons al dl)
                                            (* ale dle)
                                            (+ ari dri))))))))))
</code></pre>

<p>(define multiinsertLRo
  (lambda (new oldL oldR lat col)</p>

<pre><code>(cond
  ((null? lat) (col '() 0 0))
  ((eq? (car lat) oldL)
   (multiinsertLRo new oldL oldR (cdr lat)
                   (lambda (newlat L R)
                     (col (cons new (cons oldL newlat))
                          (+ L 1) R))))
  ((eq? (car lat) oldR)
   (multiinsertLRo new oldL oldR (cdr lat)
                   (lambda (newlat L R)
                     (col (cons oldR (cons new newlat))
                          L (+ R 1)))))
  (else
   (multiinsertLRo new oldL oldR (cdr lat)
                   (lambda (newlat L R)
                     (col (cons (car lat) newlat)
                          L
                          R)))))))
</code></pre>

<p>(define multiinsertLR*o
  (lambda (new oldL oldR lat col)</p>

<pre><code>(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))
(cond
  ((null? lat) (col '() 0 0))
  ((atom? (car lat))
   (cond
     ((eq? (car lat) oldL)
      (multiinsertLR*o new oldL oldR (cdr lat)
                      (lambda (newlat L R)
                        (col (cons new (cons oldL newlat))
                             (+ L 1) R))))
     ((eq? (car lat) oldR)
      (multiinsertLR*o new oldL oldR (cdr lat)
                      (lambda (newlat L R)
                        (col (cons oldR (cons new newlat))
                             L (+ R 1)))))
     (else
      (multiinsertLR*o new oldL oldR (cdr lat)
                      (lambda (newlat L R)
                        (col (cons (car lat) newlat)
                             L
                             R))))))
  (else
   (multiinsertLR*o new oldL oldR (car lat)
                    (lambda (al ale ari)
                      (multiinsertLR*o new oldL oldR (cdr lat)
                                       (lambda (dl dle dri)
                                         (col (cons al dl)
                                              (+ ale dle)
                                              (+ ari dri))))))))))
</code></pre>

<p>```</p>

<hr/>


<h2 id="TSS"> 二、The Season Scheme </h2>




<hr/>


<p>由<a href="#member">member</a>和rember又可以深入进行剖析，于是引进了member的升级版本two-in-a-lat,未包含TSS的最后一个two-in-a-lat的实现，并通过let,letrec,letcc改写TLS中的rember系列函数，在结合<a href="#lm">leftmost</a>和<a href="#deep">deep(Later on,deep有两外一层意思就是产生n层的pizza)</a>函数，升级rember到删除最左边的一个元素。</p>

<p>Member实际上在所有的函数的实现中都有对应的组成，他是一个十分重要的组成部分，包括基于member的<a href="#union">union</a>,<a href="#intersect">intersect</a>,<a href="#intersectall">intersectall</a>函数的，一个相对基础的函数。</p>

<h4 id="member">the  definition of member</h4>


<p>``` scheme
(define member?
  (lambda (a lat)</p>

<pre><code>(cond
  ((null? lat) #f)
  (else
   (or (eq? a (car lat))
       (member a (cdr lat)))))))
</code></pre>

<p>; member-letrec version
(define member?
  (lambda (a l)</p>

<pre><code>(letrec
  ((yes? (lambda (l)
           (cond
             ((null? l) #f)
             ((eq? (car l) a) #t)
             (else (yes? (cdr l)))))))
  (yes? l))))
</code></pre>

<p>```</p>

<p>现在让我们看看two-in-a-lat的引申(通过member)</p>

<h4 id="two">Two -in -a -lat</h4>


<p>包含two-in-a-lat(用member2代替),并附加sum-of-prefix和scramble函数的实现，目的是说如果你想让函数知道额外的信息，可以通过增加参数的方法。</p>

<p>``` scheme
(define member-letrec-ju?
  (lambda (a lat)</p>

<pre><code>(letrec ((yes? (lambda (l)
                (cond
                  ((null? l) #f)
                  (else
                   (or (eq? a (car l))
                       (yes? a (cdr l))))))))
  (yes? lat))))
</code></pre>

<p>(define member2?
  (lambda (preceding lat)</p>

<pre><code>(cond
  ((null? lat) #f)
  (else (or (eq? preceding (car lat))
            (member2? (car lat) (cdr lat)))))))
</code></pre>

<p>;;; (member2? &lsquo;a &rsquo;(a b c))  bugs!</p>

<p>(define memberContinue?
  (lambda (lat)</p>

<pre><code>(define M2?
  (lambda (preceding lat)
    (cond
      ((null? lat) #f)
      (else (or (eq? preceding (car lat))
                (M2? (car lat) (cdr lat)))))))
(M2? '() lat)))
</code></pre>

<p>(define memberContinueAlter?
  (lambda (lat)</p>

<pre><code>(letrec ((M2? (lambda (preceding lat)
                (cond
                  ((null? lat) #f)
                  (else
                   (let ((pre (car lat)))
                     (or (eq? preceding pre)
                            (M2? pre (cdr lat)))))))))
         (M2? '() lat))))
</code></pre>

<p>(define sum-of-prefixes
  (lambda (tup)</p>

<pre><code>(define sum-of-prefixes-b
  (lambda (sonssf tup)     ; sonssf stands for 'sum of numbers seen so far'
    (cond
      ((null? tup) '())
      (else (cons (+ sonssf (car tup))
                  (sum-of-prefixes-b
                   (+ sonssf (car tup))
                   (cdr tup)))))))
(sum-of-prefixes-b 0 tup)))
</code></pre>

<p>;  (sum-of-prefixes &lsquo;(1 2 3 4))
; &rsquo;(1 3 6 10)</p>

<p>(define sum-of-prefixes1
  (lambda (tup)</p>

<pre><code>(letrec
  ((S (lambda (sss tup)
        (cond
          ((null? tup) '())
          (else
           (let ((first (car tup)))
            (cons (+ sss first)
                  (S (+ sss first) (cdr tup)))))))))
</code></pre>

<p>(S 0 tup))))</p>

<p>(define scramble-b
  (lambda (tup rev-pre)</p>

<pre><code>(define one?
  (lambda (n)
    (= n  1)))
(define sub1
  (lambda (n)
    (- n 1)))
(define pick
  (lambda (n lat)
    (cond
      ((one? n) (car lat))
      (else (pick (sub1 n) (cdr lat))))))
(cond
  ((null? tup) '())
  (else
   (cons (pick (car tup) (cons (car tup) rev-pre))
         (scramble-b (cdr tup)
                     (cons (car tup) rev-pre)))))))
</code></pre>

<p>(define scramble
  (lambda (tup)</p>

<pre><code>(letrec ((scramble-b
          (lambda (tup rev-pre)
            (define one?
              (lambda (n)
                (= n  1)))
            (define sub1
              (lambda (n)
                (- n 1)))
            (define pick
              (lambda (n lat)
                (cond
                  ((one? n) (car lat))
                  (else (pick (sub1 n) (cdr lat))))))
            (cond
              ((null? tup) '())
              (else
               (let ((first (car tup)))
                 (cons (pick first (cons first rev-pre))
                 (scramble-b (cdr tup)
                             (cons first rev-pre)))))))))
  (scramble-b tup '()))))
</code></pre>

<p>(define scramble2
  (lambda (tup)</p>

<pre><code>(letrec ((one?
          (lambda (n)
            (= n  1)))
         (sub1
          (lambda (n)
            (- n 1)))
         (pick
          (lambda (n lat)
            (cond
              ((one? n) (car lat))
              (else (pick (sub1 n) (cdr lat))))))
         (scramble-b
          (lambda (tup rev-pre)
            (cond
              ((null? tup) '())
              (else
               (let ((first (car tup)))
                 (cons (pick first (cons first rev-pre))
                       (scramble-b (cdr tup)
                                   (cons first rev-pre)))))))))
  (scramble-b tup '()))))
</code></pre>

<p>```</p>

<hr/>




<h3 id="rlet">2.1 rember-let </h3>


<p>Note: use let to define the repeated expression, so simplify the definition of the procedure.</p>

<hr/>




<h3 id="rletrec">2.2 rember-letrec </h3>


<p>``` scheme</p>

<p>;;; see at the TSS
(define rember
  (lambda (a lat)</p>

<pre><code>(letrec
    ((R (lambda (lat)
          (cond
            ((null? lat) '())
            ((eq? (car lat) a) (cdr lat))
            (else
             (cons (car lat) (R (cdr lat))))))))
  (R lat))))
</code></pre>

<p>```</p>

<hr/>


<p>如果我们想要进一步实现<a href="#rbf">rember-beyond-first</a>(保留删除元素之前的所有元素)和<a href="#rul">rember-upto-last</a>(只保留删除元素之后的元素)</p>

<h3 id="rletcc">2.3 rember-letcc </h3>




<h4 id="rbf">Rember-Beyond-first</h4>


<p>``` scheme
; The rember-beyond-first function rembers everything beyond first match
;
(define rember-beyond-first
  (lambda (a lat)</p>

<pre><code>(letrec
  ((R (lambda (lat)
        (cond
          ((null? lat) '())
          ((eq? (car lat) a) '())
          (else
            (cons (car lat) (R (cdr lat))))))))
  (R lat))))
</code></pre>

<p>```</p>

<p><code>
(rember-beyond-first
  'roots
  '(noodles spaghetti spatzle bean-thread roots potatoes yam others rice))
; ==&gt; '(noodles spaghetti spaghetti bean-thread)
</code></p>

<hr/>




<h4 id="rul">Rember-upto-last</h4>


<p>``` scheme
(define-syntax letcc
  (syntax-rules ()</p>

<pre><code>((letcc ?k ?body ...)
 (call/cc (lambda (?k) ?body ...)))))
</code></pre>

<p>(define rember-upto-last
  (lambda (a lat) ; Look Ma, no cons</p>

<pre><code>(letcc skip
  (letrec 
      ((R
        (lambda (l)
          (cond
            ((null? l) (void))
            (else (let ()
                    (R (cdr l))
                    (cond
                      ((eq? a (car l))
                       (skip (cdr l)))
                      (else (void)))))))))
    (R lat)
    lat))))
</code></pre>

<p>```</p>

<p><code>
(rember-upto-last
  'roots
  '(noodles spaghetti spatzle bean-thread roots potatoes yam others rice))
; ==&gt; '(potatoes yam others rice)
</code></p>

<hr/>




<h3 id="rs">2.4 remberstar </h3>




<h4 id="lm">the  definition of leftmost</h4>


<p>``` scheme
(define leftmost-fixed-let
  (lambda (l)</p>

<pre><code>(cond
  ((null? l) '())
  ((atom? (car l)) (car l))
  (else
   (let ((a (leftmost-fixed (car l))))
     (cond
       ((atom? a) a)
       (else (leftmost-fixed (cdr l)))))))))
</code></pre>

<p>;(leftmost-fixed-let &lsquo;((() a b) (c d))) ;; bug fixed
;
;(leftmost-fixed-let &rsquo;(((y) b) (c d)))   ; &lsquo;y
;(leftmost-fixed-let &rsquo;(((y) ()) () (e))) ; &lsquo;y
;(leftmost-fixed-let &rsquo;(((() y) ())))     ; &lsquo;y
;(leftmost-fixed-let &rsquo;(((()) ()))) ; &lsquo;()</p>

<p>;;letcc version</p>

<p>(define leftmost-letcc
  (letrec</p>

<pre><code>  ((lm (lambda (l out)
         (cond
           ((null? l) '())
           ((atom? (car l)) (out (car l)))
           (else
            (begin
              (lm (car l) out)
              (lm (cdr l) out)))))))
(lambda (l)
  (call-with-current-continuation
   (lambda (skip)
     (lm l skip))))))
</code></pre>

<p>```</p>

<hr/>




<h4 id="deep">the  definition of deep</h4>


<p>``` scheme
(define deep
  (lambda (m)</p>

<pre><code>(cond
  ((zero? m) 'pizza)
  (else (cons (deep (sub1 m)) '())))))
</code></pre>

<p>(define toppings 0)
(define deepB
  (lambda (m)</p>

<pre><code>(cond
  ((zero? m)
   (call-with-current-continuation
    (lambda (jump)
      (set! toppings jump)
      'pizza)))
  (else
   (cons (deepB (sub1 m)) '())))))
</code></pre>

<p>(define deep&amp;co
  (lambda (m k)</p>

<pre><code>(cond
  ((zero? m) (k 'pizza))
  (else
   (deep&amp;co (sub1 m)
            (lambda (x) (k (cons x '()))))))))
</code></pre>

<p>(deep&amp;co 0 (lambda (x) x))          ; &lsquo;pizza
(deep&amp;co 6 (lambda (x) x))          ; &rsquo;((((((pizza))))))
(deep&amp;co 2 (lambda (x) x)) ; &lsquo;((pizza))</p>

<p>(define deep&amp;coB
  (lambda (m k)</p>

<pre><code>(cond
  ((zero? m)
   (let ()
     (set! toppings k)
     (k 'pizza)))
  (else
   (deep&amp;coB (sub1 m)
             (lambda (x)
               (k (cons x '()))))))))
</code></pre>

<p>(deep&amp;coB 6 (lambda (x) x))         ; &lsquo;((((((pizza))))))
(deep&amp;coB 4 (lambda (x) x)) ; &rsquo;((((pizza))))
```</p>

<hr/>


<p>接下来，再看看由leftmost结合rember得到rember star.</p>

<p>``` scheme</p>

<p>; The rember1<em> function removes the leftmost occurrence of a in l
;
(define rember1</em>
  (lambda (a l)</p>

<pre><code>(cond
  ((null? l) '())
  ((atom? (car l))
   (cond
     ((eq? (car l) a) (cdr l))
     (else
       (cons (car l) (rember1* a (cdr l))))))
  (else
    (cond
      ((equal? (rember1* a (car l)) (car l)) ; if the list with 'a' removed doesn't change
       (cons (car l) (rember1* a (cdr l))))  ; then recurse
      (else
        (cons (rember1* a (car l)) (cdr l)))))))) ; otherwise remove 'a'
</code></pre>

<p>```</p>

<p>```
; Examples of rember1<em>
;
(rember1</em>
  &lsquo;salad
  &rsquo;((Swedish rye) (French (mustard salad turkey)) salad))
; ==> &lsquo;((Swedish rye) (French (mustard turkey)) salad)</p>

<p>(rember1*
  &lsquo;meat
  &rsquo;((pasta meat) pasta (noodles meat sauce) meat tomatoes))
; ==> &lsquo;((pasta) pasta (noodles meat sauce) meat tomatoes)</p>

<p>```</p>

<p>下面是letrec version of rember1*
```
(define rember1*-letrec
  (lambda (a l)</p>

<pre><code>(letrec
    ((R (lambda (l)
          (cond
            ((null? l) '())
            ((atom? (car l))
             (let ((first (car l))
                   (second (cdr l)))
               (cond
                 ((eq? first a) second)
                 (else
                  (cons first (R second))))))
             (else
              (let ((first (car l))
                    (second (cdr l)))
                (cond
                  ((equal? (R first) first) ; if the list with 'a' removed doesn't change
                   (cons first (R second)))  ; then recurse
                  (else
                   (cons (R first) second))))))))) ; otherwise remove 'a'
  (R l))))
</code></pre>

<p>(rember1<em>-letrec
  &lsquo;salad
  &rsquo;((Swedish rye) (French (mustard salad turkey)) salad))
(rember1</em>-letrec
  &lsquo;meat
  &rsquo;((pasta meat) pasta (noodles meat sauce) meat tomatoes))</p>

<p>```</p>

<p>the version of letcc (我暂时不太理解)</p>

<p>```
; rember1<em> via letcc
;
(define rember1</em>-letcc
  (lambda (a l)</p>

<pre><code>(letrec
    ((rm (lambda (a l oh)
           (cond
             ((null? l) (oh 'no))
             ((atom? (car l))
              (if (eq? (car l) a)
                  (cdr l)
                  (cons (car l) (rm a (cdr l) oh))))
             (else
              (let ((new-car
                     (call-with-current-continuation
                      (lambda (oh)
                        (rm a (car l) oh)))))
                (if (atom? new-car)
                    (cons (car l) (rm a (cdr l) oh))
                    (cons new-car (cdr l)))))))))
  (let ((new-l
         (call-with-current-continuation
          (lambda (oh)
            (rm a l oh)))))
    (if (atom? new-l)
        l
        new-l)))))
</code></pre>

<p>; Tests of rember1<em>-letcc
;
(rember1</em>-letcc
 &lsquo;salad
 &rsquo;((Swedish rye) (French (mustard salad turkey)) salad))
; ==> &lsquo;((Swedish rye) (French (mustard turkey)) salad)</p>

<p>(rember1*-letcc
 &lsquo;meat
 &rsquo;((pasta meat) pasta (noodles meat sauce) meat tomatoes))
; ==> &lsquo;((pasta) pasta (noodles meat sauce) meat tomatoes)</p>

<p>(rember1*-letcc
 &lsquo;a
 &rsquo;((foo bar) baz))
; ==> &lsquo;((foo bar) baz)</p>

<p>```</p>

<hr/>




<h4 id="union">the  definition of union</h4>


<p>``` scheme
(define union2
  (lambda (set1 set2)</p>

<pre><code>(letrec ((member? (lambda (a lat)
            (cond ((null? lat) #f)
                          ((eq? a (car lat)) #t)
                          (else (member? a (cdr lat))))))
         (A (lambda (set1)
            (cond
              ((null? set1) set2)
              (else
               (let ((p1 (A (cdr set1))))
                 (if (member? (car set1) set2)
                     p1
                     (cons (car set1) p1))))))))
  (A set1))))
  (union2 '(a b c) '(c d e f))
</code></pre>

<p>```</p>

<hr/>




<h4 id="intersect">the  definition of intersect</h4>


<p>``` scheme
(define intersect
  (lambda (set1 set2)</p>

<pre><code>(cond
  ((null? set1) '())  ; don't forget the 1st commandment
  ((member? (car set1) set2)
   (cons (car set1) (intersect (cdr set1) set2)))
  (else
    (intersect (cdr set1) set2)))))
</code></pre>

<p>```</p>

<p><code>
; Examples of intersect
;
;(intersect '(a b x c d) '(q w e x r t y a))     ; '(a x)
;(intersect '(a b x c d) '())                    ; '()
;(intersect '() '())                             ; '()
;(intersect '() '(a b x c d))                    ; '()
;(intersect '(a b x c d) '(a b x c d))           ; '(a b x c d)
</code></p>

<p>intersect letrec version</p>

<p><font color="red">use letrec to remove arguments that do not change for recursive applications</font></p>

<p>``` scheme
(define intersect-letrec
  (lambda (set1 set2)</p>

<pre><code>(letrec
  ((I (lambda (set)
        (cond
          ((null? set) '())
          ((member? (car set) set2)
           (cons (car set) (I (cdr set))))
          (else
            (I (cdr set)))))))
  (I set1))))
</code></pre>

<p>; Test of intersect-letrec
;
;(intersect-letrec &lsquo;(a b x c d) &rsquo;(q w e x r t y a))     ; &lsquo;(a x)
;(intersect-letrec &rsquo;(a b x c d) &lsquo;())                    ; &rsquo;()
;(intersect-letrec &lsquo;() &rsquo;())                             ; &lsquo;()
;(intersect-letrec &rsquo;() &lsquo;(a b x c d))                    ; &rsquo;()
;(intersect-letrec &lsquo;(a b x c d) &rsquo;(a b x c d))           ; &lsquo;(a b x c d)
```</p>

<hr/>




<h4 id="intersectall">the  definition of intersectall</h4>


<p>``` scheme
; The intersectall function finds intersect of a bunch of sets
;
(define intersectall
  (lambda (lset)</p>

<pre><code>(cond
  ((null? lset) '())
  ((null? (cdr lset)) (car lset))
  (else
    (intersect (car lset)
               (intersectall (cdr lset)))))))
</code></pre>

<p>; Examples of intersectall
;
;(intersectall &lsquo;((a) (a) (a)))                   ; &rsquo;(a)
;(intersectall &lsquo;((a) () (a)))                    ; &rsquo;()
;(intersectall &lsquo;())                              ; &rsquo;()
;(intersectall &lsquo;((a b c d) (b c d e) (c d e f))) ; &rsquo;(c d)</p>

<p>; Obeying the 12th commandment
;
(define intersectall-letrec
  (lambda (lset)</p>

<pre><code>(letrec
  ((A (lambda (lset)
        (cond
          ((null? (cdr lset)) (car lset))
          (else
            (intersect (car lset)
                       (A (cdr lset))))))))
  (cond
    ((null? lset) '())
    (else (A lset))))))
</code></pre>

<p>; Tests of intersectall-letrec
;;
;(intersectall-letrec &lsquo;((a) (a) (a)))                   ; &rsquo;(a)
;(intersectall-letrec &lsquo;((a) () (a)))                    ; &rsquo;()
;(intersectall-letrec &lsquo;())                              ; &rsquo;()
;(intersectall-letrec &lsquo;((a b c d) (b c d e) (c d e f))) ; &rsquo;(c d)</p>

<p>(define intersectall-ap
  (lambda (lset)</p>

<pre><code>(call-with-current-continuation
  (lambda (hop)
    (letrec
      ((A (lambda (lset)
            (cond
              ((null? (car lset)) (hop '()))
              ((null? (cdr lset)) (car lset))
              (else
                (I (car lset)
                   (A (cdr lset)))))))
       (I (lambda (s1 s2)
            (letrec
              ((J (lambda (s1)
                    (cond
                      ((null? s1) '())
                      ((member? (car s1) s2)
                       (cons (car s1) (J (cdr s1))))
                      (else
                        (J (cdr s1)))))))
              (cond
                ((null? s2) (hop '()))
                (else (J s1)))))))
      (cond
        ((null? lset) '())
        (else (A lset))))))))
</code></pre>

<p>; Tests of intersectall-ap
;
;(intersectall-ap &lsquo;((a) (a) (a)))                   ; &rsquo;(a)
;(intersectall-ap &lsquo;((a) () (a)))                    ; &rsquo;()
;(intersectall-ap &lsquo;())                              ; &rsquo;()
;(intersectall-ap &lsquo;((a b c d) (b c d e) (c d e f))) ; &rsquo;(c d)
```</p>

<p>最后再透过deep star的写法优化过程来体会TSS的函数精髓。</p>

<hr/>




<h3 id="di">depthStar improvement </h3>


<p>通过<a href="#depth">depth</a>进一步阐释letrec的意义（从原始的depth到<a href="#depthlet">depth-let</a>
然后<a href="#letif">depth-let-if</a>，以及更为清晰版本的<a href="#letmax">depth-let-max</a>,然后最后浓缩到最后的6行代码<a href="#max">depth-max</a>。</p>

<h4 id="depth">depth</h4>


<p>``` scheme
; The depth<em> function finds the max depth of an s-expression
;
(define depth</em>
  (lambda (l)</p>

<pre><code>(cond
  ((null? l) 1)
  ((atom? (car l)) (depth* (cdr l)))
  (else
    (cond
      ((&gt; (depth* (cdr l))
          (add1 (depth* (car l))))
       (depth* (cdr l)))
      (else
</code></pre>

<p>(add1 (depth* (car l)))))))))</p>

<p>(depth<em> &lsquo;((pickled) peppers (peppers pickled)))                          ; 2
(depth</em> &rsquo;(margarine ((bitter butter) (makes) (batter (bitter))) butter)) ; 4
(depth* &lsquo;(c (b (a b) a) a)) ; 3</p>

<p>```</p>

<p>let version:</p>

<h4 id="depthlet">depth-let</h4>


<p>``` scheme</p>

<p>(define depth*-let
  (lambda (l)</p>

<pre><code>(cond
  ((null? l) 1)
  ((atom? (car l)) (depth*-let (cdr l)))
  (else
   (let ((rightPart (depth*-let (cdr l)))
         (leftPart (add1 (depth*-let (car l)))))
     (cond
       ((&gt; rightPart
           leftPart)
        rightPart)
       (else
        leftPart)))))))
</code></pre>

<p>(depth<em>-let &lsquo;((pickled) peppers (peppers pickled)))                          ; 2
(depth</em>-let &rsquo;(margarine ((bitter butter) (makes) (batter (bitter))) butter)) ; 4
(depth*-let &lsquo;(c (b (a b) a) a)) ; 3
```</p>

<p>let-if version:</p>

<h4 id="letif">depth-let-if</h4>


<p>``` scheme
(define depth*-let-if
  (lambda (l)</p>

<pre><code>(cond
  ((null? l) 1)
  ((atom? (car l)) (depth*-let-if (cdr l)))
  (else
   (let ((rightPart (depth*-let-if (cdr l)))
         (leftPart (add1 (depth*-let-if (car l)))))
     (if (&gt; rightPart leftPart)
        rightPart
        leftPart))))))
</code></pre>

<p>(depth<em>-let-if &lsquo;((pickled) peppers (peppers pickled)))                          ; 2
(depth</em>-let-if &rsquo;(margarine ((bitter butter) (makes) (batter (bitter))) butter)) ; 4
(depth*-let-if &lsquo;(c (b (a b) a) a)) ; 3
```</p>

<p>depth-let-max version:</p>

<h4 id="letmax">depth-let-max</h4>


<p>``` scheme
define depth*-let-max
  (lambda (l)</p>

<pre><code>(cond
  ((null? l) 1)
  ((atom? (car l)) (depth*-let-max (cdr l)))
  (else
   (let ((rightPart (depth*-let-max (cdr l)))
         (leftPart (add1 (depth*-let-max (car l)))))
     (max rightPart leftPart))))))
</code></pre>

<p>(depth<em>-let-max &lsquo;((pickled) peppers (peppers pickled)))                          ; 2
(depth</em>-let-max &rsquo;(margarine ((bitter butter) (makes) (batter (bitter))) butter)) ; 4
(depth*-let-max &lsquo;(c (b (a b) a) a)) ; 3</p>

<p>```</p>

<p>depth-max version:</p>

<h4 id="max">depth-max</h4>


<p>``` scheme
(define depth*-max
  (lambda (l)</p>

<pre><code>(cond
  ((null? l) 1)
  ((atom? (car l)) (depth*-max (cdr l)))
  (else
     (max (depth*-max (cdr l)) (add1 (depth*-max (car l))))))))
</code></pre>

<p>(depth<em>-max &lsquo;((pickled) peppers (peppers pickled)))                          ; 2
(depth</em>-max &rsquo;(margarine ((bitter butter) (makes) (batter (bitter))) butter)) ; 4
(depth*-max &lsquo;(c (b (a b) a) a)) ; 3
```</p>

<hr/>


<p>常用链接，</p>

<ul>
<li><a href="http://jueqingsizhe66.github.io/blog/2016/02/14/si-ji-mo-si-de-le-yuan-schemers/">Scheme清单</a></li>
<li><a href="https://groups.google.com/forum/#!forum/racket-users">Google racket User group</a></li>
<li><a href="https://groups.google.com/forum/#!topic/racket-users/cPuTr8lrXCs">Gossip about the decision tree</a></li>
<li>GreghenderShoot 1970

<ul>
<li><a href="https://github.com/greghendershott">Github Repo</a></li>
<li><a href="https://github.com/greghendershott/fear-of-macros">Fear of macro</a> Tell us the history of macro, overcome the fear of macro</li>
<li><a href="https://github.com/greghendershott/frog">frog</a> one static website generator tool</li>
<li><a href="http://www.greghendershott.com/">His Website</a></li>
</ul>
</li>
<li>Tonyg

<ul>
<li><a href="https://github.com/tonyg?tab=repositories">Github Repo</a></li>
<li><a href="http://tonyg.github.io/racket-bitsyntax/">His opensource tools: Bitsyntax</a></li>
</ul>
</li>
<li><a href="https://botbot.me/freenode/racket/">racket freenote robot, Gossip Platform</a></li>
<li>Husk scheme

<ul>
<li><a href="https://github.com/justinethier/husk-scheme">husk repo</a></li>
<li><a href="http://justinethier.github.io/husk-scheme/manual/getting-started.html">husk get started</a></li>
</ul>
</li>
<li><a href="https://github.com/alaricsp/chicken-scheme">chicken scheme</a></li>
<li><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-2.html#%_toc_start">R5RS html file</a></li>
<li>root of lisp

<ul>
<li><a href="http://www.paulgraham.com/rootsoflisp.html">original site</a></li>
<li><a href="https://github.com/hlpp/scheme/tree/master/tests">define implement</a></li>
</ul>
</li>
</ul>


<p>BTW, one very good vim tips, you can use <a href="https://github.com/Shougo/vimfiler.vim">Vimfiler</a>, with shortkey <code>m and then r</code> to rename
the file in the editor page.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket Man Wanna Learn Datetype and Cases]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2017/05/30/racket-man-wanna-learn-datetype-and-cases/"/>
    <updated>2017-05-30T14:14:59+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2017/05/30/racket-man-wanna-learn-datetype-and-cases</id>
    <content type="html"><![CDATA[<p>无意中，想到了<a href="http://racket-lang.org/"> racket </a>，scheme家族中一员，那么亲切，lovely.</p>

<!--more-->


<p>``` racket</p>

<p>Welcome to Racket v6.9.</p>

<blockquote><p>(/ 66 2)
33
(/ 52.44 0.834493)
62.840551089104395
(/ 52.44 0.834493)-62
62.840551089104395
-62
(&ndash; (/ 52.44 0.834493) 62)
0.8405510891043946
(* (&ndash; (/ 52.44 0.834493) 62) 360)
302.59839207758205
exit;</p>

<h1>&lt;procedure:exit></h1>

<p>(exit)</p></blockquote>

<p>```</p>

<p>复习列表:</p>

<ol>
<li><a href="http://jueqingsizhe66.github.io/blog/2016/02/19/the-implementation-of-define-datetype/">datetype</a></li>
<li><a href="http://jueqingsizhe66.github.io/blog/2016/02/23/casesde-zuo-yong/">cases</a></li>
<li><a href="http://jueqingsizhe66.github.io/blog/2016/02/25/first-interpreter-from-eopl/">First Interpreter From EOPL</a></li>
<li><a href="http://jueqingsizhe66.github.io/blog/2016/02/27/the-second-interpreter-from-one/">The Second Interpreter from one</a></li>
<li><a href="http://jueqingsizhe66.github.io/blog/2016/02/27/the-third-interpreter-implementing-proc/">The third Interpreter with proc feature</a></li>
<li><a href="http://jueqingsizhe66.github.io/blog/2016/02/27/the-fourth-interpreter-about-the-traceproc/">the fourth Interpreter with traceproc feature</a></li>
<li><a href="http://jueqingsizhe66.github.io/blog/2016/02/28/the-fifth-interpreter-with-the-implementation-of-letrec-important/">The fifth Interpreter with letrec feature</a></li>
<li>Read the EOPL book</li>
</ol>


<p>Deadline: 2017-06-30</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[能真正教会你编程能力的是重写]]></title>
    <link href="http://jueqingsizhe66.github.io/blog/2016/04/15/neng-zhen-zheng-jiao-hui-ni-bian-cheng-neng-li-de-shi-zhong-xie/"/>
    <updated>2016-04-15T21:50:10+08:00</updated>
    <id>http://jueqingsizhe66.github.io/blog/2016/04/15/neng-zhen-zheng-jiao-hui-ni-bian-cheng-neng-li-de-shi-zhong-xie</id>
    <content type="html"><![CDATA[<p>写了很多的matlab，感觉就那样！
编了那么多数值fortran代码，也不见自己编程有多厉害！
练了那么多的java项目，也感觉自己的技术还不见飞涨！
用c语言摸索了好几年，也没见得有太深的见地！</p>

<p>真正决定你对程序的深入理解，需要你去认识<a href="http://www.eopl3.com/">EOPL</a>或者<a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start">SICP</a>，亦或者更简单的<a href="http://www.ccs.neu.edu/home/matthias/BTLS/">TLS</a>.
他们也许不能教你们做大的项目，却真切教会你编写程序，思考程序。</p>

<!--more-->


<p>回想起之前写的java项目，反反复复就为了构造一门解释器语言，用来输送数据到数据库进行操作，不断
在中间进行验证，保证传递数据的有效性，为了搭上这样的一个平台，反复重构了代码，采用了新技术，
不断采用接口来抽象，割分具体的关系，防止数据的污染。</p>

<p>而这样做是为何？ 我之前没理解，后来做了一阶段程序语言设计方面的工作，写了多个解释器之后，我才发现总是基于
存在（任意）某一变量某一程序供你使用，你的目的就是使用这个程序或者变量来实现他的能力！然而为了懒惰，
你创建了很多工具（其实，应该是重构，重写）来不断让你的写的东西少点，同时能够达到更多的功能。</p>

<p>这过程不好经历，也不好做，很多人也很少做，有些人不需要做，更多人没想做。大部分的企业级程序也不会教你去实现这一过程，
也不会跟你从程序理论去介绍。架空程序理论，完成一系列的工程项目成为了很多人编程的主要目的。减少深入思考的时间，
追逐敏捷性编程方式，忽略了闲暇的编程时间，一味着实现需求，个人感觉不是一个好的归宿、目的、追求，但却是一种好的生活手段、工作方式、效率实现。</p>

<p>编程在我眼里是慢工出细活，所谓的快速开发的提出，我就不好奇，因为我不合适它。真正能够进一步提供自己对于写过程序理解，应该要自己能够写出一个解释器解释你写的程序，这个可以体现在<a href="http://www.ccs.neu.edu/home/matthias/BTLS/">TLS</a>,  <a href="http://www.ccs.neu.edu/home/matthias/BTSS/">TSS</a>  <a href="http://www.eopl3.com/">EOPL</a>,  <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start">SICP</a>等。</p>

<ol>
<li>let解释器</li>
<li>letrec解释器</li>
<li>proc解释器</li>
<li>state解释器</li>
<li>cps解释器</li>
<li>type解释器</li>
<li>oo解释器</li>
<li>typeoo解释器</li>
</ol>

]]></content>
  </entry>
  
</feed>
