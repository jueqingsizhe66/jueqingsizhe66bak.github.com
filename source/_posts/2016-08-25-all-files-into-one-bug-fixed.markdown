---
layout: post
title: "All Files into One bug fixed"
date: 2016-08-25 16:12:29 +0800
comments: true
categories: Linux
---

今天发现几篇使用[allFilesIntoFolds.sh][5]辅助生成的博文都出现了重复打印的内容，主要是因为sed输出的问题，是什么导致输出的时候变成了两行？？？

本文涉及:


+ [1. sed](#sed)
+ [2. vim插叙](#vim)
附带着shell字符串处理，cut命令和awk命令。


相关的sed资料如下所示:

<!--more-->

<h2 id="sed">Sed编程</h2>

The problem is shown below:

``` sh

$ sed 'p' exercises.pl
%% Chapter 1 - Exercises
%% Chapter 1 - Exercises
%%
%%
%% author: Peter Urbak
%% author: Peter Urbak
%% version: 2012-10-04
%% version: 2012-10-04

```

sed是一个很好的文件处理工具，本身是一个管道命令，主要是以行为单位进行处理，可以将数据行进行替换、删除、新增、选取等特定工作，下面先了解一下sed的用法
sed命令行格式为：
``` sh
         sed [-nefri] 'command' 输入文本    
```

常用选项：

```
选项        |                 说明
---------------------------------------------------------------------------------------------------------------------------------
-n        |          使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到萤幕上。但如果加上 -n 参数后，则只            |          有经过sed 特殊处理的那一行(或者动作)才会被列出来。

---------------------------------------------------------------------------------------------------------------------------------
-e          |          直接在指令列模式上进行 sed 的动作编辑；
---------------------------------------------------------------------------------------------------------------------------------

-f          |          直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的sed 动作；
---------------------------------------------------------------------------------------------------------------------------------

-r          |          sed 的动作支援的是延伸型正规表示法的语法。(预设是基础正规表示法语法)
---------------------------------------------------------------------------------------------------------------------------------

-i          |          直接修改读取的档案内容，而不是由萤幕输出。       
---------------------------------------------------------------------------------------------------------------------------------

```
常用命令(最好得使用过vim 并且熟练知道到[word字段操作、sentence句子操作、paragraph段落操作，以及局部括号操作][2]等：

```
选项        |              说明
---------------------------------------------------------------------------------------------------------------------------------
a           |        新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
---------------------------------------------------------------------------------------------------------------------------------
c           |        取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
---------------------------------------------------------------------------------------------------------------------------------
d           |        删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
---------------------------------------------------------------------------------------------------------------------------------
i           |        插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
---------------------------------------------------------------------------------------------------------------------------------
p           |        列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作～
---------------------------------------------------------------------------------------------------------------------------------
s           |        取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！
---------------------------------------------------------------------------------------------------------------------------------
```


<div align="center"><font color="red">所以如果我们加上`-n`选项，sed就不会连续打出两行了，即命令p一般是和选项`-n`一起使用的</font></div>
```


$ sed -n 'p' exercises.pl
%% Chapter 1 - Exercises
%%
%% author: Peter Urbak
%% version: 2012-10-04

%% Exercise 1.1

```

突然想起还有一个缺陷，也就是删去不该有的文件路径但是保留部分文件信息。比如(注意字符串截取的\*的位置 )

```

$ echo ${d*/}
exer.pl

$ echo ${d*/}
lpn/chapter-1/exer.pl

$ echo ${d%/*}
e/lpn/chapter-1

$ echo ${d%%/*}
e

```

如果使用cut,又只能获得一个字段
``` sh
$ echo $d|cut -d "/" -f2
lpn

$ echo $d|cut -d "/" -f3
chapter-1


$ echo $d|cut -d "/" -f3 -f4
cut: only one type of list may be specified
Try 'cut --help' for more information.

```

<hr/>

<h2 id="vim">vim插叙</h2>

以下内容为插叙，不重要，但是用vim写博客很重要。

vim中删除一行很简单，比如"dd",但是如何删除满足条件的一行，比如删除已708开头的一行(sed也很简单` sed '/^708/d' a.txt  `注意双斜杠之后)
当然sed也可以指定某行到某行之间删除`sed '1,/某个字符串/d' file.txt >result.txt `,1也可以替换成`/^708/` 的形式，也就是满足708开头的行。

所以vim就得查查[正则表达式][7],注意<font color="red">元字符</font>

```
元字符是具有特殊意义的字符。使用元字符可以表达任意字符、行首、行 尾、某几个字符等意义。

元字符一览

元字符                      	说明
---------------------------------------------------------------------------------------------
. 	                        匹配任意一个字符
---------------------------------------------------------------------------------------------
[abc] 	                    匹配方括号中的任意一个字符。可以使用-表示字符范围，
---------------------------------------------------------------------------------------------
                            如[a-z0-9]匹配小写字母和阿拉伯数字。
---------------------------------------------------------------------------------------------
[^abc] 	                    在方括号内开头使用^符号，表示匹配除方括号中字符之外的任意字符。
---------------------------------------------------------------------------------------------
\d 	                        匹配阿拉伯数字，等同于[0-9]。
---------------------------------------------------------------------------------------------
\D 	                        匹配阿拉伯数字之外的任意字符，等同于[^0-9]。
---------------------------------------------------------------------------------------------
\x 	                        匹配十六进制数字，等同于[0-9A-Fa-f]。
---------------------------------------------------------------------------------------------
\X                      	匹配十六进制数字之外的任意字符，等同于[^0-9A-Fa-f]。
---------------------------------------------------------------------------------------------
\w                      	匹配单词字母，等同于[0-9A-Za-z_]。
---------------------------------------------------------------------------------------------
\W                      	匹配单词字母之外的任意字符，等同于[^0-9A-Za-z_]。
---------------------------------------------------------------------------------------------
\t                      	匹配<TAB>字符。
---------------------------------------------------------------------------------------------
\s                      	匹配空白字符，等同于[ \t]。
---------------------------------------------------------------------------------------------
\S                      	匹配非空白字符，等同于[^ \t]。
---------------------------------------------------------------------------------------------

另外，如果要查找字符 *、.、/等，则需要在前面用 \ 符号，表示这不是元字符，而只是普通字符而已。
元字符 	说明

---------------------------------------------------------------------------------------------
\*                      	匹配 * 字符。
---------------------------------------------------------------------------------------------
\.                      	匹配 . 字符。
---------------------------------------------------------------------------------------------
\/                      	匹配 / 字符。
---------------------------------------------------------------------------------------------
\\                      	匹配 \ 字符。
---------------------------------------------------------------------------------------------
\[                      	匹配 [ 字符。
---------------------------------------------------------------------------------------------


表示数量的元字符

元字符                      	说明
-----------------------------------
* 	                        匹配0-任意个
-----------------------------------
\+ 	                        匹配1-任意个
-----------------------------------
\? 	                        匹配0-1个
-----------------------------------
\{n,m} 	                    匹配n-m个
-----------------------------------
\{n} 	                    匹配n个
-----------------------------------
\{n,} 	                    匹配n-任意个
-----------------------------------
\{,m} 	                    匹配0-m个
-----------------------------------


表示位置的符号

元字符 	                        说明
-------------------------------------------------
$ 	                        匹配行尾
-------------------------------------------------
^ 	                        匹配行首
-------------------------------------------------
\< 	                        匹配单词词首
-------------------------------------------------
\> 	                        匹配单词词尾
-------------------------------------------------


举例
/char\s\+[A-Za-z_]\w*;                 " 查找所有以char开头，之后是一个以上的空白，
                                             " 最后是一个标识符和分号
/\d\d:\d\d:\d\d                        " 查找如 17:37:01 格式的时间字符串
:g/^\s*$/d                             " 删除只有空白的行
:s/\<four\>/4/g                        " 将所有的four替换成4，但是fourteen中的four不替换
```

所以很简单的用vim完成满足某匹配的行
```
 删除以708开头的一整行,点号也叫做贪婪写法
:%s/^708.*//g
```

<hr/>

插叙完vim还得说明，在bash字符串截取和cut都不能满足题意的情况下，只能选用[awk][8]操作.

```
$ echo $d|awk -F'/' '{printf("%s/%s",$3,$4)}'
chapter-1/exer.pl

```

但是还有一个问题就是如何把awk的结果赋值给shell变量呢？

``` sh
var=`echo $d|awk -F"/" '{printf("%s/%s",$3,$4)}'`

```

于是我们得到一个比较完整的工具，

```

#!/bin/bash - 
#===============================================================================
#
#          FILE: browserNew.sh
# 
#         USAGE: ./browserNew.sh 
# 
#   DESCRIPTION: 
# 
#       OPTIONS: ---
#  REQUIREMENTS: ---
#          BUGS: ---
#         NOTES: ---
#        AUTHOR: Ye Zhaoliang (), zhaoturkkey@163.com
#  ORGANIZATION: YZL
#       CREATED: 2015年06月27日 15:19
#      REVISION:  ---
#===============================================================================

#---  FUNCTION  ----------------------------------------------------------------
#          NAME:  generateChapter
#   DESCRIPTION:  针对不同额文件采用不同的处理方法，判断目录 和判断脚本是一个重要的操作
#                 但是更为重要的是 find获得文集拿的绝对路径(相对于当前文件)
#    PARAMETERS:  
#       RETURNS:  
#-------------------------------------------------------------------------------

## Function definition 

generateChapter() # @Description : 对不同文件进行不同处理
                  # @usage       : generatechapter
{
    count=1;
    # 妙用find 得到当前目录的相对路径 不需要不断的进入目录
    for var in `find . -name "*"`
    do
        if [[ -d  $var ]] # < cannot . Error
        then
            echo "${currentDir}${var#.}是一个目录" # 使用#号来删除之前的点号
    # 为什么会想到使用 ${var##*/}因为var是一个相对当前文件的绝对路径，所以经过测试发现他和${0}等效如果截取到最大长度的/的话
        elif [[ "${var##*/}" == "${0}" ]] # 一定要注意等式两边有空格
        then
            echo "${currentDir}${var#.} ${0} 脚本文件不处理"
        else
            getFile ${currentDir}${var#.} $count # 这边需要去除到第一个点号,这是才得到的处理方法
            count=$(($count+1))
        fi

    done
}



#---  FUNCTION  ----------------------------------------------------------------
#          NAME:  getFile
#   DESCRIPTION:  在每个文件的头部添加一些信息
#    PARAMETERS:  
#       RETURNS:  
#-------------------------------------------------------------------------------
getFile() #@ Description: 细节处理  包括产生开头 产生边框等
          #@ Usage      : getFile
{
    tempVar=`echo $1|awk -F"/" '{printf("%s/%s",$4,$5)}'`
    headString="<h2 id=\""$2"\"> "$2". "${tempVar}"</h2>"
    echo $2
    startString="\`\`\` prolog "
    endString="\`\`\` "
       #echo "" >>summary.sh
    #echo -e "\033[44;37m -------------------<<<<<<<<<"$1" started>>>>>>>>>-------------------\033[0m" >>summary.sh
    #echo  "# -------------------<<<<<<<<<"$1" started>>>>>>>>>-------------------" >>summary.sh
    echo "+ ["$2". "$tempVar"](#"$2")" >> structure.sh
    echo "<br/>" >> summary.sh
    echo "<hr/>" >> summary.sh
    echo "<br/>" >> summary.sh
    echo $headString >> summary.sh
    echo "" >> summary.sh
    echo $startString >> summary.sh
   # echo "#" >>summary.sh
   # echo "#" >>summary.sh
    sed -n 'p' $1 >> summary.sh
    #echo "#" >>summary.sh
    #echo "#" >>summary.sh
    #echo -e "\033[43;37m --------------------<<<<<<<<<"$1" ended >>>>>>>>>-------------------\033[0m" >> summary.sh
    #echo "# --------------------<<<<<<<<<"$1" ended >>>>>>>>>-------------------" >> summary.sh
    echo "" >> summary.sh
    echo $endString >> summary.sh
    #echo "<hr/>" >>summary.sh
    echo "" >> summary.sh
    echo "" >> summary.sh

}

## variable initial 
currentDir=`pwd`


## processing information 
# 如果存在 summary.sh 证明已经存在了，就先把删掉， 因为这里是
# 采用追加的方式，而不是写入。
if [[ -e ./summary.sh ]]
then 
    rm -rf ./summary.sh
fi
if [[ -e ./structure.sh ]]
then 
    rm -rf ./structure.sh
fi

# 调用产生所有的文件夹内的数据到一个文件中
generateChapter
cat summary.sh >> structure.sh


```

所以必须得修改以下所有文章，

+ [99-problems-with-prolog(Running)][3]
+ [Learn Prolog Now Theroy and Example][4]
+ [The Art of Prolog practice(Running)][6]


[1]:http://jueqingsizhe66.github.io/blog/2016/08/06/linux-shell-summary/ 
[2]:http://jueqingsizhe66.github.io/blog/2016/08/12/some-hacks-from-the-vim-101-hacks/ 
[3]:http://jueqingsizhe66.github.io/blog/2016/07/28/99-problems-with-prolog-running/ 
[4]:http://jueqingsizhe66.github.io/blog/2016/08/01/learn-prolog-now-theroy-and-example/ 
[5]:http://jueqingsizhe66.github.io/blog/2016/07/28/the-art-of-prolog-practice-running/#tool 
[6]:http://jueqingsizhe66.github.io/blog/2016/07/28/the-art-of-prolog-practice-running/ 
[7]:http://www.2cto.com/os/201404/296597.html 
[8]:http://jueqingsizhe66.github.io/blog/2016/08/06/linux-shell-summary/awk 
