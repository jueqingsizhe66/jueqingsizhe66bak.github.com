---
layout: post
title: "能真正教会你编程能力的是重写"
date: 2016-04-15 21:50:10 +0800
comments: true
categories: scheme
---

写了很多的matlab，感觉就那样！
编了那么多数值fortran代码，也不见自己编程有多厉害！
练了那么多的java项目，也感觉自己的技术还不见飞涨！
用c语言摸索了好几年，也没见得有太深的见地！

真正决定你对程序的深入理解，需要你去认识[EOPL][3]或者[SICP][2]，亦或者更简单的[TLS][1].
他们也许不能教你们做大的项目，却真切教会你编写程序，思考程序。
<!--more-->

回想起之前写的java项目，反反复复就为了构造一门解释器语言，用来输送数据到数据库进行操作，不断
在中间进行验证，保证传递数据的有效性，为了搭上这样的一个平台，反复重构了代码，采用了新技术，
不断采用接口来抽象，割分具体的关系，防止数据的污染。

而这样做是为何？ 我之前没理解，后来做了一阶段程序语言设计方面的工作，写了多个解释器之后，我才发现总是基于
存在（任意）某一变量某一程序供你使用，你的目的就是使用这个程序或者变量来实现他的能力！然而为了懒惰，
你创建了很多工具（其实，应该是重构，重写）来不断让你的写的东西少点，同时能够达到更多的功能。

这过程不好经历，也不好做，很多人也很少做，有些人不需要做，更多人没想做。大部分的企业级程序也不会教你去实现这一过程，
也不会跟你从程序理论去介绍。架空程序理论，完成一系列的工程项目成为了很多人编程的主要目的。减少深入思考的时间，
追逐敏捷性编程方式，忽略了闲暇的编程时间，一味着实现需求，个人感觉不是一个好的归宿、目的、追求，但却是一种好的生活手段、工作方式、效率实现。

编程在我眼里是慢工出细活，所谓的快速开发的提出，我就不好奇，因为我不合适它。真正能够进一步提供自己对于写过程序理解，应该要自己能够写出一个解释器解释你写的程序，这个可以体现在[TLS][1],  [TSS][4]  [EOPL][3],  [SICP][2]等。

1. let解释器
2. letrec解释器
3. proc解释器
4. state解释器
5. cps解释器
6. type解释器
7. oo解释器
8. typeoo解释器



[1]:http://www.ccs.neu.edu/home/matthias/BTLS/ 
[2]:https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start 
[3]:http://www.eopl3.com/ 
[4]:http://www.ccs.neu.edu/home/matthias/BTSS/ 
